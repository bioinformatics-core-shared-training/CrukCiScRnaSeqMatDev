[["index.html", "CRUK Bioinformatics Summer School 2020 - single-cell RNA-seq analysis Heterogeneity in childhood acute lymphoblastic leukemia with droplet-based 10X Chromium assay. Chapter 1 Preamble 1.1 The study 1.2 The plan 1.3 The analyses 1.4 Overall summary 1.5 Conclusion 1.6 Abbreviations", " CRUK Bioinformatics Summer School 2020 - single-cell RNA-seq analysis Heterogeneity in childhood acute lymphoblastic leukemia with droplet-based 10X Chromium assay. Stephane Ballereau, Zeynep Kalender Atak 2021-04-27 Chapter 1 Preamble 1.1 The study “Childhood acute lymphoblastic leukemia (cALL) is the most common pediatric cancer. It is characterized by bone marrow lymphoid precursors that acquire genetic alterations, resulting in disrupted maturation and uncontrollable proliferation.” Caron et al. 2020. Nowaways, up to 85–90% of patients are cured, but others do not respond to treatment or relapse and die. The aim of the study is to characterise the heterogeneity of gene expression at the cell level, within and between patients. Four type of samples are considered: eight patients: six B-ALL two T-ALL three healthy pediatric controls eight healthy adult controls, publicly available As the study aims at identifying cell populations, large numbers of cells were sequenced with the droplet-based 10X Chromium assay. 1.2 The plan We will follow several steps: sequencing quality check alignment of reads to the human genome (GRCh38) with 10X software cellranger quality control (cell calls, cells and genes filtering) count normalisation data set integration feature selection dimensionality reduction clustering marker gene identification cell type annotation cell cycle assignment trajectory analysis 1.3 The analyses This report includes: Sequence Quality is good (see 2) cellranger output suggests the data sets are good quality (see 3) Quality control - a first glance at the RNA data set comprising all droplets deemed to contain at leat one cell, to check the data quality and biological signal (eg. do we observe cell types we expect?) (see 4 for the ‘all-cells’ analysis and 5 for the analysis of the downsampled data set to use in the course) an annotation of RNA clusters using known PBMC marker genes (see ??) 1.4 Overall summary 1.5 Conclusion 1.6 Abbreviations BMMC: Bone Marrow Mononuclear Cell HCA: Human Cell Atlas PCA: Principal Component Analysis UMI: Unique Molecular Identifier #projDirOsx &lt;- &quot;/Users/baller01/MyMount/clust1a/20200511_FernandesM_ME_crukBiSs2020&quot; #projDir &lt;- &quot;/mnt/scratcha/bioinformatics/baller01/20200511_FernandesM_ME_crukBiSs2020&quot; #projDir &lt;- &quot;/home/ubuntu/Course_Materials/scRNAseq&quot; projDir &lt;- params$projDir projDirLink &lt;- &quot;/Users/baller01/MyMount/svr008ssd/20200511_FernandesM_ME_crukBiSs2020&quot; inpDirBit &lt;- params$inpDirBit outDirBit &lt;- params$outDirBit library(DT) "],["SeqQualTop.html", "Chapter 2 Sequence Quality 2.1 Introduction 2.2 CaronBourque2020 - fastqc 2.3 CaronBourque2020 - MultiQC 2.4 HCA adult BMMC - fastqc 2.5 HCA adult BMMC - MultiQC", " Chapter 2 Sequence Quality 2.1 Introduction We will use two sets of Bone Marrow Mononuclear Cells (BMMC): ‘CaronBourque2020’: pediatric samples ‘Hca’: HCA Census of Immune Cells for adult BMMCs Fastq files were retrieved from publicly available archive (SRA and HCA). Sequencing quality was assessed and visualised using fastQC and MultiQC. Library structure reminder: The sample index identifies the library, with one I7 index per sample The 10X cell barcode (or cell index) identifies the droplet in the library The UMI identifies the transcript molecule within a cell and gene The insert is the transcript molecule, ie the cDNA sequence Each sample is described with three sets of fastq files: I1: sample index R1: 10x barcode + UMI R2: insert sequence The sample index is actually a set of four 8-ntd oligo. For example SIGAB8 is ‘AAAGTGCT-GCTACCTG-TGCTGTAA-CTGCAAGC’. All four are used and identified by a digit, eg 1-4. Depending on the processing pipeline, fastq files may be returned for each 8-ntd index, or combined into a single file. For the Caron data set they are combined in a single file, and files for separate lanes were also combined into a single fastq file. Each sample is identified by three fastq files, one per read type: sample _ S0 _ L001 _ I1 _ 001 _ .fastq.gz: contains sample index sample _ S0 _ L001 _ R1 _ 001 _ .fastq.gz: contains 10x barcode + UMI sample _ S0 _ L001 _ R2 _ 001 _ .fastq.gz: contains insert sequence We kept the same names for the fastqc output. With for example sample ‘SRR9264343’: SRR9264343 _ S0 _ L001 _ I1 _ 001 _ fastqc.html SRR9264343 _ S0 _ L001 _ R1 _ 001 _ fastqc.html SRR9264343 _ S0 _ L001 _ R2 _ 001 _ fastqc.html fastqcDir &lt;- sprintf(&quot;%s/Data/%s/fastqc&quot;, projDir, &quot;CaronBourque2020&quot;) fastqcDirLink &lt;- sprintf(&quot;%s/Data/%s/fastqc&quot;, projDirLink, &quot;CaronBourque2020&quot;) 2.2 CaronBourque2020 - fastqc # CaronBourque2020 cb_sampleSheetFn &lt;- file.path(projDir, &quot;Data/CaronBourque2020/SraRunTable.txt&quot;) cb_sampleSheet &lt;- read.table(cb_sampleSheetFn, header=T, sep=&quot;,&quot;) #cb_sampleSheet &lt;- cb_sampleSheet %&gt;% filter(!Run == &quot;SRR9264351&quot;) cb_sampleSheet ## Run Assay.Type AvgSpotLen Bases BioProject BioSample ## 1 SRR9264343 RNA-Seq 132 27850288884 PRJNA548203 SAMN12011162 ## 2 SRR9264344 RNA-Seq 132 43613421192 PRJNA548203 SAMN12011172 ## 3 SRR9264345 RNA-Seq 132 43838527392 PRJNA548203 SAMN12011171 ## 4 SRR9264346 RNA-Seq 132 39752529300 PRJNA548203 SAMN12011170 ## 5 SRR9264347 RNA-Seq 132 41035092252 PRJNA548203 SAMN12011169 ## 6 SRR9264348 RNA-Seq 132 42840756288 PRJNA548203 SAMN12011168 ## 7 SRR9264349 RNA-Seq 132 42953865372 PRJNA548203 SAMN12011167 ## 8 SRR9264350 RNA-Seq 132 42822420960 PRJNA548203 SAMN12011166 ## 9 SRR9264351 RNA-Seq 132 28322630028 PRJNA548203 SAMN12011165 ## 10 SRR9264352 RNA-Seq 132 36199482528 PRJNA548203 SAMN12011165 ## 11 SRR9264353 RNA-Seq 132 41446760124 PRJNA548203 SAMN12011164 ## 12 SRR9264354 RNA-Seq 132 42802129128 PRJNA548203 SAMN12011163 ## Bytes ## 1 18644549905 ## 2 27638885644 ## 3 28054431102 ## 4 25564104997 ## 5 24777477094 ## 6 27432674292 ## 7 27523442193 ## 8 27282064655 ## 9 19040444664 ## 10 22143300246 ## 11 26850120365 ## 12 27774281557 ## Cell_type ## 1 Pre-B t(12;21) [ETV6-RUNX1] acute lymphoblastic leukemia cells ## 2 Pre-B t(12;21) [ETV6-RUNX1] acute lymphoblastic leukemia cells ## 3 Pre-B t(12;21) [ETV6-RUNX1] acute lymphoblastic leukemia cells ## 4 Pre-B t(12;21) [ETV6-RUNX1] acute lymphoblastic leukemia cells ## 5 Pre-B High hyper diploid [HHD] acute lymphoblastic leukemia cells ## 6 Pre-B High hyper diploid [HHD] acute lymphoblastic leukemia cells ## 7 Pre-T acute lymphoblastic leukemia cells ## 8 Pre-T acute lymphoblastic leukemia cells ## 9 Healthy pediatric bone marrow mononuclear cells ## 10 Healthy pediatric bone marrow mononuclear cells ## 11 Healthy pediatric bone marrow mononuclear cells ## 12 Healthy pediatric bone marrow mononuclear cells ## Center.Name Consent DATASTORE.filetype DATASTORE.provider ## 1 GEO public fastq,sra gs,ncbi,s3 ## 2 GEO public fastq,sra gs,ncbi,s3 ## 3 GEO public fastq,sra gs,ncbi,s3 ## 4 GEO public fastq,sra gs,ncbi,s3 ## 5 GEO public fastq,sra gs,ncbi,s3 ## 6 GEO public fastq,sra gs,ncbi,s3 ## 7 GEO public fastq,sra gs,ncbi,s3 ## 8 GEO public fastq,sra gs,ncbi,s3 ## 9 GEO public fastq,sra gs,ncbi,s3 ## 10 GEO public fastq,sra gs,ncbi,s3 ## 11 GEO public fastq,sra gs,ncbi,s3 ## 12 GEO public fastq,sra gs,ncbi,s3 ## DATASTORE.region disease_state ## 1 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 2 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 3 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 4 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 5 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 6 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 7 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 8 gs.US,ncbi.public,s3.us-east-1 Childhood acute lymphoblastic leukemia ## 9 gs.US,ncbi.public,s3.us-east-1 Healthy pediatric control ## 10 gs.US,ncbi.public,s3.us-east-1 Healthy pediatric control ## 11 gs.US,ncbi.public,s3.us-east-1 Healthy pediatric control ## 12 gs.US,ncbi.public,s3.us-east-1 Healthy pediatric control ## Experiment GEO_Accession..exp. Instrument LibraryLayout ## 1 SRX6034681 GSM3872434 Illumina HiSeq 4000 PAIRED ## 2 SRX6034682 GSM3872435 Illumina HiSeq 4000 PAIRED ## 3 SRX6034683 GSM3872436 Illumina HiSeq 4000 PAIRED ## 4 SRX6034684 GSM3872437 Illumina HiSeq 4000 PAIRED ## 5 SRX6034685 GSM3872438 Illumina HiSeq 4000 PAIRED ## 6 SRX6034686 GSM3872439 Illumina HiSeq 4000 PAIRED ## 7 SRX6034687 GSM3872440 Illumina HiSeq 4000 PAIRED ## 8 SRX6034688 GSM3872441 Illumina HiSeq 4000 PAIRED ## 9 SRX6034689 GSM3872442 Illumina HiSeq 4000 PAIRED ## 10 SRX6034689 GSM3872442 Illumina HiSeq 4000 PAIRED ## 11 SRX6034690 GSM3872443 Illumina HiSeq 4000 PAIRED ## 12 SRX6034691 GSM3872444 Illumina HiSeq 4000 PAIRED ## LibrarySelection LibrarySource Organism Platform ReleaseDate ## 1 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 2 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 3 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 4 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 5 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 6 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 7 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 8 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 9 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 10 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 11 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## 12 cDNA TRANSCRIPTOMIC Homo sapiens ILLUMINA 2020-02-14T00:00:00Z ## Sample.Name source_name SRA.Study ## 1 GSM3872434 ETV6-RUNX1 SRP201012 ## 2 GSM3872435 ETV6-RUNX1 SRP201012 ## 3 GSM3872436 ETV6-RUNX1 SRP201012 ## 4 GSM3872437 ETV6-RUNX1 SRP201012 ## 5 GSM3872438 HHD SRP201012 ## 6 GSM3872439 HHD SRP201012 ## 7 GSM3872440 PRE-T SRP201012 ## 8 GSM3872441 PRE-T SRP201012 ## 9 GSM3872442 PBMMC SRP201012 ## 10 GSM3872442 PBMMC SRP201012 ## 11 GSM3872443 PBMMC SRP201012 ## 12 GSM3872444 PBMMC SRP201012 htmlVec &lt;- list.files(fastqcDir) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) filesDf &lt;- data.frame( &quot;I1&quot; = sprintf(&quot;%s_S0_L001_%s_001_fastqc.html&quot;, cb_sampleSheet$Run, &quot;I1&quot;), &quot;R1&quot; = sprintf(&quot;%s_S0_L001_%s_001_fastqc.html&quot;, cb_sampleSheet$Run, &quot;R1&quot;), &quot;R2&quot; = sprintf(&quot;%s_S0_L001_%s_001_fastqc.html&quot;, cb_sampleSheet$Run, &quot;R2&quot;) ) rownames(filesDf) &lt;- cb_sampleSheet$Run for (runx in cb_sampleSheet$Run) { cat(&quot;Run &quot;, runx, &quot;:\\n\\n&quot;) for(i in c(&quot;I1&quot;, &quot;R1&quot;, &quot;R2&quot;)) { #filepath &lt;- file.path(fastqcDir, filesDf[runx,i]) filepath &lt;- file.path(fastqcDirLink, filesDf[runx,i]) cat(i, &quot;: [&quot;, filesDf[runx,i], &quot;](&quot;,filepath,&quot;)\\n\\n&quot;) } } Run SRR9264343 : I1 : SRR9264343_S0_L001_I1_001_fastqc.html R1 : SRR9264343_S0_L001_R1_001_fastqc.html R2 : SRR9264343_S0_L001_R2_001_fastqc.html Run SRR9264344 : I1 : SRR9264344_S0_L001_I1_001_fastqc.html R1 : SRR9264344_S0_L001_R1_001_fastqc.html R2 : SRR9264344_S0_L001_R2_001_fastqc.html Run SRR9264345 : I1 : SRR9264345_S0_L001_I1_001_fastqc.html R1 : SRR9264345_S0_L001_R1_001_fastqc.html R2 : SRR9264345_S0_L001_R2_001_fastqc.html Run SRR9264346 : I1 : SRR9264346_S0_L001_I1_001_fastqc.html R1 : SRR9264346_S0_L001_R1_001_fastqc.html R2 : SRR9264346_S0_L001_R2_001_fastqc.html Run SRR9264347 : I1 : SRR9264347_S0_L001_I1_001_fastqc.html R1 : SRR9264347_S0_L001_R1_001_fastqc.html R2 : SRR9264347_S0_L001_R2_001_fastqc.html Run SRR9264348 : I1 : SRR9264348_S0_L001_I1_001_fastqc.html R1 : SRR9264348_S0_L001_R1_001_fastqc.html R2 : SRR9264348_S0_L001_R2_001_fastqc.html Run SRR9264349 : I1 : SRR9264349_S0_L001_I1_001_fastqc.html R1 : SRR9264349_S0_L001_R1_001_fastqc.html R2 : SRR9264349_S0_L001_R2_001_fastqc.html Run SRR9264350 : I1 : SRR9264350_S0_L001_I1_001_fastqc.html R1 : SRR9264350_S0_L001_R1_001_fastqc.html R2 : SRR9264350_S0_L001_R2_001_fastqc.html Run SRR9264351 : I1 : SRR9264351_S0_L001_I1_001_fastqc.html R1 : SRR9264351_S0_L001_R1_001_fastqc.html R2 : SRR9264351_S0_L001_R2_001_fastqc.html Run SRR9264352 : I1 : SRR9264352_S0_L001_I1_001_fastqc.html R1 : SRR9264352_S0_L001_R1_001_fastqc.html R2 : SRR9264352_S0_L001_R2_001_fastqc.html Run SRR9264353 : I1 : SRR9264353_S0_L001_I1_001_fastqc.html R1 : SRR9264353_S0_L001_R1_001_fastqc.html R2 : SRR9264353_S0_L001_R2_001_fastqc.html Run SRR9264354 : I1 : SRR9264354_S0_L001_I1_001_fastqc.html R1 : SRR9264354_S0_L001_R1_001_fastqc.html R2 : SRR9264354_S0_L001_R2_001_fastqc.html 2.3 CaronBourque2020 - MultiQC 2.3.1 sample index: I1 htmlVec &lt;- list.files(paste0(fastqcDir, &quot;/Multiqc/I1&quot;)) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) for(i in htmlVec){ filename &lt;- file.path(fastqcDirLink, &quot;/Multiqc/I1&quot;, i) cat(&quot;[&quot;, i, &quot;](&quot;,filename,&quot;)\\n\\n&quot;) } multiqc_report.html 2.3.2 cell barcode + UMI: R1 htmlVec &lt;- list.files(paste0(fastqcDir, &quot;/Multiqc/R1&quot;)) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) for(i in htmlVec){ filename &lt;- file.path(fastqcDirLink, &quot;/Multiqc/R1&quot;, i) cat(&quot;[&quot;, i, &quot;](&quot;,filename,&quot;)\\n\\n&quot;) } multiqc_report.html 2.3.3 insert: R2 htmlVec &lt;- list.files(paste0(fastqcDir, &quot;/Multiqc/R2&quot;)) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) for(i in htmlVec){ filename &lt;- file.path(fastqcDirLink, &quot;/Multiqc/R2&quot;, i) cat(&quot;[&quot;, i, &quot;](&quot;,filename,&quot;)\\n\\n&quot;) } multiqc_report.html 2.4 HCA adult BMMC - fastqc For the HCA adult BMMC fastq files were provided for each 8-ntd sample index and lane. We ran fastqc on each separately. We are therefore not listing links to the fastqc reports but only to the MultiQC reports. fastqcDir &lt;- sprintf(&quot;%s/Data/%s/fastqc&quot;, projDir, &quot;Hca&quot;) fastqcDirLink &lt;- sprintf(&quot;%s/Data/%s/fastqc&quot;, projDirLink, &quot;Hca&quot;) # HCA hca_sampleSheetFn &lt;- file.path(projDir, &quot;Data/Hca/accList_Hca.txt&quot;) hca_sampleSheet &lt;- read.table(hca_sampleSheetFn, header=F, sep=&quot;,&quot;) colnames(hca_sampleSheet) &lt;- &quot;Run&quot; hca_sampleSheet ## Run ## 1 MantonBM1 ## 2 MantonBM2 ## 3 MantonBM3 ## 4 MantonBM4 ## 5 MantonBM5 ## 6 MantonBM6 ## 7 MantonBM7 ## 8 MantonBM8 htmlVec &lt;- list.files(fastqcDir) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) 378 fastqc reports were compiled in the multiQC reports below. 2.5 HCA adult BMMC - MultiQC 2.5.1 sample index: I1 htmlVec &lt;- list.files(paste0(fastqcDir, &quot;/Multiqc/I1&quot;)) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) for(i in htmlVec){ filename &lt;- file.path(fastqcDirLink, &quot;/Multiqc/I1&quot;, i) cat(&quot;[&quot;, i, &quot;](&quot;,filename,&quot;)\\n\\n&quot;) } multiqc_report.html 2.5.2 cell barcode + UMI: R1 htmlVec &lt;- list.files(paste0(fastqcDir, &quot;/Multiqc/R1&quot;)) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) for(i in htmlVec){ filename &lt;- file.path(fastqcDirLink, &quot;/Multiqc/R1&quot;, i) cat(&quot;[&quot;, i, &quot;](&quot;,filename,&quot;)\\n\\n&quot;) } multiqc_report.html 2.5.3 insert: R2 htmlVec &lt;- list.files(paste0(fastqcDir, &quot;/Multiqc/R2&quot;)) htmlVec &lt;- grep(&quot;\\\\.html$&quot;, htmlVec, value=TRUE) for(i in htmlVec){ filename &lt;- file.path(fastqcDirLink, &quot;/Multiqc/R2&quot;, i) cat(&quot;[&quot;, i, &quot;](&quot;,filename,&quot;)\\n\\n&quot;) } multiqc_report.html WORKING DOCUMENT - IN PROGRESS library(dplyr) "],["AliFeatCountTop.html", "Chapter 3 Alignment and feature counting 3.1 Introduction 3.2 10X cellranger pipeline in brief 3.3 sample sheet 3.4 10X cellranger reports for CaronBourque2020 3.5 10X cellranger reports for HCA’s adult BMMCs", " Chapter 3 Alignment and feature counting 3.1 Introduction We will use two sets of Bone Marrow Mononuclear Cells (BMMC): ‘CaronBourque2020’: pediatric samples ‘Hca’: HCA Census of Immune Cells for adult BMMCs Fastq files were retrieved from publicly available archive (SRA and HCA). Sequencing quality was assessed and visualised using fastQC and MultiQC. Reads were aligned against GRCh38 and features counted using cellranger (v3.1.0). #wrkDir &lt;- &quot;/mnt/scratchb/bioinformatics/baller01/20200511_FernandesM_ME_crukBiSs2020/CaronBourque2020/grch38300&quot; #setwd(wrkDir) projDir &lt;- params$projDir #projDirLink &lt;- &quot;/Users/baller01/MyMount/svr008ssd/20200511_FernandesM_ME_crukBiSs2020&quot; projDirLink &lt;- gsub(&quot;/ssd/personal/baller01&quot;, &quot;/Users/baller01/MyMount/svr008ssd&quot;, projDir) inpDirBit &lt;- params$inpDirBit # &quot;AnaWiSeurat/Attempt1&quot; outDirBit &lt;- params$outDirBit # &quot;AnaWiSeurat/Attempt1&quot; plotDir &lt;- &quot;QcPlots&quot; # eg # cellrangerDirLink &lt;- sprintf(&quot;%s/%s/grch38300&quot;, projDirLink, &quot;CaronBourque2020&quot;) 3.2 10X cellranger pipeline in brief Each sample was analysed separately with cellranger. This pipeline “is a set of analysis pipelines that process Chromium single-cell RNA-seq output to align reads, generate feature-barcode matrices and perform clustering and gene expression analysis.” TODO Add code to call cellranger 3.3 sample sheet # CaronBourque2020 cb_sampleSheetFn &lt;- file.path(projDir, &quot;Data/CaronBourque2020/SraRunTable.txt&quot;) # Human Cell Atlas hca_sampleSheetFn &lt;- file.path(projDir, &quot;Data/Hca/accList_Hca.txt&quot;) # read sample sheet in: splShtColToKeep &lt;- c(&quot;Run&quot;, &quot;Sample.Name&quot;, &quot;source_name&quot;) cb_sampleSheet &lt;- read.table(cb_sampleSheetFn, header=T, sep=&quot;,&quot;) hca_sampleSheet &lt;- read.table(hca_sampleSheetFn, header=F, sep=&quot;,&quot;) colnames(hca_sampleSheet) &lt;- &quot;Sample.Name&quot; hca_sampleSheet$Run &lt;- hca_sampleSheet$Sample.Name hca_sampleSheet$source_name &lt;- &quot;ABMMC&quot; # adult BMMC sampleSheetCat &lt;- rbind(cb_sampleSheet[,splShtColToKeep], hca_sampleSheet[,splShtColToKeep]) sampleSheetCat %&gt;% #DT::datatable(options = list(dom=&#39;t&#39;)) DT::datatable(options = list(pageLength = 10)) 3.4 10X cellranger reports for CaronBourque2020 #cellrangerDir &lt;- sprintf(&quot;%s/%s/grch38300&quot;, projDir, &quot;CaronBourque2020&quot;) #projDirOsx &lt;- &quot;/Users/baller01/MyMount/clust1b/20200511_FernandesM_ME_crukBiSs2020&quot; # make dir name for each sample of interest # with &#39;Run&#39; column sampleSheet &lt;- sampleSheetCat %&gt;% filter(! source_name == &quot;ABMMC&quot;) cellrangerDirLink &lt;- sprintf(&quot;%s/%s/grch38300&quot;, projDirLink, &quot;CaronBourque2020&quot;) htmlVec &lt;- sprintf(&quot;%s/%s/%s/outs/web_summary.html&quot;, cellrangerDirLink, sampleSheet$Run, sampleSheet$Run) names(htmlVec) &lt;- sampleSheet$Run for(i in 1:length(htmlVec)){ cat(&quot;[&quot;, names(htmlVec)[i], &quot;](&quot;, htmlVec[i],&quot;)\\n\\n&quot;) } SRR9264343 SRR9264344 SRR9264345 SRR9264346 SRR9264347 SRR9264348 SRR9264349 SRR9264350 SRR9264351 SRR9264352 SRR9264353 SRR9264354 # TODO: add links to sample sheet and show with DT::datatable 3.5 10X cellranger reports for HCA’s adult BMMCs #cellrangerDir &lt;- sprintf(&quot;%s/%s/grch38300&quot;, projDir, &quot;CaronBourque2020&quot;) #projDirOsx &lt;- &quot;/Users/baller01/MyMount/clust1b/20200511_FernandesM_ME_crukBiSs2020&quot; # make dir name for each sample of interest # with &#39;Run&#39; column sampleSheet &lt;- sampleSheetCat %&gt;% filter(source_name == &quot;ABMMC&quot;) cellrangerDirLink &lt;- sprintf(&quot;%s/%s/grch38300&quot;, projDirLink, &quot;Hca&quot;) htmlVec &lt;- sprintf(&quot;%s/%s/%s/outs/web_summary.html&quot;, cellrangerDirLink, sampleSheet$Run, sampleSheet$Run) names(htmlVec) &lt;- sampleSheet$Run for(i in 1:length(htmlVec)){ cat(&quot;[&quot;, names(htmlVec)[i], &quot;](&quot;, htmlVec[i],&quot;)\\n\\n&quot;) } MantonBM1 MantonBM2 MantonBM3 MantonBM4 MantonBM5 MantonBM6 MantonBM7 MantonBM8 "],["PreProcAllCellsTop.html", "Chapter 4 Quality Control 4.1 Introduction 4.2 Load packages 4.3 Sample sheet 4.4 Data representation 4.5 Example 4.6 Mapping QC 4.7 Cell calling for droplet data 4.8 Load filtered matrices 4.9 Properties of scRNA-seq data 4.10 Quality control 4.11 Identification of low-quality cells with adaptive thresholds 4.12 Experimental factors 4.13 Novelty 4.14 QC based on sparsity 4.15 Subsample Hca set 4.16 Session information", " Chapter 4 Quality Control 4.1 Introduction We will use two sets of Bone Marrow Mononuclear Cells (BMMC): ‘CaronBourque2020’: pediatric samples ‘Hca’: HCA Census of Immune Cells for adult BMMCs Fastq files were retrieved from publicly available archive (SRA and HCA). Sequencing quality was assessed and visualised using fastQC and MultiQC. Reads were aligned against GRCh38 and features counted using cellranger (v3.1.0). We will now check the quality of the data further: mapping quality and amplification rate cell counts distribution of keys quality metrics We will then: filter genes with very low expression identify low-quality cells filter and/or mark low quality cells 4.2 Load packages SingleCellExperiment - to store the data Matrix - to deal with sparse and/or large matrices DropletUtils - utilities for the analysis of droplet-based, inc. cell counting scater - QC scran - normalisation igraph - graphs biomaRt - for gene annotation ggplot2 - for plotting irlba - for faster PCA #projDir &lt;- &quot;/home/ubuntu/Course_Materials/scRNAseq&quot; projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit setSuf &lt;- params$setSuf # with merge-knit # params are read once only. # but we need to change one param value: dirRel # 3 solutions: # - unlock bindings to edit the global value # - copy params to edit and use the local copy # - simply set dirRel, based on type of merging if need be. # unlock binding # (but should remember to set back to init value if need be) #bindingIsLocked(&quot;params&quot;, env = .GlobalEnv) #unlockBinding(&quot;params&quot;, env = .GlobalEnv) #params$stuff &lt;- &#39;toto&#39; # OR: # global_params &lt;- params; # if merge-knit # have local copy of params to edit and use here #local_params &lt;- params; # if merge-knit #local_params$stuff &lt;- &#39;toto&#39; # OR: # if merge-knit, edit params. if(params$bookType == &quot;mk&quot;){ setName &lt;- &quot;caron&quot; setSuf &lt;- &quot;_allCells&quot; dirRel &lt;- &quot;..&quot; } # other variables: wrkDir &lt;- sprintf(&quot;%s/CaronBourque2020/grch38300&quot;, projDir) qcPlotDirBit &lt;- &quot;Plots/Qc&quot; poolBool &lt;- TRUE # FALSE # whether to read each sample in and pool them and write object to file, or just load that file. biomartBool &lt;- FALSE # biomaRt sometimes fails, do it once, write to file and use that copy. addQcBool &lt;- TRUE # FALSE runAll &lt;- FALSE # TRUE dir.create(sprintf(&quot;%s/%s/%s&quot;, projDir, outDirBit, qcPlotDirBit), showWarnings = FALSE, recursive = TRUE) 4.3 Sample sheet We will load both the Caron and Hca data sets. # CaronBourque2020 cb_sampleSheetFn &lt;- file.path(projDir, &quot;Data/CaronBourque2020/SraRunTable.txt&quot;) # Human Cell Atlas hca_sampleSheetFn &lt;- file.path(projDir, &quot;Data/Hca/accList_Hca.txt&quot;) # read sample sheet in: splShtColToKeep &lt;- c(&quot;Run&quot;, &quot;Sample.Name&quot;, &quot;source_name&quot;) cb_sampleSheet &lt;- read.table(cb_sampleSheetFn, header=T, sep=&quot;,&quot;) hca_sampleSheet &lt;- read.table(hca_sampleSheetFn, header=F, sep=&quot;,&quot;) colnames(hca_sampleSheet) &lt;- &quot;Sample.Name&quot; hca_sampleSheet$Run &lt;- hca_sampleSheet$Sample.Name hca_sampleSheet$source_name &lt;- &quot;ABMMC&quot; # adult BMMC sampleSheet &lt;- rbind(cb_sampleSheet[,splShtColToKeep], hca_sampleSheet[,splShtColToKeep]) sampleSheet %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) 4.4 Data representation We will use a SingleCellExperiment object that is described here and stores various data types: the count matrix feature (gene) annotation droplet annotation outcome of downstream analysis such as dimensionality reduction tmpFn &lt;- sprintf(&quot;%s/Images/tenxLibStructureV3.png&quot;, &quot;..&quot;) knitr::include_graphics(tmpFn, auto_pdf = TRUE) 4.5 Example We will load the data for the first sample in the sample sheet: SRR9264343. i &lt;- 1 sample.path &lt;- sprintf(&quot;%s/%s/%s/outs/raw_feature_bc_matrix/&quot;, wrkDir, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) sce.raw &lt;- read10xCounts(sample.path, col.names=TRUE) sce.raw ## class: SingleCellExperiment ## dim: 33538 737280 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ... ## TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## altExpNames(0): We can access these different types of data with various functions. Number of genes and droplets in the count matrix: dim(counts(sce.raw)) ## [1] 33538 737280 Features, with rowData(): head(rowData(sce.raw)) ## DataFrame with 6 rows and 3 columns ## ID Symbol Type ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000243485 ENSG00000243485 MIR1302-2HG Gene Expression ## ENSG00000237613 ENSG00000237613 FAM138A Gene Expression ## ENSG00000186092 ENSG00000186092 OR4F5 Gene Expression ## ENSG00000238009 ENSG00000238009 AL627309.1 Gene Expression ## ENSG00000239945 ENSG00000239945 AL627309.3 Gene Expression ## ENSG00000239906 ENSG00000239906 AL627309.2 Gene Expression Samples, with colData(): head(colData(sce.raw)) ## DataFrame with 6 rows and 2 columns ## Sample Barcode ## &lt;character&gt; &lt;character&gt; ## AAACCTGAGAAACCAT-1 /ssd/personal/baller.. AAACCTGAGAAACCAT-1 ## AAACCTGAGAAACCGC-1 /ssd/personal/baller.. AAACCTGAGAAACCGC-1 ## AAACCTGAGAAACCTA-1 /ssd/personal/baller.. AAACCTGAGAAACCTA-1 ## AAACCTGAGAAACGAG-1 /ssd/personal/baller.. AAACCTGAGAAACGAG-1 ## AAACCTGAGAAACGCC-1 /ssd/personal/baller.. AAACCTGAGAAACGCC-1 ## AAACCTGAGAAAGTGG-1 /ssd/personal/baller.. AAACCTGAGAAAGTGG-1 Single-cell RNA-seq data compared to bulk RNA-seq is sparse, especially with droplet-based methods such as 10X, mostly because: a given cell does not express each gene the library preparation does not capture all transcript the cell does express the sequencing depth per cell is far lower Counts, with counts(). Given the large number of droplets in a sample, count matrices can be large. They are however very sparse and can be stored in a ‘sparse matrix’ that only stores non-zero values, for example a ‘dgCMatrix’ object (‘DelayedArray’ class). counts(sce.raw) &lt;- as(counts(sce.raw), &quot;dgCMatrix&quot;) #class(counts(sce.raw)) counts(sce.raw)[1:10, 1:10] ## 10 x 10 sparse Matrix of class &quot;dgCMatrix&quot; ## ## ENSG00000243485 . . . . . . . . . . ## ENSG00000237613 . . . . . . . . . . ## ENSG00000186092 . . . . . . . . . . ## ENSG00000238009 . . . . . . . . . . ## ENSG00000239945 . . . . . . . . . . ## ENSG00000239906 . . . . . . . . . . ## ENSG00000241599 . . . . . . . . . . ## ENSG00000236601 . . . . . . . . . . ## ENSG00000284733 . . . . . . . . . . ## ENSG00000235146 . . . . . . . . . . 4.6 Mapping QC 4.6.1 Gene body coverage The plot below show the average coverage (y-axis) along the body of genes (x-axis). tmpFn &lt;- sprintf(&quot;%s/Images/1_AAACCTGAGACTTTCG-1.rseqcGeneBodyCovCheck.txt.geneBodyCoverage.curves.png&quot;, &quot;..&quot;) knitr::include_graphics(tmpFn, auto_pdf = TRUE) 4.6.2 Amplification rate We will use the information stored in the ‘molecule info’ file to count the number of UMI and reads for each gene in each cell. ##mol.info.file &lt;- sprintf(&quot;%s/%s/%s/outs/molecule_info.h5&quot;, wrkDir, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) ##mol.info &lt;- read10xMolInfo(mol.info.file) # or mol.info object if issue with H5Fopen mol.info.file &lt;- sprintf(&quot;%s/%s/%s/outs/molecule_info_h5.Rds&quot;, wrkDir, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) mol.info &lt;- readRDS(mol.info.file) # slow # &#39;data&#39; slot: mol.info$data ## DataFrame with 18544666 rows and 5 columns ## cell umi gem_group gene reads ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 AAACCTGAGAAACCTA 467082 1 3287 1 ## 2 AAACCTGAGAAACCTA 205888 1 3446 1 ## 3 AAACCTGAGAAACCTA 866252 1 3896 3 ## 4 AAACCTGAGAAACCTA 796027 1 3969 1 ## 5 AAACCTGAGAAACCTA 542561 1 5008 1 ## ... ... ... ... ... ... ## 18544662 TTTGTCATCTTTAGTC 927060 1 23634 1 ## 18544663 TTTGTCATCTTTAGTC 975865 1 27143 1 ## 18544664 TTTGTCATCTTTAGTC 364964 1 27467 4 ## 18544665 TTTGTCATCTTTAGTC 152570 1 30125 7 ## 18544666 TTTGTCATCTTTAGTC 383230 1 30283 5 # &#39;genes&#39; slot head(mol.info$genes) ## [1] &quot;ENSG00000243485&quot; &quot;ENSG00000237613&quot; &quot;ENSG00000186092&quot; &quot;ENSG00000238009&quot; ## [5] &quot;ENSG00000239945&quot; &quot;ENSG00000239906&quot; # for each cell and gene, count UMIs # slow, but needs running, at least once # so write it to file to load later if need be. tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_preProc_ampDf1.Rds&quot;, projDir, outDirBit) if(!file.exists(tmpFn)) { ampDf &lt;- mol.info$data %&gt;% data.frame() %&gt;% mutate(umi = as.character(umi)) %&gt;% group_by(cell, gene) %&gt;% summarise(nUmis = n(), totReads=sum(reads)) %&gt;% data.frame() # Write object to file saveRDS(ampDf, tmpFn) } else { ampDf &lt;- readRDS(tmpFn) } rm(tmpFn) # distribution of totReads summary(ampDf$totReads) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 2.00 6.00 15.23 12.00 79275.00 # distribution of nUmis summary(ampDf$nUmis) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 1.000 1.000 2.377 1.000 7137.000 # too slow sp &lt;- ggplot(ampDf, aes(x=nUmis, y=totReads)) + geom_point() + scale_x_continuous(trans=&#39;log2&#39;) + scale_y_continuous(trans=&#39;log2&#39;) sp #ggMarginal(sp) sp2 &lt;- ggplot(ampDf, aes(x=nUmis, y=totReads)) + geom_bin2d(bins = 50) + scale_fill_continuous(type = &quot;viridis&quot;) + scale_x_continuous(trans=&#39;log10&#39;) + scale_y_continuous(trans=&#39;log10&#39;) + ggtitle(&quot;totReads vs nUmis&quot;) + theme_bw() sp2 gc(verbose=FALSE) ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 9016602 481.6 16305644 870.9 10352348 552.9 ## Vcells 106811173 815.0 336016856 2563.7 336016856 2563.7 4.7 Cell calling for droplet data For a given sample, amongst the tens of thousands of droplets used in the assay, some will contain a cell while many others will not. The presence of RNA in a droplet will show with non-zero UMI count. This is however not sufficient to infer that the droplet does contain a cell. Indeed, after sample preparation, some cell debris including RNA will still float in the mix. This ambient RNA is unwillignly captured during library preparation and sequenced. Cellranger generates a count matrix that includes all droplets analysed in the assay. We will now load this ‘raw matrix’ for one sample and draw the distribution of UMI counts. Distribution of UMI counts: libSizeDf &lt;- mol.info$data %&gt;% data.frame() %&gt;% mutate(umi = as.character(umi)) %&gt;% group_by(cell) %&gt;% summarise(nUmis = n(), totReads=sum(reads)) %&gt;% data.frame() rm(mol.info) gc() ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 9024917 482.0 16305644 870.9 16305644 870.9 ## Vcells 51521023 393.1 268813485 2050.9 336016856 2563.7 ggplot(libSizeDf, aes(x=log10(nUmis))) + geom_histogram(bins = 50) Library size varies widely, both amongst empty droplets and droplets carrying cells, mostly due to: variation in droplet size, amplification efficiency, sequencing Most cell counting methods try to identify the library size that best distinguishes empty from cell-carrying droplets. 4.7.1 Mixture model This method by default fits a mixture of two normal distributions to the logged library sizes: one with a small mean for empty droplets the other with a higher mean for cell-carrying droplets set.seed(100) # get package library(&quot;mixtools&quot;) # have library sizes on a log10 scale log10_lib_size &lt;- log10(libSizeDf$nUmis) # fit mixture mix &lt;- normalmixEM(log10_lib_size, mu=c(log10(10), log10(100), log10(10000)), maxrestarts=50, epsilon = 1e-03) ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## One of the variances is going to zero; trying new starting values. ## number of iterations= 64 # plot p1 &lt;- dnorm(log10_lib_size, mean=mix$mu[1], sd=mix$sigma[1]) p2 &lt;- dnorm(log10_lib_size, mean=mix$mu[2], sd=mix$sigma[2]) p3 &lt;- dnorm(log10_lib_size, mean=mix$mu[3], sd=mix$sigma[3]) pList &lt;- list(p1, p2, p3) if (mix$mu[1] &lt; mix$mu[2]) { split &lt;- min(log10_lib_size[p1 &lt; p2]) } else { split &lt;- min(log10_lib_size[p2 &lt; p1]) } # find densities with the higest means: i1 &lt;- which(order(mix$mu)==2) i2 &lt;- which(order(mix$mu)==3) # find intersection: dd0 &lt;- data.frame(log10_lib_size=log10_lib_size, #p1, p2, p3) pA=pList[[i1]], pB=pList[[i2]]) split &lt;- dd0 %&gt;% filter(pA &lt; pB &amp; mix$mu[i1] &lt; log10_lib_size) %&gt;% arrange(log10_lib_size) %&gt;% head(n=1) %&gt;% pull(log10_lib_size) # show split on plot: plot(mix, which=2, xlab2=&quot;log10(mol per cell)&quot;) # get density for each distribution: #log10_lib_size &lt;- log10(libSizeDf$nUmis) abline(v=split, lwd=2) dd &lt;- data.frame(log10_lib_size=log10_lib_size, p1, p2, p3) %&gt;% arrange(log10_lib_size) %&gt;% tidyr::pivot_longer(!log10_lib_size, names_to = &quot;curve&quot;, values_to = &quot;density&quot;) head(dd) ggplot(dd, aes(x=log10_lib_size, y=density, col=curve)) + geom_line() 4.7.2 Barcode rank plot The barcode rank plot shows the library sizes against their rank in decreasing order, for the first 10000 droplets only. barcode_rank &lt;- rank(-libSizeDf$nUmis) plot(barcode_rank, libSizeDf$nUmis, xlim=c(1,10000), ylab=&quot;library size&quot;) Given the exponential shape of the curve above, library sizes can be shown on the log10 scale: plot(barcode_rank, log10_lib_size, xlim=c(1,10000)) The plot above shows that the majority of droplets have fewer than 100 UMIs, e.g. droplets with rank greater than 4000. We will redraw the plot to focus on droplets with lower ranks, by using the log10 scale for the x-axis. plot(log10(barcode_rank), log10_lib_size, xlim=log10(c(1,10000))) The point on the curve where it drops sharply may be used as the split point. Before that point library sizes are high, because droplets carry a cell. After that point, library sizes are far smaller because droplets do not carry a cell, only ambient RNA (… or do they?). Here, we could ‘visually’ approximate the number of cells to 2500. There are however more robust and convenient methods. 4.7.3 Inflection point We could also compute the inflection point of the curve. o &lt;- order(barcode_rank) log10_lib_size &lt;- log10_lib_size[o] barcode_rank &lt;- barcode_rank[o] rawdiff &lt;- diff(log10_lib_size)/diff(barcode_rank) inflection &lt;- which(rawdiff == min(rawdiff[100:length(rawdiff)], na.rm=TRUE)) plot(x=log10(barcode_rank), y=log10_lib_size, xlim=log10(c(1,10000))) abline(v=log10(inflection), col=&quot;red&quot;, lwd=2) The inflection is at 3279 UMIs (3.5157414 on the log10 scale). 2306 droplets have at least these many UMIs and would thus contain one cell (or more). 4.7.4 Cellranger v1 and v2 Given an expected number of cells, cellranger used to assume a ~10-fold range of library sizes for real cells and estimate this range (cellranger (v1 and v2). The threshold was defined as the 99th quantile of the library size, divided by 10. # approximate number of cells expected: n_cells &lt;- 2500 # CellRanger totals &lt;- sort(libSizeDf$nUmis, decreasing = TRUE) # 99th percentile of top n_cells divided by 10 thresh = totals[round(0.01*n_cells)]/10 plot(x=log10(seq(1,10000)), y=log10(totals)[1:10000] ) abline(h=log10(thresh), col=&quot;red&quot;, lwd=2) The threshold is at 1452 UMIs and 2773 cells are detected. 4.7.5 DropletUtils and EmptyDrops The DropletUtils package offers utilities to analyse droplet-based data, including cell counting using the library size as seen above. These simple approaches may exclude droplets with small or quiet cells with low RNA content. The emptyDrops method calls cells by first computing the expression profile for droplets with RNA content so low they almost certainly do not contain any cell: the ‘background’ or ‘ambient’ profile. The method then tests each non-background droplet for significant difference in expression profile. Let’s first check the knee and inflection methods. br.out &lt;- barcodeRanks(counts(sce.raw)) plot(br.out$rank, br.out$total, log=&quot;xy&quot;, xlab=&quot;Rank&quot;, ylab=&quot;Total UMI count&quot;) o &lt;- order(br.out$rank) lines(br.out$rank[o], br.out$fitted[o], col=&quot;red&quot;) abline(h=metadata(br.out)$knee, col=&quot;dodgerblue&quot;, lty=2) abline(h=metadata(br.out)$inflection, col=&quot;forestgreen&quot;, lty=2) legend(&quot;bottomleft&quot;, lty=2, col=c(&quot;dodgerblue&quot;, &quot;forestgreen&quot;), legend=c(&quot;knee&quot;, &quot;inflection&quot;)) Testing for empty droplets. We will call cells with a false discovery rate (FDR) of 0.1% so that at most 1 in 1000 droplets called may be empty. # a bit slow # significance is computed by simulation so we set a seed for reproducibility set.seed(100) # run analysis: e.out &lt;- emptyDrops(counts(sce.raw)) e.out ## DataFrame with 737280 rows and 5 columns ## Total LogProb PValue Limited FDR ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;logical&gt; &lt;numeric&gt; ## AAACCTGAGAAACCAT-1 0 NA NA NA NA ## AAACCTGAGAAACCGC-1 0 NA NA NA NA ## AAACCTGAGAAACCTA-1 31 NA NA NA NA ## AAACCTGAGAAACGAG-1 0 NA NA NA NA ## AAACCTGAGAAACGCC-1 0 NA NA NA NA ## ... ... ... ... ... ... ## TTTGTCATCTTTACAC-1 0 NA NA NA NA ## TTTGTCATCTTTACGT-1 1 NA NA NA NA ## TTTGTCATCTTTAGGG-1 0 NA NA NA NA ## TTTGTCATCTTTAGTC-1 26 NA NA NA NA ## TTTGTCATCTTTCCTC-1 0 NA NA NA NA NAs are assigned to droplets used to compute the ambient profile. Get numbers of droplets in each class defined by FDR and the cut-off used: summary(e.out$FDR &lt;= 0.001) ## Mode FALSE TRUE NA&#39;s ## logical 487 3075 733718 The test significance is computed by permutation. For each droplet tested, the number of permutations may limit the value of the p-value. This information is available in the ‘Limited’ column. If ‘Limited’ is ‘TRUE’ for any non-significant droplet, the number of permutations was too low, should be increased and the analysis re-run. comment=&quot;emptyDrops() uses Monte Carlo simulations to compute p-values for the multinomial sampling transcripts from the ambient pool. The number of Monte Carlo iterations determines the lower bound for the p-values (Phipson and Smyth 2010). The Limited field in the output indicates whether or not the computed p-value for a particular barcode is bounded by the number of iterations. If any non-significant barcodes are TRUE for Limited, we may need to increase the number of iterations. A larger number of iterations will result in a lower p-value for these barcodes, which may allow them to be detected after correcting for multiple testing.&quot; table(Sig=e.out$FDR &lt;= 0.001, Limited=e.out$Limited) ## Limited ## Sig FALSE TRUE ## FALSE 487 0 ## TRUE 76 2999 Let’s check that the background comprises only empty droplets. If the droplets used to define the background profile are indeed empty, testing them should result in a flat distribution of p-values. Let’s test the ‘ambient’ droplets and draw the p-value distribution. commment=&quot;As mentioned above, emptyDrops() assumes that barcodes with low total UMI counts are empty droplets. Thus, the null hypothesis should be true for all of these barcodes. We can check whether the hypothesis testing procedure holds its size by examining the distribution of p-values for low-total barcodes with test.ambient=TRUE. Ideally, the distribution should be close to uniform (Figure 6.6). Large peaks near zero indicate that barcodes with total counts below lower are not all ambient in origin. This can be resolved by decreasing lower further to ensure that barcodes corresponding to droplets with very small cells are not used to estimate the ambient profile.&quot; set.seed(100) limit &lt;- 100 all.out &lt;- emptyDrops(counts(sce.raw), lower=limit, test.ambient=TRUE) hist(all.out$PValue[all.out$Total &lt;= limit &amp; all.out$Total &gt; 0], xlab=&quot;P-value&quot;, main=&quot;&quot;, col=&quot;grey80&quot;) The distribution of p-values looks uniform with no large peak for small values: no cell in these droplets. To evaluate the outcome of the analysis, we will plot the strength of the evidence against library size. is.cell &lt;- e.out$FDR &lt;= 0.001 Number of cells detected: 3075. The plot plot shows the strength of the evidence against the library size. Each point is a droplet coloured: in black if without cell, in red if with a cell (or more) in green if with a cell (or more) as defined with emptyDrops but not the inflection method. # colour: cellColour &lt;- ifelse(is.cell, &quot;red&quot;, &quot;black&quot;) # rep(&quot;black&quot;, nrow((e.out))) # boolean for presence of cells as defined by the inflection method tmpBoolInflex &lt;- e.out$Total &gt; metadata(br.out)$inflection # boolean for presence of cells as defined by the emptyDrops method tmpBoolSmall &lt;- e.out$FDR &lt;= 0.001 tmpBoolRecov &lt;- !tmpBoolInflex &amp; tmpBoolSmall cellColour[tmpBoolRecov] &lt;- &quot;green&quot; # &#39;recovered&#39; cells # plot strength of significance vs library size plot(log10(e.out$Total), -e.out$LogProb, col=cellColour, xlim=c(2,max(log10(e.out$Total))), xlab=&quot;Total UMI count&quot;, ylab=&quot;-Log Probability&quot;) # add point to show &#39;recovered&#39; cell on top points(log10(e.out$Total)[tmpBoolRecov], -e.out$LogProb[tmpBoolRecov], pch=16, col=&quot;green&quot;) Let’s filter out empty droplets. comment=&quot;Once we are satisfied with the performance of emptyDrops(), we subset our SingleCellExperiment object to retain only the detected cells. Discerning readers will notice the use of which(), which conveniently removes the NAs prior to the subsetting.&quot; sce.ed &lt;- sce.raw[,which(e.out$FDR &lt;= 0.001)] # ed for empty droplet rm(sce.raw); gc(); ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 9065272 484.2 16305644 870.9 16305644 870.9 ## Vcells 59369154 453.0 215050788 1640.8 336016856 2563.7 And check the new SCE object: sce.ed ## class: SingleCellExperiment ## dim: 33538 3075 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames(3075): AAACCTGAGACTTTCG-1 AAACCTGGTCTTCAAG-1 ... ## TTTGTCACAGGCTCAC-1 TTTGTCAGTTCGGCAC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## altExpNames(0): rm(sce.ed) Cell calling in cellranger v3 uses a method similar to emptyDrops() and a ‘filtered matrix’ is generated that only keeps droplets deemed to contain a cell. We will load these filtered matrices now. text=&quot;emptyDrops() already removes cells with very low library sizes or (by association) low numbers of expressed genes. Thus, further filtering on these metrics is not strictly necessary. It may still be desirable to filter on both of these metrics to remove non-empty droplets containing cell fragments or stripped nuclei that were not caught by the mitochondrial filter. However, this should be weighed against the risk of losing genuine cell types as discussed in Section 6.3.2.2.&quot; 4.8 Load filtered matrices Each sample was analysed with cellranger separately. We load filtered matrices one sample at a time, showing for each the name and number of features and cells. # a bit slow # load data: sce.list &lt;- vector(&quot;list&quot;, length = nrow(sampleSheet)) for (i in 1:nrow(sampleSheet)) { print(sprintf(&quot;&#39;Run&#39; %s, &#39;Sample.Name&#39; %s&quot;, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Sample.Name&quot;])) sample.path &lt;- sprintf(&quot;%s/%s/%s/outs/filtered_feature_bc_matrix/&quot;, sprintf(&quot;%s/%s/grch38300&quot;, projDir, ifelse(sampleSheet[i,&quot;source_name&quot;] == &quot;ABMMC&quot;, &quot;Hca&quot;, &quot;CaronBourque2020&quot;)), sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) sce.list[[i]] &lt;- read10xCounts(sample.path) print(dim(sce.list[[i]])) } ## [1] &quot;&#39;Run&#39; SRR9264343, &#39;Sample.Name&#39; GSM3872434&quot; ## [1] 33538 3088 ## [1] &quot;&#39;Run&#39; SRR9264344, &#39;Sample.Name&#39; GSM3872435&quot; ## [1] 33538 6678 ## [1] &quot;&#39;Run&#39; SRR9264345, &#39;Sample.Name&#39; GSM3872436&quot; ## [1] 33538 5054 ## [1] &quot;&#39;Run&#39; SRR9264346, &#39;Sample.Name&#39; GSM3872437&quot; ## [1] 33538 6096 ## [1] &quot;&#39;Run&#39; SRR9264347, &#39;Sample.Name&#39; GSM3872438&quot; ## [1] 33538 5442 ## [1] &quot;&#39;Run&#39; SRR9264348, &#39;Sample.Name&#39; GSM3872439&quot; ## [1] 33538 5502 ## [1] &quot;&#39;Run&#39; SRR9264349, &#39;Sample.Name&#39; GSM3872440&quot; ## [1] 33538 4126 ## [1] &quot;&#39;Run&#39; SRR9264350, &#39;Sample.Name&#39; GSM3872441&quot; ## [1] 33538 3741 ## [1] &quot;&#39;Run&#39; SRR9264351, &#39;Sample.Name&#39; GSM3872442&quot; ## [1] 33538 978 ## [1] &quot;&#39;Run&#39; SRR9264352, &#39;Sample.Name&#39; GSM3872442&quot; ## [1] 33538 1150 ## [1] &quot;&#39;Run&#39; SRR9264353, &#39;Sample.Name&#39; GSM3872443&quot; ## [1] 33538 4964 ## [1] &quot;&#39;Run&#39; SRR9264354, &#39;Sample.Name&#39; GSM3872444&quot; ## [1] 33538 4255 ## [1] &quot;&#39;Run&#39; MantonBM1, &#39;Sample.Name&#39; MantonBM1&quot; ## [1] 33538 23283 ## [1] &quot;&#39;Run&#39; MantonBM2, &#39;Sample.Name&#39; MantonBM2&quot; ## [1] 33538 25055 ## [1] &quot;&#39;Run&#39; MantonBM3, &#39;Sample.Name&#39; MantonBM3&quot; ## [1] 33538 24548 ## [1] &quot;&#39;Run&#39; MantonBM4, &#39;Sample.Name&#39; MantonBM4&quot; ## [1] 33538 26478 ## [1] &quot;&#39;Run&#39; MantonBM5, &#39;Sample.Name&#39; MantonBM5&quot; ## [1] 33538 26383 ## [1] &quot;&#39;Run&#39; MantonBM6, &#39;Sample.Name&#39; MantonBM6&quot; ## [1] 33538 22801 ## [1] &quot;&#39;Run&#39; MantonBM7, &#39;Sample.Name&#39; MantonBM7&quot; ## [1] 33538 24372 ## [1] &quot;&#39;Run&#39; MantonBM8, &#39;Sample.Name&#39; MantonBM8&quot; ## [1] 33538 24860 Let’s combine all 20 samples into a single object. We first check the feature lists are identical. # check row names are the same # compare to that for the first sample rowNames1 &lt;- rownames(sce.list[[1]]) for (i in 2:nrow(sampleSheet)) { print(identical(rowNames1, rownames(sce.list[[i]]))) } ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE A cell barcode comprises the actual sequence and a ‘group ID’, e.g. AAACCTGAGAAACCAT-1. The latter helps distinguish cells that share the same sequence but come from different samples. As each sample was analysed separately, the group ID is set to 1 in all data sets. To pool these data sets we first need to change group IDs so cell barcodes are unique across all samples. We will use the position of the sample in the sample sheet. sce &lt;- sce.list[[1]] colData(sce)$Barcode &lt;- gsub(&quot;([0-9])$&quot;, 1, colData(sce)$Barcode) print(head(colData(sce)$Barcode)) ## [1] &quot;AAACCTGAGACTTTCG-1&quot; &quot;AAACCTGGTCTTCAAG-1&quot; &quot;AAACCTGGTGCAACTT-1&quot; ## [4] &quot;AAACCTGGTGTTGAGG-1&quot; &quot;AAACCTGTCCCAAGTA-1&quot; &quot;AAACCTGTCGAATGCT-1&quot; print(tail(colData(sce)$Barcode)) ## [1] &quot;TTTGGTTTCCGAAGAG-1&quot; &quot;TTTGGTTTCTTTAGGG-1&quot; &quot;TTTGTCAAGAAACGAG-1&quot; ## [4] &quot;TTTGTCAAGGACGAAA-1&quot; &quot;TTTGTCACAGGCTCAC-1&quot; &quot;TTTGTCAGTTCGGCAC-1&quot; for (i in 2:nrow(sampleSheet)) { sce.tmp &lt;- sce.list[[i]] colData(sce.tmp)$Barcode &lt;- gsub(&quot;([0-9])$&quot;, i, colData(sce.tmp)$Barcode) sce &lt;- cbind(sce, sce.tmp) #print(head(colData(sce)$Barcode)) print(tail(colData(sce)$Barcode, 2)) } ## [1] &quot;TTTGTCATCTTAACCT-2&quot; &quot;TTTGTCATCTTCTGGC-2&quot; ## [1] &quot;TTTGTCATCCGCGGTA-3&quot; &quot;TTTGTCATCCGGGTGT-3&quot; ## [1] &quot;TTTGTCATCACTCTTA-4&quot; &quot;TTTGTCATCTATCCCG-4&quot; ## [1] &quot;TTTGTCAGTTCCCTTG-5&quot; &quot;TTTGTCATCGACGGAA-5&quot; ## [1] &quot;TTTGTCATCCTTTCGG-6&quot; &quot;TTTGTCATCTATGTGG-6&quot; ## [1] &quot;TTTGTCAGTCATTAGC-7&quot; &quot;TTTGTCAGTTGTGGCC-7&quot; ## [1] &quot;TTTGTCATCTACCAGA-8&quot; &quot;TTTGTCATCTGCAGTA-8&quot; ## [1] &quot;TTTGGTTGTGCATCTA-9&quot; &quot;TTTGTCACAGCTCGAC-9&quot; ## [1] &quot;TTTGTCAGTAAATGTG-10&quot; &quot;TTTGTCAGTACAAGTA-10&quot; ## [1] &quot;TTTGTCATCACCCTCA-11&quot; &quot;TTTGTCATCTTCATGT-11&quot; ## [1] &quot;TTTGTCATCAGTTGAC-12&quot; &quot;TTTGTCATCTCGTTTA-12&quot; ## [1] &quot;TTTGTCATCTTTACAC-13&quot; &quot;TTTGTCATCTTTCCTC-13&quot; ## [1] &quot;TTTGTCATCGACGGAA-14&quot; &quot;TTTGTCATCGCCTGAG-14&quot; ## [1] &quot;TTTGTCATCTTGTACT-15&quot; &quot;TTTGTCATCTTTAGGG-15&quot; ## [1] &quot;TTTGTCATCGGATGGA-16&quot; &quot;TTTGTCATCGTGGACC-16&quot; ## [1] &quot;TTTGTCATCTGCGGCA-17&quot; &quot;TTTGTCATCTGCGTAA-17&quot; ## [1] &quot;TTTGTCATCTAACTGG-18&quot; &quot;TTTGTCATCTGCGGCA-18&quot; ## [1] &quot;TTTGTCATCTGGGCCA-19&quot; &quot;TTTGTCATCTTGTATC-19&quot; ## [1] &quot;TTTGTCATCTTGAGAC-20&quot; &quot;TTTGTCATCTTGTATC-20&quot; rm(sce.list) We now add the sample sheet information to the object metadata. colDataOrig &lt;- colData(sce) # split path: tmpList &lt;- strsplit(colDataOrig$Sample, split=&quot;/&quot;) # get Run ID, to use to match sample in the meta data and sample sheet objects: tmpVec &lt;- unlist(lapply(tmpList, function(x){x[9]})) colData(sce)$Run &lt;- tmpVec # merge: colData(sce) &lt;- colData(sce) %&gt;% data.frame %&gt;% left_join(sampleSheet[,splShtColToKeep], &quot;Run&quot;) %&gt;% relocate() %&gt;% DataFrame Let’s save the object for future reference. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postPool%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postPool%s.Rds&quot;, projDir, outDirBit, setSuf) sce &lt;- readRDS(tmpFn) 4.9 Properties of scRNA-seq data # a bit slow # TODO first remove emtpy droplets the mol.info data mol.info$data head(mol.info$genes) dd &lt;- mol.info$data %&gt;% data.frame() dd$umi &lt;- as.character(dd$umi) tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_preProc_ampDf2.Rds&quot;, projDir, outDirBit) if(FALSE) # slow { ampDf &lt;- dd %&gt;% filter(paste(cell,gem_group, sep=&quot;-&quot;) %in% sce$Barcode) %&gt;% group_by(cell, gene) %&gt;% summarise(nUmis = n(), totReads=sum(reads)) %&gt;% data.frame() # Write object to file saveRDS(ampDf, tmpFn) } else { ampDf &lt;- readRDS(tmpFn) } rm(tmpFn) #summary(ampDf$nUmis) #summary(ampDf$totReads) hist(log2(ampDf$nUmis), n=100) hist(log2(ampDf$totReads), n=100) sp2 &lt;- ggplot(ampDf, aes(x=nUmis, y=totReads)) + geom_bin2d(bins = 50) + scale_fill_continuous(type = &quot;viridis&quot;) + scale_x_continuous(trans=&#39;log2&#39;) + scale_y_continuous(trans=&#39;log2&#39;) + theme_bw() sp2 #rm(mol.info) rm(ampDf) gc() The number and identity of genes detected in a cell vary across cells: the total number of genes detected across all cells is far larger than the number of genes per cell. Total number of genes detected across cells: # for each gene, compute total number of UMIs across all cells, # then counts genes with at least one UMI: countsRowSums &lt;- rowSums(counts(sce)) sum(countsRowSums &gt; 0) ## [1] 27795 Summary of the distribution of the number of genes detected per cell: # for each cell count number of genes with at least 1 UMI # then compute distribution moments: summary(colSums(counts(sce) &gt; 0)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 26 724 873 1173 1262 8077 Now let’s plot for each gene, the total number of UMIs and the proportion of cells that express it. Lowly expressed genes tend to be detected in a large proportion of cells. The higher the overall expression the lower the proportion of cells. # very slow; many points # skip in DEV, TODO: write plot to file and embed that. # x-axis: total number of UMIs for the gene across all cells # y-axis: fraction of cells expressing the gene tmpFn &lt;- sprintf(&quot;%s/%s/%s/corelLibSizePropCellExpress%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) png(tmpFn) plot( # x-axis: nb UMI per gene across all cells countsRowSums, # y-axis: proportion of cells that do express the cell rowMeans(counts(sce) &gt; 0), log = &quot;x&quot;, xlab=&quot;total number of UMIs&quot;, ylab=&quot;proportion of cells expressing the gene&quot; ) dev.off() dd &lt;- data.frame(&quot;countsRowSums&quot; = countsRowSums, &quot;propCellsExpr&quot; = rowMeans(counts(sce) &gt; 0)) head(dd) ## countsRowSums propCellsExpr ## ENSG00000243485 3 1.205526e-05 ## ENSG00000237613 0 0.000000e+00 ## ENSG00000186092 0 0.000000e+00 ## ENSG00000238009 203 8.157393e-04 ## ENSG00000239945 5 2.009210e-05 ## ENSG00000239906 0 0.000000e+00 sp &lt;- ggplot(dd, aes(x=countsRowSums, y=propCellsExpr)) + geom_point(alpha=0.3) + scale_x_continuous(trans=&#39;log10&#39;) + geom_density_2d() + xlab(&quot;total number of UMIs&quot;) + ylab(&quot;proportion of cells expressing the gene&quot;) sp ggExtra::ggMarginal(sp) tmpFn &lt;- sprintf(&quot;%s/%s/%s/corelLibSizePropCellExpress%s_2.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) tmpFn ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Qc/corelLibSizePropCellExpress_allCells_2.png&quot; #ggsave(ggExtra::ggMarginal(sp), file=tmpFn) rm(tmpFn) getwd() tmpFn &lt;- sprintf(&quot;%s/%s/corelLibSizePropCellExpress%s_2.png&quot;, dirRel, qcPlotDirBit, setSuf) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Count genes that are not ‘expressed’ (detected): not.expressed &lt;- rowSums(counts(sce)) == 0 table(not.expressed) ## not.expressed ## FALSE TRUE ## 27795 5743 Plot the percentage of counts per gene and show genes with the highest UMI counts: #Compute the relative expression of each gene per cell # a bit slow rel_expression &lt;- t( t(counts(sce)) / Matrix::colSums(counts(sce))) * 100 rownames(rel_expression) &lt;- rowData(sce)$Symbol most_expressed &lt;- sort(Matrix::rowSums( rel_expression ),T)[20:1] / ncol(sce) boxplot( as.matrix(t(rel_expression[names(most_expressed),])), cex=.1, las=1, xlab=&quot;% total count per cell&quot;, col=scales::hue_pal()(20)[20:1], horizontal=TRUE) Mind that we have combined two data sets here. It may be interesting to count non-expressed genes in each set separately. 4.10 Quality control Cell calling performed above does not inform on the quality of the library in each of the droplets kept. Poor-quality cells, or rather droplets, may be caused by cell damage during dissociation or failed library preparation. They usually have low UMI counts, few genes detected and/or high mitochondrial content. The presence may affect normalisation, assessment of cell population heterogeneity, clustering and trajectory: Normalisation: Contaminating genes, ‘the ambient RNA’, are detected at low levels in all libraires. In low quality libraries with low RNA content, scaling will increase counts for these genes more than for better-quality cells, resulting in their apparent upregulation in these cells and increased variance overall. Cell population heterogeneity: variance estimation and dimensionality reduction with PCA where the first principal component will be correlated with library size, rather than biology. Clustering and trajectory: higher mitochondrial and/or nuclear RNA content may cause low-quality cells to cluster separately or form states or trajectories between distinct cell types. We will now exclude lowly expressed features and identify low-quality cells using the following metrics mostly: library size, i.e. the total number of UMIs per cell number of features detected per cell mitochondrial content, i.e. the proportion of UMIs that map to mitochondrial genes, with higher values consistent with leakage from the cytoplasm of RNA, but not mitochodria We will first annotate genes, to know which lie in the mitochondrial genome, then use scater’s addPerCellQC() to compute various metrics. Annotate genes with biomaRt. # retrieve the feature information gene.info &lt;- rowData(sce) # setup the biomaRt connection to Ensembl using the correct species genome (hsapiens_gene_ensembl) ensembl &lt;- useEnsembl(biomart=&#39;ensembl&#39;, dataset=&#39;hsapiens_gene_ensembl&#39;, #mirror = &quot;www&quot;) #mirror = &quot;useast&quot;) mirror = &quot;uswest&quot;) #mirror = &quot;asia&quot;) ensembl = useMart(biomart=&quot;ENSEMBL_MART_ENSEMBL&quot;, dataset=&quot;hsapiens_gene_ensembl&quot;, host=&quot;uswest.ensembl.org&quot;, ensemblRedirect = FALSE) # retrieve the attributes of interest from biomaRt using the Ensembl gene ID as the key # beware that this will only retrieve information for matching IDs gene_symbol &lt;- getBM(attributes=c(&#39;ensembl_gene_id&#39;, &#39;external_gene_name&#39;, &#39;chromosome_name&#39;, &#39;start_position&#39;, &#39;end_position&#39;, &#39;strand&#39;), filters=&#39;ensembl_gene_id&#39;, mart=ensembl, values=gene.info[, 1]) # create a new data frame of the feature information gene.merge &lt;- merge(gene_symbol, gene.info, by.x=c(&#39;ensembl_gene_id&#39;), by.y=c(&#39;ID&#39;), all.y=TRUE) rownames(gene.merge) &lt;- gene.merge$ensembl_gene_id # set the order for the same as the original gene information gene.merge &lt;- gene.merge[gene.info[, 1], ] # reset the rowdata on the SCE object to contain all of this information rowData(sce) &lt;- gene.merge # slow # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postBiomart%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postBiomart%s.Rds&quot;, projDir, outDirBit, setSuf) sce &lt;- readRDS(tmpFn) table(rowData(sce)$chromosome_name) ## ## 1 10 11 12 13 14 15 ## 3127 1221 1910 1748 662 1380 1121 ## 16 17 18 19 2 20 21 ## 1518 1880 654 1989 2263 889 499 ## 22 3 4 5 6 7 8 ## 831 1704 1345 1646 1616 1526 1303 ## 9 GL000009.2 GL000194.1 GL000195.1 GL000205.2 GL000213.1 GL000218.1 ## 1211 1 2 2 1 1 1 ## GL000219.1 KI270711.1 KI270713.1 KI270721.1 KI270726.1 KI270727.1 KI270728.1 ## 1 1 2 1 2 4 6 ## KI270731.1 KI270734.1 MT X Y ## 1 3 13 1067 97 is.mito &lt;- which(rowData(sce)$chromosome_name==&quot;MT&quot;) Calculate and store QC metrics for genes with addPerFeatureQC() and for cells with addPerCellQC(). # long # for genes sce &lt;- addPerFeatureQC(sce) head(rowData(sce)) %&gt;% as.data.frame() %&gt;% datatable(rownames = FALSE) # ENS ID Three columns of interest for cells: ‘sum’: total UMI count ‘detected’: number of features (genes) detected ‘subsets_Mito_percent’: percentage of reads mapped to mitochondrial transcripts # for cells sce &lt;- addPerCellQC(sce, subsets=list(Mito=is.mito)) head(colData(sce)) %&gt;% as.data.frame() %&gt;% datatable(rownames = FALSE) # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postAddQc%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postAddQc%s.Rds&quot;, projDir, outDirBit, setSuf) sce &lt;- readRDS(tmpFn) 4.10.1 QC metric distribution Overall: par(mfrow=c(1, 2)) hist(log10(sce$sum), breaks=20, col=&quot;grey80&quot;, xlab=&quot;Log-total UMI count&quot;, main=&quot;&quot;) hist(sce$subsets_Mito_percent, breaks=20, col=&quot;grey80&quot;, xlab=&quot;Proportion of reads in mitochondrial genes&quot;, main=&quot;&quot;) abline(v=20, lty=2, col=&#39;purple&#39;) Per sample group: sce$source_name &lt;- factor(sce$source_name) sce$block &lt;- sce$source_name sce$setName &lt;- ifelse(grepl(&quot;ABMMC&quot;, sce$source_name), &quot;Hca&quot;, &quot;Caron&quot;) # ok, but little gain in splitting by Caron and Hca, # better set levels to have PBMMC last and use ggplot with colours. tmpFn &lt;- sprintf(&quot;%s/%s/%s/qc_metricDistrib_plotColData2%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) png(tmpFn) # violin plots gridExtra::grid.arrange( plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Total count&quot;), plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Detected features&quot;), plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, other_fields=&quot;setName&quot;) + # facet_wrap(~setName) + ggtitle(&quot;Mito percent&quot;), ncol=1 ) dev.off() # eval=FALSE: see chunks below for each of the metrics separately tmpFn &lt;- sprintf(&quot;%s/%s/%s/qc_metricDistrib_plotColData2%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Library size (‘Total count’): plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Total count&quot;) Number of genes (‘detected’): plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) Mitochondrial content (‘subsets_Mito_percent’): plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, other_fields=&quot;setName&quot;) + # facet_wrap(~setName) + ggtitle(&quot;Mito percent&quot;) Correlation between the number of genes detected and library size (‘detected’ against ‘sum’): sp &lt;- ggplot(data.frame(colData(sce)), aes(x=sum, y=detected, col=source_name)) + geom_point(alpha=0.3) sp + facet_wrap(~source_name) Correlation between the mitochondrial content and library size (‘subsets_Mito_percent’ against ‘sum’): sp &lt;- ggplot(data.frame(colData(sce)), aes(x=sum, y=detected, col=subsets_Mito_percent)) + geom_point() sp + facet_wrap(~source_name) 4.11 Identification of low-quality cells with adaptive thresholds One can use hard threshold for the library size, number of genes detected and mitochondrial content. These will however vary across runs. It may therefore be preferable to rely on outlier detection to identify cells that markedly differ from most cells. We saw above that the distribution of the QC metrics is close to Normal. Hence, we can detect outlier using the median and the median absolute deviation (MAD) from the median (not the mean and the standard deviation that both are sensitive to outliers). For a given metric, an outlier value is one that lies over some number of MADs away from the median. A cell will be excluded if it is an outlier in the part of the range to avoid, for example low gene counts, or high mitochondrial content. For a normal distribution, a threshold defined with a distance of 3 MADs from the median retains about 99% of values. 4.11.1 Library size For the library size we use the log scale to avoid negative values for lower part of the distribution. qc.lib2 &lt;- isOutlier(sce$sum, log=TRUE, type=&quot;lower&quot;) table(qc.lib2) ## qc.lib2 ## FALSE TRUE ## 245250 3604 Threshold values: attr(qc.lib2, &quot;thresholds&quot;) ## lower higher ## 920.8674 Inf 4.11.2 Number of genes For the number of genes detected we also use the log scale to avoid negative values for lower part of the distribution. qc.nexprs2 &lt;- isOutlier(sce$detected, log=TRUE, type=&quot;lower&quot;) table(qc.nexprs2) ## qc.nexprs2 ## FALSE TRUE ## 246349 2505 Threshold values: attr(qc.nexprs2, &quot;thresholds&quot;) ## lower higher ## 302.3803 Inf 4.11.3 Mitochondrial content For the mitochondrial content the exclusion zone is in the higher part of the distribution. qc.mito2 &lt;- isOutlier(sce$subsets_Mito_percent, type=&quot;higher&quot;) table(qc.mito2) ## qc.mito2 ## FALSE TRUE ## 237080 11774 Threshold values: attr(qc.mito2, &quot;thresholds&quot;) ## lower higher ## -Inf 7.613065 4.11.4 Summary discard2 &lt;- qc.lib2 | qc.nexprs2 | qc.mito2 # Summarize the number of cells removed for each reason. DataFrame(LibSize=sum(qc.lib2), NExprs=sum(qc.nexprs2), MitoProp=sum(qc.mito2), Total=sum(discard2)) ## DataFrame with 1 row and 4 columns ## LibSize NExprs MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 3604 2505 11774 15386 4.11.5 All steps at once The steps above may be run at once with quickPerCellQC(): reasons &lt;- quickPerCellQC(colData(sce), percent_subsets=c(&quot;subsets_Mito_percent&quot;)) colSums(as.matrix(reasons)) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) 4.11.6 Assumptions Data quality depends on the tissue analysed, some being difficult to dissociate, e.g. brain, so that one level of QC stringency will not fit all data sets. Filtering based on QC metrics as done here assumes that these QC metrics are not correlated with biology. This may not necessarily be true in highly heterogenous data sets where some cell types represented by good-quality cells may have low RNA content or high mitochondrial content. 4.12 Experimental factors The two data sets analysed here may have been obtained in experiments with different settings, such as cell preparation or sequencing depth. Such differences between these two batches would affect the adaptive thresholds discussed above. We will now perform QC in each batch separately. We will use the quickPerCellQC() ‘batch’ option. batch.reasons &lt;- quickPerCellQC(colData(sce), percent_subsets=c(&quot;subsets_Mito_percent&quot;), batch=sce$setName) colSums(as.matrix(batch.reasons)) ## low_lib_size low_n_features high_subsets_Mito_percent ## 0 1034 11046 ## discard ## 12014 sce$discard &lt;- batch.reasons$discard Fewer cells are discarded, in particular because of small library size and low gene number. But the differences are deeper as the two sets only partially overlap: table(reasons$discard, batch.reasons$discard) ## ## FALSE TRUE ## FALSE 231781 1687 ## TRUE 5059 10327 # see chunks below for each of the metric separately tmpFn &lt;- sprintf(&quot;%s/%s/%s/qc_metricDistrib_plotColDataBatch%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) png(tmpFn) gridExtra::grid.arrange( plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Total count&quot;), plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Detected features&quot;), plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + ggtitle(&quot;Mito percent&quot;), ncol=1 ) dev.off() # eval=FALSE; see chunks below for each of the metric separately tmpFn &lt;- sprintf(&quot;%s/%s/qc_metricDistrib_plotColDataBatch%s.png&quot;, dirRel, qcPlotDirBit, setSuf) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Library size: plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Total count&quot;) Number of genes detected: plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + facet_wrap(~colour_by) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) Mitochondrial content: plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + ggtitle(&quot;Mito percent&quot;) sp &lt;- ggplot(data.frame(colData(sce)), aes(x=detected, y=subsets_Mito_percent, col=discard)) + geom_point(size = 0.05, alpha = 0.2) + geom_density_2d(size = 0.5, colour = &quot;blue&quot;) + guides(colour = guide_legend(override.aes = list(size=1, alpha=1))) + theme(legend.position=&quot;bottom&quot;) #sp ggExtra::ggMarginal(sp) sp &lt;- ggplot(data.frame(colData(sce)), aes(x=detected, y=subsets_Mito_percent, col=discard)) + geom_point(size = 0.05, alpha = 0.2) sp + facet_wrap(~source_name) sp &lt;- ggplot(data.frame(colData(sce)), aes(x=detected, y=subsets_Mito_percent)) + geom_point(size = 0.05, alpha = 0.0) sp + #geom_density_2d_filled(alpha = 0.5) + geom_density_2d(size = 0.5, colour = &quot;black&quot;) sp &lt;- ggplot(data.frame(colData(sce)), aes(x=detected, y=subsets_Mito_percent)) + geom_point(size = 0.05, alpha = 0.2) + geom_density_2d(size = 0.5, colour = &quot;blue&quot;) ggExtra::ggMarginal(sp) 4.12.1 Identify poor-quality batches We will now consider the ‘sample’ batch to illustrate how to identify batches with overall low quality or different from other batches. Let’s compare thresholds across sample groups. 4.12.1.1 Number of genes detected # compute discard.nexprs &lt;- isOutlier(sce$detected, log=TRUE, type=&quot;lower&quot;, batch=sce$Sample.Name) nexprs.thresholds &lt;- attr(discard.nexprs, &quot;thresholds&quot;)[&quot;lower&quot;,] nexprs.thresholds %&gt;% round(0) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) Without block: # plots - without blocking discard.nexprs.woBlock &lt;- isOutlier(sce$detected, log=TRUE, type=&quot;lower&quot;) without.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;detected&quot;, colour_by=I(discard.nexprs.woBlock)) without.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) With block: # plots - with blocking with.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;detected&quot;, colour_by=I(discard.nexprs)) with.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 4.12.1.1.1 Mitochondrial content discard.mito &lt;- isOutlier(sce$subsets_Mito_percent, type=&quot;higher&quot;, batch=sce$Sample.Name) mito.thresholds &lt;- attr(discard.mito, &quot;thresholds&quot;)[&quot;higher&quot;,] mito.thresholds %&gt;% round(0) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) Without block: # plots - without blocking discard.mito.woBlock &lt;- isOutlier(sce$subsets_Mito_percent, type=&quot;higher&quot;) without.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=I(discard.mito.woBlock)) without.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) With block: # plots - with blocking with.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=I(discard.mito)) with.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 4.12.1.2 Samples to check Names of samples with a ‘low’ threshold for the number of genes detected: # names names(nexprs.thresholds)[isOutlier(nexprs.thresholds, type=&quot;lower&quot;)] ## character(0) Names of samples with a ‘high’ threshold for mitocondrial content: # names names(mito.thresholds)[isOutlier(mito.thresholds, type=&quot;higher&quot;)] ## [1] &quot;GSM3872434&quot; &quot;GSM3872437&quot; &quot;GSM3872438&quot; &quot;GSM3872443&quot; 4.12.2 QC metrics space A similar approach exists to identify outliers using a set of metrics together. We will the same QC metrics as above: # slow stats &lt;- cbind(log10(sce$sum), log10(sce$detected), sce$subsets_Mito_percent) library(robustbase) outlying &lt;- adjOutlyingness(stats, only.outlyingness = TRUE) multi.outlier &lt;- isOutlier(outlying, type = &quot;higher&quot;) summary(multi.outlier) ## Mode FALSE TRUE ## logical 232401 16453 Compare with previous filtering: table(sce$discard, multi.outlier) ## multi.outlier ## FALSE TRUE ## FALSE 226413 10427 ## TRUE 5988 6026 4.12.3 QC PCA One can also perform a principal components analysis (PCA) on cells, based on the column metadata in a SingleCellExperiment object. Here we will only use the library size, the number of genes detected (which is correlated with library size) and the mitochondrial content. sce &lt;- runColDataPCA(sce, variables=list( &quot;sum&quot;, &quot;detected&quot;, &quot;subsets_Mito_percent&quot;), outliers=TRUE) #reducedDimNames(sce) #head(reducedDim(sce)) #head(colData(sce)) #p &lt;- plotReducedDim(sce, dimred=&quot;PCA_coldata&quot;, colour_by = &quot;Sample.Name&quot;) p &lt;- plotReducedDim(sce, dimred=&quot;PCA_coldata&quot;, colour_by = &quot;outlier&quot;) p + facet_wrap(~sce$discard) Compare with previous filtering: discard and runColDataPCA’s outlier: table(sce$discard, sce$outlier) ## ## FALSE TRUE ## FALSE 227999 8841 ## TRUE 5611 6403 adjOutlyingness’ multi.outlier and runColDataPCA’s outlier: table(multi.outlier, sce$outlier) ## ## multi.outlier FALSE TRUE ## FALSE 226248 6153 ## TRUE 7362 9091 4.12.4 Other diagnostic plots Mitochondrial content against library size: plotColData(sce, x=&quot;sum&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=&quot;discard&quot;) sp &lt;- ggplot(data.frame(colData(sce)), aes(x=sum, y=subsets_Mito_percent, col=discard)) + geom_point(size = 0.05, alpha = 0.7) + geom_density_2d(size = 0.5, colour = &quot;blue&quot;) + guides(colour = guide_legend(override.aes = list(size=1, alpha=1))) + theme(legend.position=&quot;bottom&quot;) #sp ggExtra::ggMarginal(sp) Mind distributions: sp + facet_wrap(~source_name) 4.12.5 Filter low-quality cells out We will now exclude poor-quality cells. scePreQc &lt;- sce sce &lt;- scePreQc[,!scePreQc$discard] sce ## class: SingleCellExperiment ## dim: 33538 236840 ## metadata(20): Samples Samples ... Samples Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(10): ensembl_gene_id external_gene_name ... mean detected ## colnames: NULL ## colData names(15): Sample Barcode ... discard outlier ## reducedDimNames(1): PCA_coldata ## altExpNames(0): We also write the R object to file to use later if need be. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postQc%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postQc%s.Rds&quot;, projDir, outDirBit, setSuf) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/sce_postQc_allCells.Rds&quot; #sce &lt;- readRDS(tmpFn) 4.13 Novelty The number of genes per UMI for each cell informs on the level of sequencing saturation achieved ( hbctraining). For a given cell, as sequencing depth increases each extra UMI is less likely to correspnf to a gene not already detected in that cell. Cells with small library size tend to have higher overall ‘novelty’ i.e. they have not reached saturation for any given gene. Outlier cell may have a library with low complexity. This may suggest the some cell types, e.g. red blood cells. The expected novelty is about 0.8. Here we see that some PBMMCs have low novelty, ie overall fewer genes were detected for an equivalent number of UMIs in these cells than in others. p &lt;- colData(sce) %&gt;% data.frame() %&gt;% ggplot(aes(x=sum, y=detected, color=subsets_Mito_percent)) + geom_point() + stat_smooth(method=lm) + scale_x_log10() + scale_y_log10() + geom_vline(xintercept = 800) + facet_wrap(~source_name) p # write plot to file tmpFn &lt;- sprintf(&quot;%s/%s/%s/novelty_scat%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Qc/novelty_scat_allCells.png&quot; ##ggsave(plot=p, file=tmpFn) # Novelty # the number of genes per UMI for each cell, # https://hbctraining.github.io/In-depth-NGS-Data-Analysis-Course/sessionIV/lessons/SC_quality_control_analysis.html # Add number of UMIs per gene for each cell to metadata colData(sce)$log10GenesPerUMI &lt;- log10(colData(sce)$detected) / log10(colData(sce)$sum) #```{r novelty_dens_allCells, cache.lazy = FALSE} # Visualize the overall novelty of the gene expression by visualizing the genes detected per UMI p &lt;- colData(sce) %&gt;% data.frame() %&gt;% ggplot(aes(x=log10GenesPerUMI, color = source_name, fill = source_name)) + geom_density() p tmpFn &lt;- sprintf(&quot;%s/%s/%s/novelty_dens%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Qc/novelty_dens_allCells.png&quot; ##ggsave(plot=p, file=tmpFn) rm(sce) 4.14 QC based on sparsity The approach above identified poor-quality using thresholds on the number of genes detected and mitochondrial content. We will here specifically look at the sparsity of the data, both at the gene and cell levels. 4.14.1 Remove genes that are not expressed at all Genes that are not expressed at all are not informative, so we remove them not.expressed &lt;- rowSums(counts(scePreQc)) == 0 # store the cell-wise information cols.meta &lt;- colData(scePreQc) rows.meta &lt;- rowData(scePreQc) nz.counts &lt;- counts(scePreQc)[!not.expressed, ] sce.nz &lt;- SingleCellExperiment(list(counts=nz.counts)) # reset the column data on the new object colData(sce.nz) &lt;- cols.meta rowData(sce.nz) &lt;- rows.meta[!not.expressed, ] sce.nz # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(sce.nz, tmpFn) # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz%s.Rds&quot;, projDir, outDirBit, setSuf) sce.nz &lt;- readRDS(tmpFn) Number of genes 27795. Number of cells 248854. 4.14.2 Sparsity plots We will compute: the cell sparsity: for each cell, the proportion of genes that are not detected the gene sparsity: for each gene, the proportion of cells in which it is not detected # compute - SLOW cell_sparsity &lt;- apply(counts(sce.nz) == 0, 2, sum)/nrow(counts(sce.nz)) gene_sparsity &lt;- apply(counts(sce.nz) == 0, 1, sum)/ncol(counts(sce.nz)) colData(sce.nz)$cell_sparsity &lt;- cell_sparsity rowData(sce.nz)$gene_sparsity &lt;- gene_sparsity # write outcome to file for later use tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_sparsityCellGene%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(list(&quot;colData&quot; = colData(sce.nz), &quot;rowData&quot; = rowData(sce.nz)), tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_sparsityCellGene%s.Rds&quot;, projDir, outDirBit, setSuf) tmpList &lt;- readRDS(tmpFn) cell_sparsity &lt;- tmpList$colData$cell_sparsity gene_sparsity &lt;- tmpList$rowData$gene_sparsity We now plot the distribution of these two metrics. The cell sparsity plot shows that cells have between 85% and 99% 0’s, which is typical. The gene sparsity plot shows that a large number of genes are almost never detected, which is alo regularly observed. #```{r sparsity_plot_allCells, eval=runAll} # plot tmpFn &lt;- sprintf(&quot;%s/%s/%s/sparsity%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setSuf) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Qc/sparsity_allCells.png&quot; ##png(tmpFn) ##par(mfrow=c(1, 2)) ##hist(cell_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Cell sparsity&quot;, main=&quot;&quot;) ##hist(gene_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Gene sparsity&quot;, main=&quot;&quot;) ##abline(v=40, lty=2, col=&#39;purple&#39;) ##dev.off() tmpFn &lt;- sprintf(&quot;%s/%s/sparsity%s.png&quot;, dirRel, qcPlotDirBit, setSuf) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 4.14.3 Filters We also remove cells with sparsity higher than 0.99, and/or mitochondrial content higher than 20%. Genes detected in a few cells only are unlikely to be informative and would hinder normalisation. We will remove genes that are expressed in fewer than 20 cells. # filter sparse.cells &lt;- cell_sparsity &gt; 0.99 mito.cells &lt;- sce.nz$subsets_Mito_percent &gt; 20 min.cells &lt;- 1 - (20/length(cell_sparsity)) sparse.genes &lt;- gene_sparsity &gt; min.cells Number of genes removed: table(sparse.genes) ## sparse.genes ## FALSE TRUE ## 21579 6216 Number of cells removed: table(sparse.cells, mito.cells) ## mito.cells ## sparse.cells FALSE TRUE ## FALSE 244996 1785 ## TRUE 1859 214 # remove cells from the SCE object that are poor quality # remove the sparse genes, then re-set the counts and row data accordingly cols.meta &lt;- colData(sce.nz) rows.meta &lt;- rowData(sce.nz) counts.nz &lt;- counts(sce.nz)[!sparse.genes, !(sparse.cells | mito.cells)] sce.nz &lt;- SingleCellExperiment(assays=list(counts=counts.nz)) colData(sce.nz) &lt;- cols.meta[!(sparse.cells | mito.cells),] rowData(sce.nz) &lt;- rows.meta[!sparse.genes, ] sce.nz # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setSuf) saveRDS(sce.nz, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setSuf) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/sce_nz_postQc_allCells.Rds&quot; ##sce.nz &lt;- readRDS(tmpFn) Compare with filter above (mind that the comparison is not fair because we used a less stringent, hard filtering on mitochondrial content): table(scePreQc$discard, (sparse.cells | mito.cells)) ## ## FALSE TRUE ## FALSE 235832 1008 ## TRUE 9164 2850 rm(scePreQc) 4.14.4 Separate Caron and Hca batches We will now check sparsity for each batch separately. sce.nz.caron &lt;- sce.nz[,sce.nz$setName==&quot;Caron&quot;] sce.nz.hca &lt;- sce.nz[,sce.nz$setName==&quot;Hca&quot;] 4.14.5 Caron only setName &lt;- &quot;caron&quot; sce.x &lt;- sce.nz.caron # for code re-use rm(sce.nz.caron) # compute - SLOW cell_sparsity &lt;- apply(counts(sce.x) == 0, 2, sum)/nrow(counts(sce.x)) gene_sparsity &lt;- apply(counts(sce.x) == 0, 1, sum)/ncol(counts(sce.x)) colData(sce.x)$cell_sparsity &lt;- cell_sparsity rowData(sce.x)$gene_sparsity &lt;- gene_sparsity # write outcome to file for later use tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(list(&quot;colData&quot; = colData(sce.x), &quot;rowData&quot; = rowData(sce.x)), tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene%s.Rds&quot;, projDir, outDirBit, setName, setSuf) tmpList &lt;- readRDS(tmpFn) cell_sparsity &lt;- tmpList$colData$cell_sparsity gene_sparsity &lt;- tmpList$rowData$gene_sparsity # plot tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sparsity%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf) png(tmpFn) par(mfrow=c(1, 2)) hist(cell_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Cell sparsity&quot;, main=&quot;&quot;) hist(gene_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Gene sparsity&quot;, main=&quot;&quot;) abline(v=40, lty=2, col=&#39;purple&#39;) dev.off() tmpFn &lt;- sprintf(&quot;%s/%s/%s_sparsity%s.png&quot;, dirRel, qcPlotDirBit, setName, setSuf) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) # filter sparse.cells &lt;- cell_sparsity &gt; 0.99 mito.cells &lt;- sce.x$subsets_Mito_percent &gt; 20 min.cells &lt;- 1 - (20/length(cell_sparsity)) sparse.genes &lt;- gene_sparsity &gt; min.cells # remove cells from the SCE object that are poor quality # remove the sparse genes, then re-set the counts and row data accordingly cols.meta &lt;- colData(sce.x) rows.meta &lt;- rowData(sce.x) counts.x &lt;- counts(sce.x)[!sparse.genes, !(sparse.cells | mito.cells)] sce.x &lt;- SingleCellExperiment(assays=list(counts=counts.x)) colData(sce.x) &lt;- cols.meta[!(sparse.cells | mito.cells),] rowData(sce.x) &lt;- rows.meta[!sparse.genes, ] sce.x We write the R object to caron_sce_nz_postQc_allCells.Rds. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce.x, tmpFn) # rename to sce.nz.caron sce.nz.caron &lt;- sce.x # TODO sce.nz.caron not used rm(sce.x) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce.nz.caron &lt;- readRDS(tmpFn) 4.14.6 Hca only setName &lt;- &quot;hca&quot; sce.x &lt;- sce.nz.hca # for code re-use rm(sce.nz.hca) # compute - SLOW cell_sparsity &lt;- apply(counts(sce.x) == 0, 2, sum)/nrow(counts(sce.x)) gene_sparsity &lt;- apply(counts(sce.x) == 0, 1, sum)/ncol(counts(sce.x)) colData(sce.x)$cell_sparsity &lt;- cell_sparsity rowData(sce.x)$gene_sparsity &lt;- gene_sparsity # write outcome to file for later use tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(list(&quot;colData&quot; = colData(sce.x), &quot;rowData&quot; = rowData(sce.x)), tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene%s.Rds&quot;, projDir, outDirBit, setName, setSuf) tmpList &lt;- readRDS(tmpFn) cell_sparsity &lt;- tmpList$colData$cell_sparsity gene_sparsity &lt;- tmpList$rowData$gene_sparsity #```{r Hca_sparsity_plot_allCells, eval=runAll} # plot tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sparsity%s.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Qc/hca_sparsity_allCells.png&quot; ##png(tmpFn) ##par(mfrow=c(1, 2)) ##hist(cell_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Cell sparsity&quot;, main=&quot;&quot;) ##hist(gene_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Gene sparsity&quot;, main=&quot;&quot;) ##abline(v=40, lty=2, col=&#39;purple&#39;) ##dev.off() #tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sparsity.png&quot;, projDir, outDirBit, qcPlotDirBit, setName) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sparsity%s.png&quot;, dirRel, qcPlotDirBit, setName, setSuf) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) # filter sparse.cells &lt;- cell_sparsity &gt; 0.99 mito.cells &lt;- sce.x$subsets_Mito_percent &gt; 20 min.cells &lt;- 1 - (20/length(cell_sparsity)) sparse.genes &lt;- gene_sparsity &gt; min.cells # remove cells from the SCE object that are poor quality # remove the sparse genes, then re-set the counts and row data accordingly cols.meta &lt;- colData(sce.x) rows.meta &lt;- rowData(sce.x) counts.x &lt;- counts(sce.x)[!sparse.genes, !(sparse.cells | mito.cells)] sce.x &lt;- SingleCellExperiment(assays=list(counts=counts.x)) colData(sce.x) &lt;- cols.meta[!(sparse.cells | mito.cells),] rowData(sce.x) &lt;- rows.meta[!sparse.genes, ] sce.x We write the R object to hca_sce_nz_postQc_allCells.Rds. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce.x, tmpFn) # rename to sce.nz.hca sce.nz.hca &lt;- sce.x # TODO sce.nz.hca only used for sce.nz.hca.5k rm(sce.x) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce.nz.hca &lt;- readRDS(tmpFn) 4.15 Subsample Hca set The HCA data comprises about 25,000 cells per samples, compared to 5,000 for the Caron study. We will randomly subsample the HCA samples down to 5000 cells. sce.nz.hca # have new list of cell barcodes for each sample sce.nz.hca.5k.bc &lt;- colData(sce.nz.hca) %&gt;% data.frame() %&gt;% group_by(Sample.Name) %&gt;% sample_n(5000) %&gt;% pull(Barcode) table(colData(sce.nz.hca)$Barcode %in% sce.nz.hca.5k.bc) tmpInd &lt;- which(colData(sce.nz.hca)$Barcode %in% sce.nz.hca.5k.bc) sce.nz.hca.5k &lt;- sce.nz.hca[,tmpInd] # mind that genes were filtered using all cells, not just those sampled here. We write the R object to ‘hca_sce_nz_postQc_5kCellPerSpl.Rds’. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc_5kCellPerSpl.Rds&quot;, projDir, outDirBit, setName) saveRDS(sce.nz.hca.5k, tmpFn) rm(sce.nz.hca) rm(sce.nz.hca.5k) gc() ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 9519624 508.5 16305648 870.9 16305648 870.9 ## Vcells 1421357338 10844.1 2765812427 21101.5 2297115936 17525.7 4.16 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] BiocSingular_1.6.0 scuttle_1.0.4 ## [3] robustbase_0.93-7 mixtools_1.2.0 ## [5] irlba_2.3.3 biomaRt_2.46.3 ## [7] Matrix_1.2-18 igraph_1.2.6 ## [9] DropletUtils_1.10.3 scater_1.18.6 ## [11] ggplot2_3.3.3 scran_1.18.7 ## [13] SingleCellExperiment_1.12.0 SummarizedExperiment_1.20.0 ## [15] Biobase_2.50.0 GenomicRanges_1.42.0 ## [17] GenomeInfoDb_1.26.7 IRanges_2.24.1 ## [19] S4Vectors_0.28.1 BiocGenerics_0.36.1 ## [21] MatrixGenerics_1.2.1 matrixStats_0.58.0 ## [23] dplyr_1.0.5 DT_0.18 ## [25] knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] BiocFileCache_1.14.0 splines_4.0.3 ## [3] BiocParallel_1.24.1 crosstalk_1.1.1 ## [5] digest_0.6.27 htmltools_0.5.1.1 ## [7] viridis_0.5.1 fansi_0.4.2 ## [9] magrittr_2.0.1 memoise_2.0.0 ## [11] limma_3.46.0 readr_1.4.0 ## [13] R.utils_2.10.1 askpass_1.1 ## [15] prettyunits_1.1.1 colorspace_2.0-0 ## [17] blob_1.2.1 rappdirs_0.3.1 ## [19] xfun_0.22 crayon_1.4.1 ## [21] RCurl_1.98-1.3 jsonlite_1.7.2 ## [23] survival_3.2-7 glue_1.4.2 ## [25] gtable_0.3.0 zlibbioc_1.36.0 ## [27] XVector_0.30.0 DelayedArray_0.16.3 ## [29] kernlab_0.9-29 Rhdf5lib_1.12.1 ## [31] DEoptimR_1.0-8 HDF5Array_1.18.1 ## [33] scales_1.1.1 DBI_1.1.1 ## [35] edgeR_3.32.1 miniUI_0.1.1.1 ## [37] Rcpp_1.0.6 isoband_0.2.4 ## [39] xtable_1.8-4 viridisLite_0.3.0 ## [41] progress_1.2.2 dqrng_0.2.1 ## [43] bit_4.0.4 rsvd_1.0.3 ## [45] htmlwidgets_1.5.3 httr_1.4.2 ## [47] ellipsis_0.3.1 pkgconfig_2.0.3 ## [49] XML_3.99-0.5 R.methodsS3_1.8.1 ## [51] farver_2.1.0 sass_0.3.1 ## [53] dbplyr_2.0.0 locfit_1.5-9.4 ## [55] utf8_1.2.1 later_1.1.0.1 ## [57] tidyselect_1.1.0 labeling_0.4.2 ## [59] rlang_0.4.10 AnnotationDbi_1.52.0 ## [61] munsell_0.5.0 tools_4.0.3 ## [63] cachem_1.0.4 generics_0.1.0 ## [65] RSQLite_2.2.6 evaluate_0.14 ## [67] stringr_1.4.0 fastmap_1.1.0 ## [69] yaml_2.2.1 bit64_4.0.5 ## [71] purrr_0.3.4 nlme_3.1-149 ## [73] sparseMatrixStats_1.2.1 mime_0.10 ## [75] R.oo_1.24.0 ggExtra_0.9 ## [77] xml2_1.3.2 compiler_4.0.3 ## [79] rstudioapi_0.13 beeswarm_0.2.3 ## [81] curl_4.3 tibble_3.1.1 ## [83] statmod_1.4.35 bslib_0.2.4 ## [85] stringi_1.5.3 highr_0.8 ## [87] lattice_0.20-41 bluster_1.0.0 ## [89] vctrs_0.3.7 pillar_1.6.0 ## [91] lifecycle_1.0.0 rhdf5filters_1.2.0 ## [93] jquerylib_0.1.3 BiocNeighbors_1.8.2 ## [95] cowplot_1.1.1 bitops_1.0-6 ## [97] httpuv_1.5.5 R6_2.5.0 ## [99] promises_1.1.1 bookdown_0.21 ## [101] gridExtra_2.3 vipor_0.4.5 ## [103] codetools_0.2-16 MASS_7.3-53 ## [105] assertthat_0.2.1 rhdf5_2.34.0 ## [107] openssl_1.4.3 withr_2.4.2 ## [109] GenomeInfoDbData_1.2.4 mgcv_1.8-33 ## [111] hms_1.0.0 grid_4.0.3 ## [113] beachmat_2.6.4 rmarkdown_2.7 ## [115] DelayedMatrixStats_1.12.3 segmented_1.3-3 ## [117] shiny_1.5.0 ggbeeswarm_0.6.0 "],["PreProcTop.html", "Chapter 5 Quality Control 5.1 Introduction 5.2 Load packages 5.3 Sample sheet 5.4 Data representation 5.5 Example 5.6 Mapping QC 5.7 Cell calling for droplet data 5.8 Load filtered matrices 5.9 Properties of scRNA-seq data 5.10 Quality control 5.11 Identification of low-quality cells with adaptive thresholds 5.12 Experimental factors 5.13 Novelty 5.14 QC based on sparsity 5.15 Session information", " Chapter 5 Quality Control 5.1 Introduction We will use two sets of Bone Marrow Mononuclear Cells (BMMC): ‘CaronBourque2020’: pediatric samples ‘Hca’: HCA Census of Immune Cells for adult BMMCs Fastq files were retrieved from publicly available archive (SRA and HCA). Sequencing quality was assessed and visualised using fastQC and MultiQC. Reads were aligned against GRCh38 and features counted using cellranger (v3.1.0). We will now check the quality of the data further: mapping quality and amplification rate cell counts distribution of keys quality metrics We will then: filter genes with very low expression identify low-quality cells filter and/or mark low quality cells 5.2 Load packages SingleCellExperiment - to store the data Matrix - to deal with sparse and/or large matrices DropletUtils - utilities for the analysis of droplet-based, inc. cell counting scater - QC scran - normalisation igraph - graphs biomaRt - for gene annotation ggplot2 - for plotting irlba - for faster PCA projDir &lt;- params$projDir wrkDir &lt;- sprintf(&quot;%s/CaronBourque2020/grch38300&quot;, projDir) outDirBit &lt;- params$outDirBit # &quot;AnaWiSeurat/Attempt1&quot; qcPlotDirBit &lt;- &quot;Plots/Qc&quot; poolBool &lt;- TRUE # FALSE # whether to read each sample in and pool them and write object to file, or just load that file. biomartBool &lt;- FALSE # TRUE # biomaRt sometimes fails, do it once, write to file and use that copy. See geneAnnot.Rmd addQcBool &lt;- TRUE runAll &lt;- TRUE saveRds &lt;- TRUE # overwrite existing Rds files dir.create(sprintf(&quot;%s/%s/%s&quot;, projDir, outDirBit, qcPlotDirBit), showWarnings = FALSE, recursive = TRUE) print(sprintf(&quot;%s/%s/%s&quot;, projDir, outDirBit, qcPlotDirBit)) ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Qc&quot; dir.create(sprintf(&quot;%s/%s/Robjects&quot;, projDir, outDirBit), showWarnings = FALSE) 5.3 Sample sheet We will load both the Caron and Hca data sets. # CaronBourque2020 cb_sampleSheetFn &lt;- file.path(projDir, &quot;Data/CaronBourque2020/SraRunTable.txt&quot;) # Human Cell Atlas hca_sampleSheetFn &lt;- file.path(projDir, &quot;Data/Hca/accList_Hca.txt&quot;) # read sample sheet in: splShtColToKeep &lt;- c(&quot;Run&quot;, &quot;Sample.Name&quot;, &quot;source_name&quot;) cb_sampleSheet &lt;- read.table(cb_sampleSheetFn, header=T, sep=&quot;,&quot;) hca_sampleSheet &lt;- read.table(hca_sampleSheetFn, header=F, sep=&quot;,&quot;) colnames(hca_sampleSheet) &lt;- &quot;Sample.Name&quot; hca_sampleSheet$Run &lt;- hca_sampleSheet$Sample.Name hca_sampleSheet$source_name &lt;- &quot;ABMMC&quot; # adult BMMC sampleSheet &lt;- rbind(cb_sampleSheet[,splShtColToKeep], hca_sampleSheet[,splShtColToKeep]) sampleSheet %&gt;% as.data.frame() %&gt;% datatable(rownames = FALSE) 5.4 Data representation We will use a SingleCellExperiment object that is described here and stores various data types: the count matrix feature (gene) annotation droplet annotation outcome of downstream analysis such as dimensionality reduction tmpFn &lt;- sprintf(&quot;%s/Images/tenxLibStructureV3.png&quot;, &quot;..&quot;) print(getwd()) ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; print(tmpFn) ## [1] &quot;../Images/tenxLibStructureV3.png&quot; print(file.exists(tmpFn)) ## [1] TRUE knitr::include_graphics(tmpFn, auto_pdf = TRUE) 5.5 Example We will load the data for the first sample in the sample sheet: SRR9264343. i &lt;- 1 sample.path &lt;- sprintf(&quot;%s/%s/%s/outs/raw_feature_bc_matrix/&quot;, wrkDir, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) sce.raw &lt;- read10xCounts(sample.path, col.names=TRUE) sce.raw ## class: SingleCellExperiment ## dim: 33538 737280 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ... ## TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## altExpNames(0): We can access these different types of data with various functions. Number of genes and droplets in the count matrix: dim(counts(sce.raw)) ## [1] 33538 737280 Features, with rowData(): head(rowData(sce.raw)) ## DataFrame with 6 rows and 3 columns ## ID Symbol Type ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000243485 ENSG00000243485 MIR1302-2HG Gene Expression ## ENSG00000237613 ENSG00000237613 FAM138A Gene Expression ## ENSG00000186092 ENSG00000186092 OR4F5 Gene Expression ## ENSG00000238009 ENSG00000238009 AL627309.1 Gene Expression ## ENSG00000239945 ENSG00000239945 AL627309.3 Gene Expression ## ENSG00000239906 ENSG00000239906 AL627309.2 Gene Expression Samples, with colData(): head(colData(sce.raw)) ## DataFrame with 6 rows and 2 columns ## Sample Barcode ## &lt;character&gt; &lt;character&gt; ## AAACCTGAGAAACCAT-1 /ssd/personal/baller.. AAACCTGAGAAACCAT-1 ## AAACCTGAGAAACCGC-1 /ssd/personal/baller.. AAACCTGAGAAACCGC-1 ## AAACCTGAGAAACCTA-1 /ssd/personal/baller.. AAACCTGAGAAACCTA-1 ## AAACCTGAGAAACGAG-1 /ssd/personal/baller.. AAACCTGAGAAACGAG-1 ## AAACCTGAGAAACGCC-1 /ssd/personal/baller.. AAACCTGAGAAACGCC-1 ## AAACCTGAGAAAGTGG-1 /ssd/personal/baller.. AAACCTGAGAAAGTGG-1 Single-cell RNA-seq data compared to bulk RNA-seq is sparse, especially with droplet-based methods such as 10X, mostly because: a given cell does not express each gene the library preparation does not capture all transcript the cell does express the sequencing depth per cell is far lower Counts, with counts(). Given the large number of droplets in a sample, count matrices can be large. They are however very sparse and can be stored in a ‘sparse matrix’ that only stores non-zero values, for example a ‘dgCMatrix’ object (‘DelayedArray’ class). counts(sce.raw) &lt;- as(counts(sce.raw), &quot;dgCMatrix&quot;) counts(sce.raw)[1:10, 1:10] ## 10 x 10 sparse Matrix of class &quot;dgCMatrix&quot; ## ## ENSG00000243485 . . . . . . . . . . ## ENSG00000237613 . . . . . . . . . . ## ENSG00000186092 . . . . . . . . . . ## ENSG00000238009 . . . . . . . . . . ## ENSG00000239945 . . . . . . . . . . ## ENSG00000239906 . . . . . . . . . . ## ENSG00000241599 . . . . . . . . . . ## ENSG00000236601 . . . . . . . . . . ## ENSG00000284733 . . . . . . . . . . ## ENSG00000235146 . . . . . . . . . . 5.6 Mapping QC 5.6.1 Gene body coverage The plot below show the average coverage (y-axis) along the body of genes (x-axis). tmpFn &lt;- sprintf(&quot;%s/Images/1_AAACCTGAGACTTTCG-1.rseqcGeneBodyCovCheck.txt.geneBodyCoverage.curves.png&quot;, &quot;..&quot;) knitr::include_graphics(tmpFn, auto_pdf = TRUE) 5.6.2 Amplification rate We will use the information stored in the ‘molecule info’ file to count the number of UMI and reads for each gene in each cell. ##mol.info.file &lt;- sprintf(&quot;%s/%s/%s/outs/molecule_info.h5&quot;, wrkDir, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) ##mol.info &lt;- read10xMolInfo(mol.info.file) # or mol.info object if issue with H5Fopen i &lt;- 1 mol.info.file &lt;- sprintf(&quot;%s/%s/%s/outs/molecule_info_h5.Rds&quot;, wrkDir, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) mol.info &lt;- readRDS(mol.info.file) # slow # &#39;data&#39; slot: mol.info$data ## DataFrame with 18544666 rows and 5 columns ## cell umi gem_group gene reads ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 AAACCTGAGAAACCTA 467082 1 3287 1 ## 2 AAACCTGAGAAACCTA 205888 1 3446 1 ## 3 AAACCTGAGAAACCTA 866252 1 3896 3 ## 4 AAACCTGAGAAACCTA 796027 1 3969 1 ## 5 AAACCTGAGAAACCTA 542561 1 5008 1 ## ... ... ... ... ... ... ## 18544662 TTTGTCATCTTTAGTC 927060 1 23634 1 ## 18544663 TTTGTCATCTTTAGTC 975865 1 27143 1 ## 18544664 TTTGTCATCTTTAGTC 364964 1 27467 4 ## 18544665 TTTGTCATCTTTAGTC 152570 1 30125 7 ## 18544666 TTTGTCATCTTTAGTC 383230 1 30283 5 # &#39;genes&#39; slot head(mol.info$genes) ## [1] &quot;ENSG00000243485&quot; &quot;ENSG00000237613&quot; &quot;ENSG00000186092&quot; &quot;ENSG00000238009&quot; ## [5] &quot;ENSG00000239945&quot; &quot;ENSG00000239906&quot; # for each cell and gene, count UMIs # slow, but needs running, at least once # so write it to file to load later if need be. tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_preProc_ampDf1.Rds&quot;, projDir, outDirBit) if(!file.exists(tmpFn)) { ampDf &lt;- mol.info$data %&gt;% data.frame() %&gt;% mutate(umi = as.character(umi)) %&gt;% group_by(cell, gene) %&gt;% summarise(nUmis = n(), totReads=sum(reads)) %&gt;% data.frame() # Write object to file saveRDS(ampDf, tmpFn) } else { ampDf &lt;- readRDS(tmpFn) } rm(tmpFn) # distribution of totReads summary(ampDf$totReads) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 2.00 6.00 15.23 12.00 79275.00 # distribution of nUmis summary(ampDf$nUmis) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 1.000 1.000 2.377 1.000 7137.000 We now plot the amplification rate. sp2 &lt;- ggplot(ampDf, aes(x=nUmis, y=totReads)) + geom_bin2d(bins = 50) + scale_fill_continuous(type = &quot;viridis&quot;) + scale_x_continuous(trans=&#39;log10&#39;) + scale_y_continuous(trans=&#39;log10&#39;) + ggtitle(&quot;totReads vs nUmis&quot;) + theme_bw() sp2 gc(verbose=FALSE) ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 9288829 496.1 13541980 723.3 13541980 723.3 ## Vcells 3021432558 23051.8 4895307436 37348.3 4074004374 31082.2 5.7 Cell calling for droplet data For a given sample, amongst the tens of thousands of droplets used in the assay, some will contain a cell while many others will not. The presence of RNA in a droplet will show with non-zero UMI count. This is however not sufficient to infer that the droplet does contain a cell. Indeed, after sample preparation, some cell debris including RNA will still float in the mix. This ambient RNA is unwillingly captured during library preparation and sequenced. Cellranger generates a count matrix that includes all droplets analysed in the assay. We will now load this ‘raw matrix’ for one sample and draw the distribution of UMI counts. Distribution of UMI counts: libSizeDf &lt;- mol.info$data %&gt;% data.frame() %&gt;% mutate(umi = as.character(umi)) %&gt;% group_by(cell) %&gt;% summarise(nUmis = n(), totReads=sum(reads)) %&gt;% data.frame() rm(mol.info) ggplot(libSizeDf, aes(x=log10(nUmis))) + geom_histogram(bins = 50) Library size varies widely, both amongst empty droplets and droplets carrying cells, mostly due to: variation in droplet size, amplification efficiency, sequencing Most cell counting methods try to identify the library size that best distinguishes empty from cell-carrying droplets. 5.7.1 Mixture model This method by default fits a mixture of two normal distributions to the logged library sizes: one with a small mean for empty droplets the other with a higher mean for cell-carrying droplets set.seed(100) # get package library(&quot;mixtools&quot;) # have library sizes on a log10 scale log10_lib_size &lt;- log10(libSizeDf$nUmis) # fit mixture mix &lt;- normalmixEM(log10_lib_size, mu=c(log10(100), log10(1000)), maxrestarts=50, epsilon = 1e-03) ## number of iterations= 29 # plot plot(mix, which=2, xlab2=&quot;log(mol per cell)&quot;) # get density for each distribution: p1 &lt;- dnorm(log10_lib_size, mean=mix$mu[1], sd=mix$sigma[1]) p2 &lt;- dnorm(log10_lib_size, mean=mix$mu[2], sd=mix$sigma[2]) # find intersection: if (mix$mu[1] &lt; mix$mu[2]) { split &lt;- min(log10_lib_size[p2 &gt; p1]) } else { split &lt;- min(log10_lib_size[p1 &gt; p2]) } # show split on plot: abline(v=split, lwd=2) 5.7.2 Barcode rank plot The barcode rank plot shows the library sizes against their rank in decreasing order, for the first 10000 droplets only. barcode_rank &lt;- rank(-libSizeDf$nUmis) plot(barcode_rank, libSizeDf$nUmis, xlim=c(1,10000), ylab=&quot;library size&quot;) Given the exponential shape of the curve above, library sizes can be shown on the log10 scale: plot(barcode_rank, log10_lib_size, xlim=c(1,10000)) The plot above shows that the majority of droplets have fewer than 100 UMIs, e.g. droplets with rank greater than 4000. We will redraw the plot to focus on droplets with lower ranks, by using the log10 scale for the x-axis. plot(log10(barcode_rank), log10_lib_size, xlim=log10(c(1,10000))) The point on the curve where it drops sharply may be used as the split point. Before that point library sizes are high, because droplets carry a cell. After that point, library sizes are far smaller because droplets do not carry a cell, only ambient RNA (… or do they?). Here, we could ‘visually’ approximate the number of cells to 2500. There are however more robust and convenient methods. 5.7.3 Inflection point We could also compute the inflection point of the curve. o &lt;- order(barcode_rank) log10_lib_size &lt;- log10_lib_size[o] barcode_rank &lt;- barcode_rank[o] rawdiff &lt;- diff(log10_lib_size)/diff(barcode_rank) inflection &lt;- which(rawdiff == min(rawdiff[100:length(rawdiff)], na.rm=TRUE)) plot(x=log10(barcode_rank), y=log10_lib_size, xlim=log10(c(1,10000))) abline(v=log10(inflection), col=&quot;red&quot;, lwd=2) The inflection is at 3279 UMIs (3.5157414 on the log10 scale). 2306 droplets have at least these many UMIs and would thus contain one cell (or more). 5.7.4 Cellranger v1 and v2 Given an expected number of cells, cellranger used to assume a ~10-fold range of library sizes for real cells and estimate this range (cellranger v1 and v2). The threshold was defined as the 99th quantile of the library size, divided by 10. # approximate number of cells expected: n_cells &lt;- 2500 # CellRanger totals &lt;- sort(libSizeDf$nUmis, decreasing = TRUE) # 99th percentile of top n_cells divided by 10 thresh = totals[round(0.01*n_cells)]/10 #plot(log10(totals), xlim=c(1,10000)) plot(x=log10(seq(1,10000)), y=log10(totals)[1:10000] ) abline(h=log10(thresh), col=&quot;red&quot;, lwd=2) The threshold is at 1452 UMIs and 2773 cells are detected. 5.7.5 DropletUtils and EmptyDrops The DropletUtils package offers utilities to analyse droplet-based data, including cell counting using the library size as seen above. These simple approaches may exclude droplets with small or quiet cells with low RNA content. The emptyDrops method calls cells by first computing the expression profile for droplets with RNA content so low they almost certainly do not contain any cell: the ‘background’ or ‘ambient’ profile. The method then tests each non-background droplet for significant difference in expression profile. Let’s first check the knee and inflection methods. br.out &lt;- barcodeRanks(counts(sce.raw)) plot(br.out$rank, br.out$total, log=&quot;xy&quot;, xlab=&quot;Rank&quot;, ylab=&quot;Total UMI count&quot;) o &lt;- order(br.out$rank) lines(br.out$rank[o], br.out$fitted[o], col=&quot;red&quot;) abline(h=metadata(br.out)$knee, col=&quot;dodgerblue&quot;, lty=2) abline(h=metadata(br.out)$inflection, col=&quot;forestgreen&quot;, lty=2) legend(&quot;bottomleft&quot;, lty=2, col=c(&quot;dodgerblue&quot;, &quot;forestgreen&quot;), legend=c(&quot;knee&quot;, &quot;inflection&quot;)) Testing for empty droplets. We will call cells with a false discovery rate (FDR) of 0.1% so that at most 1 in 1000 droplets called may be empty. # a bit slow # significance is computed by simulation so we set a seed for reproducibility set.seed(100) # run analysis: e.out &lt;- emptyDrops(counts(sce.raw)) e.out ## DataFrame with 737280 rows and 5 columns ## Total LogProb PValue Limited FDR ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;logical&gt; &lt;numeric&gt; ## AAACCTGAGAAACCAT-1 0 NA NA NA NA ## AAACCTGAGAAACCGC-1 0 NA NA NA NA ## AAACCTGAGAAACCTA-1 31 NA NA NA NA ## AAACCTGAGAAACGAG-1 0 NA NA NA NA ## AAACCTGAGAAACGCC-1 0 NA NA NA NA ## ... ... ... ... ... ... ## TTTGTCATCTTTACAC-1 0 NA NA NA NA ## TTTGTCATCTTTACGT-1 1 NA NA NA NA ## TTTGTCATCTTTAGGG-1 0 NA NA NA NA ## TTTGTCATCTTTAGTC-1 26 NA NA NA NA ## TTTGTCATCTTTCCTC-1 0 NA NA NA NA NAs are assigned to droplets used to compute the ambient profile. Get numbers of droplets in each class defined by FDR and the cut-off used: summary(e.out$FDR &lt;= 0.001) ## Mode FALSE TRUE NA&#39;s ## logical 487 3075 733718 The test significance is computed by permutation. For each droplet tested, the number of permutations may limit the value of the p-value. This information is available in the ‘Limited’ column. If ‘Limited’ is ‘TRUE’ for any non-significant droplet, the number of permutations was too low, should be increased and the analysis re-run. table(Sig=e.out$FDR &lt;= 0.001, Limited=e.out$Limited) ## Limited ## Sig FALSE TRUE ## FALSE 487 0 ## TRUE 76 2999 Let’s check that the background comprises only empty droplets. If the droplets used to define the background profile are indeed empty, testing them should result in a flat distribution of p-values. Let’s test the ‘ambient’ droplets and draw the p-value distribution. set.seed(100) limit &lt;- 100 all.out &lt;- emptyDrops(counts(sce.raw), lower=limit, test.ambient=TRUE) hist(all.out$PValue[all.out$Total &lt;= limit &amp; all.out$Total &gt; 0], xlab=&quot;P-value&quot;, main=&quot;&quot;, col=&quot;grey80&quot;) The distribution of p-values looks uniform with no large peak for small values: no cell in these droplets. To evaluate the outcome of the analysis, we will plot the strength of the evidence against library size. is.cell &lt;- e.out$FDR &lt;= 0.001 Number of cells detected: 3075. The plot plot shows the strength of the evidence against the library size. Each point is a droplet coloured: in black if without cell, in red if with a cell (or more) in green if with a cell (or more) as defined with emptyDrops but not the inflection method. # colour: cellColour &lt;- ifelse(is.cell, &quot;red&quot;, &quot;black&quot;) # rep(&quot;black&quot;, nrow((e.out))) # boolean for presence of cells as defined by the inflection method tmpBoolInflex &lt;- e.out$Total &gt; metadata(br.out)$inflection # boolean for presence of cells as defined by the emptyDrops method tmpBoolSmall &lt;- e.out$FDR &lt;= 0.001 tmpBoolRecov &lt;- !tmpBoolInflex &amp; tmpBoolSmall cellColour[tmpBoolRecov] &lt;- &quot;green&quot; # &#39;recovered&#39; cells # plot strength of significance vs library size plot(log10(e.out$Total), -e.out$LogProb, col=cellColour, xlim=c(2,max(log10(e.out$Total))), xlab=&quot;Total UMI count&quot;, ylab=&quot;-Log Probability&quot;) # add point to show &#39;recovered&#39; cell on top points(log10(e.out$Total)[tmpBoolRecov], -e.out$LogProb[tmpBoolRecov], pch=16, col=&quot;green&quot;) Let’s filter out empty droplets. sce.ed &lt;- sce.raw[,which(e.out$FDR &lt;= 0.001)] # &#39;ed&#39; for empty droplet rm(sce.raw); gc(); ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 9521622 508.6 16305648 870.9 16305648 870.9 ## Vcells 1404540205 10715.8 2765812427 21101.5 2297115936 17525.7 And check the new SCE object: sce.ed ## class: SingleCellExperiment ## dim: 33538 3075 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames(3075): AAACCTGAGACTTTCG-1 AAACCTGGTCTTCAAG-1 ... ## TTTGTCACAGGCTCAC-1 TTTGTCAGTTCGGCAC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## altExpNames(0): rm(sce.ed) Cell calling in cellranger v3 uses a method similar to emptyDrops() and a ‘filtered matrix’ is generated that only keeps droplets deemed to contain a cell (or more). We will load these filtered matrices now. 5.8 Load filtered matrices Each sample was analysed with cellranger separately. We load filtered matrices one sample at a time, showing for each the name and number of features and cells. # load data: # a bit slow # use &#39;cache.lazy = FALSE&#39; to avoid &#39;long vectors not supported yet&#39; when &#39;cache=TRUE&#39; sce.list &lt;- vector(&quot;list&quot;, length = nrow(sampleSheet)) for (i in 1:nrow(sampleSheet)) { print(sprintf(&quot;&#39;Run&#39; %s, &#39;Sample.Name&#39; %s&quot;, sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Sample.Name&quot;])) sample.path &lt;- sprintf(&quot;%s/%s/%s/outs/filtered_feature_bc_matrix/&quot;, sprintf(&quot;%s/%s/grch38300&quot;, projDir, ifelse(sampleSheet[i,&quot;source_name&quot;] == &quot;ABMMC&quot;, &quot;Hca&quot;, &quot;CaronBourque2020&quot;)), sampleSheet[i,&quot;Run&quot;], sampleSheet[i,&quot;Run&quot;]) sce.list[[i]] &lt;- read10xCounts(sample.path) print(dim(sce.list[[i]])) } ## [1] &quot;&#39;Run&#39; SRR9264343, &#39;Sample.Name&#39; GSM3872434&quot; ## [1] 33538 3088 ## [1] &quot;&#39;Run&#39; SRR9264344, &#39;Sample.Name&#39; GSM3872435&quot; ## [1] 33538 6678 ## [1] &quot;&#39;Run&#39; SRR9264345, &#39;Sample.Name&#39; GSM3872436&quot; ## [1] 33538 5054 ## [1] &quot;&#39;Run&#39; SRR9264346, &#39;Sample.Name&#39; GSM3872437&quot; ## [1] 33538 6096 ## [1] &quot;&#39;Run&#39; SRR9264347, &#39;Sample.Name&#39; GSM3872438&quot; ## [1] 33538 5442 ## [1] &quot;&#39;Run&#39; SRR9264348, &#39;Sample.Name&#39; GSM3872439&quot; ## [1] 33538 5502 ## [1] &quot;&#39;Run&#39; SRR9264349, &#39;Sample.Name&#39; GSM3872440&quot; ## [1] 33538 4126 ## [1] &quot;&#39;Run&#39; SRR9264350, &#39;Sample.Name&#39; GSM3872441&quot; ## [1] 33538 3741 ## [1] &quot;&#39;Run&#39; SRR9264351, &#39;Sample.Name&#39; GSM3872442&quot; ## [1] 33538 978 ## [1] &quot;&#39;Run&#39; SRR9264352, &#39;Sample.Name&#39; GSM3872442&quot; ## [1] 33538 1150 ## [1] &quot;&#39;Run&#39; SRR9264353, &#39;Sample.Name&#39; GSM3872443&quot; ## [1] 33538 4964 ## [1] &quot;&#39;Run&#39; SRR9264354, &#39;Sample.Name&#39; GSM3872444&quot; ## [1] 33538 4255 ## [1] &quot;&#39;Run&#39; MantonBM1, &#39;Sample.Name&#39; MantonBM1&quot; ## [1] 33538 23283 ## [1] &quot;&#39;Run&#39; MantonBM2, &#39;Sample.Name&#39; MantonBM2&quot; ## [1] 33538 25055 ## [1] &quot;&#39;Run&#39; MantonBM3, &#39;Sample.Name&#39; MantonBM3&quot; ## [1] 33538 24548 ## [1] &quot;&#39;Run&#39; MantonBM4, &#39;Sample.Name&#39; MantonBM4&quot; ## [1] 33538 26478 ## [1] &quot;&#39;Run&#39; MantonBM5, &#39;Sample.Name&#39; MantonBM5&quot; ## [1] 33538 26383 ## [1] &quot;&#39;Run&#39; MantonBM6, &#39;Sample.Name&#39; MantonBM6&quot; ## [1] 33538 22801 ## [1] &quot;&#39;Run&#39; MantonBM7, &#39;Sample.Name&#39; MantonBM7&quot; ## [1] 33538 24372 ## [1] &quot;&#39;Run&#39; MantonBM8, &#39;Sample.Name&#39; MantonBM8&quot; ## [1] 33538 24860 Let’s combine all 20 samples into a single object. We first check the feature lists are identical. # check row names are the same # compare to that for the first sample rowNames1 &lt;- rownames(sce.list[[1]]) for (i in 2:nrow(sampleSheet)) { print(identical(rowNames1, rownames(sce.list[[i]]))) } ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE A cell barcode comprises the actual sequence and a ‘group ID’, e.g. AAACCTGAGAAACCAT-1. The latter helps distinguish cells with identical barcode sequence but come from different samples. As each sample was analysed separately, the group ID is set to 1 in all data sets. To pool these data sets we first need to change group IDs so cell barcodes are unique across all samples. We will use the position of the sample in the sample sheet. # subset 2000 cells: # mind that is not mentioned in Rds file names ... if(ncol(sce.list[[1]]) &lt; 2000) { sce &lt;- sce.list[[1]] } else { sce &lt;- sce.list[[1]][, sample(ncol(sce.list[[1]]), 2000)] } colData(sce)$Barcode &lt;- gsub(&quot;([0-9])$&quot;, 1, colData(sce)$Barcode) print(head(colData(sce)$Barcode)) ## [1] &quot;GATGCTAGTATCAGTC-1&quot; &quot;GTCCTCAGTCCAAGTT-1&quot; &quot;CGCGTTTAGGCTAGCA-1&quot; ## [4] &quot;GGATTACGTGCGAAAC-1&quot; &quot;CGTTGGGCAGCCAATT-1&quot; &quot;GTGCGGTGTCATTAGC-1&quot; print(tail(colData(sce)$Barcode)) ## [1] &quot;CGTCCATAGATTACCC-1&quot; &quot;CAGCCGACATCCCATC-1&quot; &quot;GCAGCCACACTTCTGC-1&quot; ## [4] &quot;CAAGATCGTCGGCACT-1&quot; &quot;GTAACGTTCCCATTAT-1&quot; &quot;TTCGGTCAGGGTTCCC-1&quot; for (i in 2:nrow(sampleSheet)) { if(ncol(sce.list[[i]]) &lt; 2000) { sce.tmp &lt;- sce.list[[i]] } else { sce.tmp &lt;- sce.list[[i]][, sample(ncol(sce.list[[i]]), 2000)] } colData(sce.tmp)$Barcode &lt;- gsub(&quot;([0-9])$&quot;, i, colData(sce.tmp)$Barcode) sce &lt;- cbind(sce, sce.tmp) print(tail(colData(sce)$Barcode, 2)) } ## [1] &quot;AGAGTGGCACCAGTTA-2&quot; &quot;AACACGTGTACCTACA-2&quot; ## [1] &quot;CGGCTAGAGCTGAACG-3&quot; &quot;TAGCCGGAGTTAGCGG-3&quot; ## [1] &quot;ACACCAAGTCAGAAGC-4&quot; &quot;AAGGTTCAGGCCGAAT-4&quot; ## [1] &quot;AGGGTGAAGAGTCGGT-5&quot; &quot;CTGCGGAGTGAGTATA-5&quot; ## [1] &quot;GGCGACTGTGTTTGGT-6&quot; &quot;TTGGAACAGTGTACTC-6&quot; ## [1] &quot;TGTGGTACACTTACGA-7&quot; &quot;ACTGAGTTCTATCGCC-7&quot; ## [1] &quot;GTCACAACAATCGGTT-8&quot; &quot;CTACATTGTCTCTCGT-8&quot; ## [1] &quot;TTTGGTTGTGCATCTA-9&quot; &quot;TTTGTCACAGCTCGAC-9&quot; ## [1] &quot;TTTGTCAGTAAATGTG-10&quot; &quot;TTTGTCAGTACAAGTA-10&quot; ## [1] &quot;TGCGGGTAGCGTAGTG-11&quot; &quot;CTAGAGTCAAAGTGCG-11&quot; ## [1] &quot;GCAATCAAGGCTATCT-12&quot; &quot;GGGTCTGCATAAGACA-12&quot; ## [1] &quot;TATCTCAGTCATATCG-13&quot; &quot;TCGTACCTCTGGTATG-13&quot; ## [1] &quot;CGTTCTGCAGCTGTTA-14&quot; &quot;TCGCGAGTCATCTGCC-14&quot; ## [1] &quot;ACTTACTCAGGTTTCA-15&quot; &quot;ACTGCTCTCGGTTAAC-15&quot; ## [1] &quot;AGAGTGGCAAAGGCGT-16&quot; &quot;ACACCCTAGATCCCGC-16&quot; ## [1] &quot;GCTGGGTAGGCTCATT-17&quot; &quot;TGTTCCGCACAGACAG-17&quot; ## [1] &quot;CTACATTGTAGCGATG-18&quot; &quot;TGGGCGTCACACCGCA-18&quot; ## [1] &quot;TTCCCAGCAGGGTACA-19&quot; &quot;GTTCTCGGTCCTCCAT-19&quot; ## [1] &quot;GCTGGGTCATAACCTG-20&quot; &quot;TATGCCCCAGCGTCCA-20&quot; rm(sce.list) We now add the sample sheet information to the object metadata. colDataOrig &lt;- colData(sce) # split path: tmpList &lt;- strsplit(colDataOrig$Sample, split=&quot;/&quot;) # get Run ID, to use to match sample in the meta data and sample sheet objects: tmpVec &lt;- unlist(lapply(tmpList, function(x){x[9]})) colData(sce)$Run &lt;- tmpVec # remove path to filtered matrix files by sample name in &#39;Sample&#39;: colData(sce)$Sample &lt;- NULL # merge: colData(sce) &lt;- colData(sce) %&gt;% data.frame %&gt;% left_join(sampleSheet[,splShtColToKeep], &quot;Run&quot;) %&gt;% relocate() %&gt;% DataFrame Let’s save the object for future reference. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postPool.Rds&quot;, projDir, outDirBit) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postPool.Rds&quot;, projDir, outDirBit) sce &lt;- readRDS(tmpFn) 5.9 Properties of scRNA-seq data The number and identity of genes detected in a cell vary across cells: the total number of genes detected across all cells is far larger than the number of genes detected in each cell. Total number of genes detected across cells: # for each gene, compute total number of UMIs across all cells, # then counts genes with at least one UMI: sum(rowSums(counts(sce)) &gt; 0) ## [1] 25116 Summary of the distribution of the number of genes detected per cell: # for each cell count number of genes with at least 1 UMI # then compute distribution moments: summary(colSums(counts(sce) &gt; 0)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 26 717 940 1228 1521 6586 Now let’s plot for each gene the total number of UMIs and the proportion of cells that express it. Lowly expressed genes tend to be detected in a large proportion of cells. The higher the overall expression the lower the proportion of cells. # randomly subset 1000 cells. tmpCounts &lt;- counts(sce)[,sample(1000)] plot(rowSums(tmpCounts), rowMeans(tmpCounts &gt; 0), log = &quot;x&quot;, xlab=&quot;total number of UMIs&quot;, ylab=&quot;proportion of cells expressing the gene&quot; ) Count genes that are not ‘expressed’ (detected): not.expressed &lt;- rowSums(counts(sce)) == 0 table(not.expressed) ## not.expressed ## FALSE TRUE ## 25116 8422 Plot the percentage of counts per gene and show genes with the highest UMI counts: #Compute the relative expression of each gene per cell rel_expression &lt;- t( t(counts(sce)) / Matrix::colSums(counts(sce))) * 100 rownames(rel_expression) &lt;- rowData(sce)$Symbol most_expressed &lt;- sort(Matrix::rowSums( rel_expression ),T)[20:1] / ncol(sce) boxplot( as.matrix(t(rel_expression[names(most_expressed),])), cex=.1, las=1, xlab=&quot;% total count per cell&quot;, col=scales::hue_pal()(20)[20:1], horizontal=TRUE) Mind that we have combined two data sets here. It may be interesting to count non-expressed genes in each set separately. 5.10 Quality control Cell calling performed above does not inform on the quality of the library in each of the droplets kept. Poor-quality cells, or rather droplets, may be caused by cell damage during dissociation or failed library preparation. They usually have low UMI counts, few genes detected and/or high mitochondrial content. The presence may affect normalisation, assessment of cell population heterogeneity, clustering and trajectory: Normalisation: Contaminating genes, ‘the ambient RNA’, are detected at low levels in all libraires. In low quality libraries with low RNA content, scaling will increase counts for these genes more than for better-quality cells, resulting in their apparent upregulation in these cells and increased variance overall. Cell population heterogeneity: variance estimation and dimensionality reduction with PCA where the first principal component will be correlated with library size, rather than biology. Clustering and trajectory: higher mitochondrial and/or nuclear RNA content may cause low-quality cells to cluster separately or form states or trajectories between distinct cell types. We will now exclude lowly expressed features and identify low-quality cells using the following metrics mostly: library size, i.e. the total number of UMIs per cell number of features detected per cell mitochondrial content, i.e. the proportion of UMIs that map to mitochondrial genes, with higher values consistent with leakage from the cytoplasm of RNA, but not mitochondria We will first annotate genes, to know which ones are mitochondrial, then use scater’s addPerCellQC() to compute various metrics. Annotate genes with biomaRt. # retrieve the feature information gene.info &lt;- rowData(sce) # setup the biomaRt connection to Ensembl using the correct species genome (hsapiens_gene_ensembl) ensembl &lt;- useEnsembl(biomart=&#39;ensembl&#39;, dataset=&#39;hsapiens_gene_ensembl&#39;, mirror = &quot;www&quot;) #ensembl = useMart(biomart=&quot;ensembl&quot;, # dataset=&#39;hsapiens_gene_ensembl&#39;, # host = &quot;www.ensembl.org&quot;) # ensemblRedirect = FALSE # retrieve the attributes of interest from biomaRt using the Ensembl gene ID as the key # beware that this will only retrieve information for matching IDs gene_symbol &lt;- getBM(attributes=c(&#39;ensembl_gene_id&#39;, &#39;external_gene_name&#39;, &#39;chromosome_name&#39;, &#39;start_position&#39;, &#39;end_position&#39;, &#39;strand&#39;), filters=&#39;ensembl_gene_id&#39;, mart=ensembl, values=gene.info[, 1]) # create a new data frame of the feature information gene.merge &lt;- merge(gene_symbol, gene.info, by.x=c(&#39;ensembl_gene_id&#39;), by.y=c(&#39;ID&#39;), all.y=TRUE) rownames(gene.merge) &lt;- gene.merge$ensembl_gene_id # set the order for the same as the original gene information gene.merge &lt;- gene.merge[gene.info[, 1], ] # reset the rowdata on the SCE object to contain all of this information rowData(sce) &lt;- gene.merge # slow # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postBiomart.Rds&quot;, projDir, outDirBit) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postBiomart.Rds&quot;, projDir, outDirBit) sce &lt;- readRDS(tmpFn) Number of genes per chromosome, inc. 13 on the mitochondrial genome: # number of genes per chromosome table(rowData(sce)$chromosome_name) %&gt;% as.data.frame() %&gt;% dplyr::rename(Chromosome=Var1, NbGenes=Freq) %&gt;% datatable(rownames = FALSE) # mitochondrial genes is.mito &lt;- which(rowData(sce)$chromosome_name==&quot;MT&quot;) Calculate and store QC metrics for genes with addPerFeatureQC() and for cells with addPerCellQC(). # long # for genes sce &lt;- addPerFeatureQC(sce) head(rowData(sce)) %&gt;% as.data.frame() %&gt;% datatable(rownames = FALSE) # ENS ID Three columns of interest for cells: ‘sum’: total UMI count ‘detected’: number of features (genes) detected ‘subsets_Mito_percent’: percentage of reads mapped to mitochondrial transcripts # for cells sce &lt;- addPerCellQC(sce, subsets=list(Mito=is.mito)) head(colData(sce)) %&gt;% as.data.frame() %&gt;% datatable(rownames = FALSE) # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postAddQc.Rds&quot;, projDir, outDirBit) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postAddQc.Rds&quot;, projDir, outDirBit) sce &lt;- readRDS(tmpFn) 5.10.1 QC metric distribution Overall: par(mfrow=c(1, 2)) hist(log10(sce$sum), breaks=20, col=&quot;grey80&quot;, xlab=&quot;Log-total UMI count&quot;, main=&quot;&quot;) hist(sce$subsets_Mito_percent, breaks=20, col=&quot;grey80&quot;, xlab=&quot;Proportion of reads in mitochondrial genes&quot;, main=&quot;&quot;) abline(v=20, lty=2, col=&#39;purple&#39;) Per sample group: sce$source_name &lt;- factor(sce$source_name) sce$block &lt;- sce$source_name sce$setName &lt;- ifelse(grepl(&quot;ABMMC&quot;, sce$source_name), &quot;Hca&quot;, &quot;Caron&quot;) Library size (‘Total count’): p &lt;- plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Total count&quot;) p Number of genes (‘detected’): p &lt;- plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) p Mitochondrial content (‘subsets_Mito_percent’): p &lt;- plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, other_fields=&quot;setName&quot;) + # facet_wrap(~setName) + ggtitle(&quot;Mito percent&quot;) p tmpFn &lt;- sprintf(&quot;%s/%s/%s/qc_metricDistrib_plotColData2.png&quot;, projDir, outDirBit, qcPlotDirBit) png(tmpFn) # violin plots gridExtra::grid.arrange( plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Total count&quot;), plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, other_fields=&quot;setName&quot;) + #facet_wrap(~setName) + scale_y_log10() + ggtitle(&quot;Detected features&quot;), plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, other_fields=&quot;setName&quot;) + # facet_wrap(~setName) + ggtitle(&quot;Mito percent&quot;), ncol=1 ) dev.off() ## png ## 2 tmpFn &lt;- sprintf(&quot;../%s/qc_metricDistrib_plotColData2.png&quot;, qcPlotDirBit) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Correlation between the number of genes detected and library size (‘detected’ against ‘sum’): sp &lt;- ggplot(data.frame(colData(sce)), aes(x=sum, y=detected, col=subsets_Mito_percent)) + geom_point() sp + facet_wrap(~source_name) 5.11 Identification of low-quality cells with adaptive thresholds One can use hard threshold for the library size, number of genes detected and mitochondrial content. These will however vary across runs. It may therefore be preferable to rely on outlier detection to identify cells that markerdly differ from most cells. We saw above that the distribution of the QC metrics is close to Normal. Hence, we can detect outlier using the median and the median absolute deviation (MAD) from the median (not the mean and the standard deviation that both are sensitive to outliers). For a given metric, an outlier value is one that lies over some number of MADs away from the median. A cell will be excluded if it is an outlier in the part of the range to avoid, for example low gene counts, or high mitochondrial content. For a normal distribution, a threshold defined with a distance of 3 MADs from the median retains about 99% of values. 5.11.1 Library size For the library size we use the log scale to avoid negative values for lower part of the distribution. qc.lib2 &lt;- isOutlier(sce$sum, log=TRUE, type=&quot;lower&quot;) table(qc.lib2) ## qc.lib2 ## FALSE TRUE ## 37795 333 Threshold values: attr(qc.lib2, &quot;thresholds&quot;) ## lower higher ## 576.4435 Inf 5.11.2 Number of genes For the number of genes detected we also use the log scale to avoid negative values for lower part of the distribution. qc.nexprs2 &lt;- isOutlier(sce$detected, log=TRUE, type=&quot;lower&quot;) table(qc.nexprs2) ## qc.nexprs2 ## FALSE TRUE ## 37723 405 Threshold values: attr(qc.nexprs2, &quot;thresholds&quot;) ## lower higher ## 204.1804 Inf 5.11.3 Mitochondrial content For the mitochondrial content the exclusion zone is in the higher part of the distribution. qc.mito2 &lt;- isOutlier(sce$subsets_Mito_percent, type=&quot;higher&quot;) table(qc.mito2) ## qc.mito2 ## FALSE TRUE ## 35755 2373 Threshold values: attr(qc.mito2, &quot;thresholds&quot;) ## lower higher ## -Inf 8.715114 5.11.4 Summary discard2 &lt;- qc.lib2 | qc.nexprs2 | qc.mito2 # Summarize the number of cells removed for each reason. DataFrame(LibSize=sum(qc.lib2), NExprs=sum(qc.nexprs2), MitoProp=sum(qc.mito2), Total=sum(discard2)) ## DataFrame with 1 row and 4 columns ## LibSize NExprs MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 333 405 2373 2900 5.11.5 All steps at once The steps above may be run at once with quickPerCellQC(): reasons &lt;- quickPerCellQC(colData(sce), percent_subsets=c(&quot;subsets_Mito_percent&quot;)) colSums(as.matrix(reasons)) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) 5.11.6 Assumptions Data quality depends on the tissue analysed, some being difficult to dissociate, e.g. brain, so that one level of QC stringency will not fit all data sets. Filtering based on QC metrics as done here assumes that these QC metrics are not correlated with biology. This may not necessarily be true in highly heterogenous data sets where some cell types represented by good-quality cells may have low RNA content or high mitochondrial content. 5.12 Experimental factors The two data sets analysed here may have been obtained in experiments with different settings, such as cell preparation or sequencing depth. Such differences between these two batches would affect the adaptive thesholds discussed above. We will now perform QC in each batch separately. We will use the quickPerCellQC() ‘batch’ option. batch.reasons &lt;- quickPerCellQC(colData(sce), percent_subsets=c(&quot;subsets_Mito_percent&quot;), batch=sce$setName) colSums(as.matrix(batch.reasons)) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) sce$discard &lt;- batch.reasons$discard Fewer cells are discarded, in particular because of small library size and low gene number. But the differences are deeper as the two sets only partially overlap: table(reasons$discard, batch.reasons$discard) ## ## FALSE TRUE ## FALSE 34880 348 ## TRUE 805 2095 Library size: plotColData(sce, x=&quot;block&quot;, y=&quot;sum&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + scale_y_log10() + ggtitle(&quot;Total count&quot;) Number of genes detected: plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) plotColData(sce, x=&quot;block&quot;, y=&quot;detected&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + facet_wrap(~colour_by) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) Mitochondrial content: plotColData(sce, x=&quot;block&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=&quot;discard&quot;, other_fields=&quot;setName&quot;) + ggtitle(&quot;Mito percent&quot;) 5.12.1 Identify poor-quality batches We will now consider the ‘sample’ batch to illustrate how to identify batches with overall low quality or different from other batches. Let’s compare thresholds across sample groups. 5.12.1.1 Number of genes detected # compute discard.nexprs &lt;- isOutlier(sce$detected, log=TRUE, type=&quot;lower&quot;, batch=sce$Sample.Name) nexprs.thresholds &lt;- attr(discard.nexprs, &quot;thresholds&quot;)[&quot;lower&quot;,] nexprs.thresholds %&gt;% round(0) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) Without block: # plots - without blocking discard.nexprs.woBlock &lt;- isOutlier(sce$detected, log=TRUE, type=&quot;lower&quot;) without.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;detected&quot;, colour_by=I(discard.nexprs.woBlock)) without.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) With block: # plots - with blocking with.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;detected&quot;, colour_by=I(discard.nexprs)) with.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 5.12.1.1.1 Mitochondrial content discard.mito &lt;- isOutlier(sce$subsets_Mito_percent, type=&quot;higher&quot;, batch=sce$Sample.Name) mito.thresholds &lt;- attr(discard.mito, &quot;thresholds&quot;)[&quot;higher&quot;,] mito.thresholds %&gt;% round(0) %&gt;% as.data.frame() %&gt;% datatable(rownames = TRUE) Without block: # plots - without blocking discard.mito.woBlock &lt;- isOutlier(sce$subsets_Mito_percent, type=&quot;higher&quot;) without.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=I(discard.mito.woBlock)) without.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) With block: # plots - with blocking with.blocking &lt;- plotColData(sce, x=&quot;Sample.Name&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=I(discard.mito)) with.blocking + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 5.12.1.2 Samples to check Names of samples with a ‘low’ threshold for the number of genes detected: # names names(nexprs.thresholds)[isOutlier(nexprs.thresholds, type=&quot;lower&quot;)] ## character(0) Names of samples with a ‘high’ threshold for mitocondrial content: # names names(mito.thresholds)[isOutlier(mito.thresholds, type=&quot;higher&quot;)] ## [1] &quot;GSM3872434&quot; &quot;GSM3872437&quot; &quot;GSM3872438&quot; &quot;GSM3872443&quot; 5.12.2 QC metrics space A similar approach exists to identify outliers using a set of metrics together. We will the same QC metrics as above. # slow stats &lt;- cbind(log10(sce$sum), log10(sce$detected), sce$subsets_Mito_percent) library(robustbase) outlying &lt;- adjOutlyingness(stats, only.outlyingness = TRUE) multi.outlier &lt;- isOutlier(outlying, type = &quot;higher&quot;) summary(multi.outlier) ## Mode FALSE TRUE ## logical 34298 3830 Compare with previous filtering: table(sce$discard, multi.outlier) ## multi.outlier ## FALSE TRUE ## FALSE 33461 2224 ## TRUE 837 1606 5.12.3 QC PCA One can also perform a principal components analysis (PCA) on cells, based on the column metadata in a SingleCellExperiment object. Here we will only use the library size, the number of genes detected (which is correlated with library size) and the mitochondrial content. sce &lt;- runColDataPCA(sce, variables=list( &quot;sum&quot;, &quot;detected&quot;, &quot;subsets_Mito_percent&quot;), outliers=TRUE) #reducedDimNames(sce) #head(reducedDim(sce)) #head(colData(sce)) #p &lt;- plotReducedDim(sce, dimred=&quot;PCA_coldata&quot;, colour_by = &quot;Sample.Name&quot;) p &lt;- plotReducedDim(sce, dimred=&quot;PCA_coldata&quot;, colour_by = &quot;outlier&quot;) p + facet_wrap(~sce$discard) Compare with previous filtering: table(sce$discard, sce$outlier) ## ## FALSE TRUE ## FALSE 35001 684 ## TRUE 769 1674 table(multi.outlier, sce$outlier) ## ## multi.outlier FALSE TRUE ## FALSE 33675 623 ## TRUE 2095 1735 5.12.4 Other diagnostic plots Mitochondrial content against library size: plotColData(sce, x=&quot;sum&quot;, y=&quot;subsets_Mito_percent&quot;, colour_by=&quot;discard&quot;) sp &lt;- ggplot(data.frame(colData(sce)), aes(x=sum, y=subsets_Mito_percent, col=discard)) + geom_point(size = 0.05, alpha = 0.7) + geom_density_2d(size = 0.5, colour = &quot;blue&quot;) + guides(colour = guide_legend(override.aes = list(size=1, alpha=1))) + theme(legend.position=&quot;bottom&quot;) #sp ggExtra::ggMarginal(sp) Mind distributions: sp + facet_wrap(~source_name) 5.12.5 Filter low-quality cells out We will now exclude poor-quality cells. scePreQc &lt;- sce sce &lt;- scePreQc[,!scePreQc$discard] sce ## class: SingleCellExperiment ## dim: 33538 35685 ## metadata(20): Samples Samples ... Samples Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(10): ensembl_gene_id external_gene_name ... mean detected ## colnames: NULL ## colData names(14): Barcode Run ... discard outlier ## reducedDimNames(1): PCA_coldata ## altExpNames(0): We also write the R object to file to use later if need be. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postQc.Rds&quot;, projDir, outDirBit) saveRDS(sce, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_postQc.Rds&quot;, projDir, outDirBit) sce &lt;- readRDS(tmpFn) 5.13 Novelty The number of genes per UMI for each cell informs on the level of sequencing saturation achieved ( hbctraining). For a given cell, as sequencing depth increases each extra UMI is less likely to correspnf to a gene not already detected in that cell. Cells with small library size tend to have higher overall ‘novelty’ i.e. they have not reached saturation for any given gene. Outlier cell may have a library with low complexity. This may suggest the some cell types, e.g. red blood cells. The expected novelty is about 0.8. Here we see that some PBMMCs have low novelty, ie overall fewer genes were detected for an equivalent number of UMIs in these cells than in others. p &lt;- colData(sce) %&gt;% data.frame() %&gt;% ggplot(aes(x=sum, y=detected, color=subsets_Mito_percent)) + geom_point() + stat_smooth(method=lm) + scale_x_log10() + scale_y_log10() + geom_vline(xintercept = 800) + facet_wrap(~source_name) p # write plot to file tmpFn &lt;- sprintf(&quot;%s/%s/%s/novelty_scat.png&quot;, projDir, outDirBit, qcPlotDirBit) ggsave(plot=p, file=tmpFn) # Novelty # the number of genes per UMI for each cell, # https://hbctraining.github.io/In-depth-NGS-Data-Analysis-Course/sessionIV/lessons/SC_quality_control_analysis.html # Add number of UMIs per gene for each cell to metadata colData(sce)$log10GenesPerUMI &lt;- log10(colData(sce)$detected) / log10(colData(sce)$sum) # Visualize the overall novelty of the gene expression by visualizing the genes detected per UMI p &lt;- colData(sce) %&gt;% data.frame() %&gt;% ggplot(aes(x=log10GenesPerUMI, color = source_name, fill = source_name)) + geom_density() p tmpFn &lt;- sprintf(&quot;%s/%s/%s/novelty_dens.png&quot;, projDir, outDirBit, qcPlotDirBit) ggsave(plot=p, file=tmpFn) rm(sce) 5.14 QC based on sparsity The approach above identified poor-quality using thresholds on the number of genes detected and mitochondrial content. We will here specifically look at the sparsity of the data, both at the gene and cell levels. 5.14.1 Remove genes that are not expressed at all Genes that are not expressed at all are not informative, so we remove them: not.expressed &lt;- rowSums(counts(scePreQc)) == 0 # store the cell-wise information cols.meta &lt;- colData(scePreQc) rows.meta &lt;- rowData(scePreQc) nz.counts &lt;- counts(scePreQc)[!not.expressed, ] sce.nz &lt;- SingleCellExperiment(list(counts=nz.counts)) # reset the column data on the new object colData(sce.nz) &lt;- cols.meta rowData(sce.nz) &lt;- rows.meta[!not.expressed, ] sce.nz ## class: SingleCellExperiment ## dim: 25116 38128 ## metadata(0): ## assays(1): counts ## rownames(25116): ENSG00000238009 ENSG00000239945 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(10): ensembl_gene_id external_gene_name ... mean detected ## colnames: NULL ## colData names(14): Barcode Run ... discard outlier ## reducedDimNames(0): ## altExpNames(0): # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz.Rds&quot;, projDir, outDirBit) saveRDS(sce.nz, tmpFn) # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz.Rds&quot;, projDir, outDirBit) sce.nz &lt;- readRDS(tmpFn) 5.14.2 Sparsity plots We will compute: the cell sparsity: for each cell, the proportion of genes that are not detected the gene sparsity: for each gene, the proportion of cells in which it is not detected # compute - SLOW cell_sparsity &lt;- apply(counts(sce.nz) == 0, 2, sum)/nrow(counts(sce.nz)) gene_sparsity &lt;- apply(counts(sce.nz) == 0, 1, sum)/ncol(counts(sce.nz)) colData(sce.nz)$cell_sparsity &lt;- cell_sparsity rowData(sce.nz)$gene_sparsity &lt;- gene_sparsity # write outcome to file for later use tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_sparsityCellGene.Rds&quot;, projDir, outDirBit) saveRDS(list(&quot;colData&quot; = colData(sce.nz), &quot;rowData&quot; = rowData(sce.nz)), tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_sparsityCellGene.Rds&quot;, projDir, outDirBit) tmpList &lt;- readRDS(tmpFn) cell_sparsity &lt;- tmpList$colData$cell_sparsity gene_sparsity &lt;- tmpList$rowData$gene_sparsity We now plot the distribution of these two metrics. The cell sparsity plot shows that cells have between 85% and 99% 0’s, which is typical. hist(cell_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Cell sparsity&quot;, main=&quot;&quot;) The gene sparsity plot shows that a large number of genes are almost never detected, which is also regularly observed. hist(gene_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Gene sparsity&quot;, main=&quot;&quot;) 5.14.3 Filters We also remove cells with sparsity higher than 0.99, and/or mitochondrial content higher than 20%. Genes detected in a few cells only are unlikely to be informative and would hinder normalisation. We will remove genes that are expressed in fewer than 20 cells. # filter sparse.cells &lt;- cell_sparsity &gt; 0.99 mito.cells &lt;- sce.nz$subsets_Mito_percent &gt; 20 min.cells &lt;- 1 - (20/length(cell_sparsity)) sparse.genes &lt;- gene_sparsity &gt; min.cells Number of genes removed: table(sparse.genes) ## sparse.genes ## FALSE TRUE ## 17854 7262 Number of cells removed: table(sparse.cells, mito.cells) ## mito.cells ## sparse.cells FALSE TRUE ## FALSE 36871 671 ## TRUE 525 61 # remove cells from the SCE object that are poor quality # remove the sparse genes, then re-set the counts and row data accordingly cols.meta &lt;- colData(sce.nz) rows.meta &lt;- rowData(sce.nz) counts.nz &lt;- counts(sce.nz)[!sparse.genes, !(sparse.cells | mito.cells)] sce.nz &lt;- SingleCellExperiment(assays=list(counts=counts.nz)) colData(sce.nz) &lt;- cols.meta[!(sparse.cells | mito.cells),] rowData(sce.nz) &lt;- rows.meta[!sparse.genes, ] sce.nz ## class: SingleCellExperiment ## dim: 17854 36871 ## metadata(0): ## assays(1): counts ## rownames(17854): ENSG00000238009 ENSG00000237491 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(15): Barcode Run ... outlier cell_sparsity ## reducedDimNames(0): ## altExpNames(0): # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_postQc.Rds&quot;, projDir, outDirBit) saveRDS(sce.nz, tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/sce_nz_postQc.Rds&quot;, projDir, outDirBit) sce.nz &lt;- readRDS(tmpFn) Compare with filter above (mind that the comparison is not fair because we used a less stringent, hard filtering on mitochondrial content): table(scePreQc$discard, (sparse.cells | mito.cells)) ## ## FALSE TRUE ## FALSE 35351 334 ## TRUE 1520 923 rm(scePreQc) 5.14.4 Separate Caron and Hca batches We will now check sparsity for each batch separately. sce.nz.caron &lt;- sce.nz[,sce.nz$setName==&quot;Caron&quot;] sce.nz.hca &lt;- sce.nz[,sce.nz$setName==&quot;Hca&quot;] 5.14.5 Caron only setName &lt;- &quot;caron&quot; sce.x &lt;- sce.nz.caron rm(sce.nz.caron) # compute - SLOW cell_sparsity &lt;- apply(counts(sce.x) == 0, 2, sum)/nrow(counts(sce.x)) gene_sparsity &lt;- apply(counts(sce.x) == 0, 1, sum)/ncol(counts(sce.x)) colData(sce.x)$cell_sparsity &lt;- cell_sparsity rowData(sce.x)$gene_sparsity &lt;- gene_sparsity # write outcome to file for later use tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene.Rds&quot;, projDir, outDirBit, setName) saveRDS(list(&quot;colData&quot; = colData(sce.x), &quot;rowData&quot; = rowData(sce.x)), tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene.Rds&quot;, projDir, outDirBit, setName) tmpList &lt;- readRDS(tmpFn) cell_sparsity &lt;- tmpList$colData$cell_sparsity gene_sparsity &lt;- tmpList$rowData$gene_sparsity # plot tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sparsity.png&quot;, projDir, outDirBit, qcPlotDirBit, setName) png(tmpFn) par(mfrow=c(1, 2)) hist(cell_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Cell sparsity&quot;, main=&quot;&quot;) hist(gene_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Gene sparsity&quot;, main=&quot;&quot;) abline(v=40, lty=2, col=&#39;purple&#39;) dev.off() ## png ## 2 tmpFn &lt;- sprintf(&quot;../%s/%s_sparsity.png&quot;, qcPlotDirBit, setName) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) # filter sparse.cells &lt;- cell_sparsity &gt; 0.99 mito.cells &lt;- sce.x$subsets_Mito_percent &gt; 20 min.cells &lt;- 1 - (20/length(cell_sparsity)) sparse.genes &lt;- gene_sparsity &gt; min.cells We write the R object to ‘caron_sce_nz_postQc.Rds’. # remove cells from the SCE object that are poor quality # remove the sparse genes, then re-set the counts and row data accordingly cols.meta &lt;- colData(sce.x) rows.meta &lt;- rowData(sce.x) counts.x &lt;- counts(sce.x)[!sparse.genes, !(sparse.cells | mito.cells)] sce.x &lt;- SingleCellExperiment(assays=list(counts=counts.x)) colData(sce.x) &lt;- cols.meta[!(sparse.cells | mito.cells),] rowData(sce.x) &lt;- rows.meta[!sparse.genes, ] sce.x ## class: SingleCellExperiment ## dim: 16629 20908 ## metadata(0): ## assays(1): counts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(15): Barcode Run ... outlier cell_sparsity ## reducedDimNames(0): ## altExpNames(0): # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc.Rds&quot;, projDir, outDirBit, setName) saveRDS(sce.x, tmpFn) # update sce.nz.caron sce.nz.caron &lt;- sce.x # TODO not used rm(sce.x) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc.Rds&quot;, dirRel, outDirBit, setName) sce.nz.caron &lt;- readRDS(tmpFn) 5.14.6 Hca only setName &lt;- &quot;hca&quot; sce.x &lt;- sce.nz.hca rm(sce.nz.hca) # compute - SLOW cell_sparsity &lt;- apply(counts(sce.x) == 0, 2, sum)/nrow(counts(sce.x)) gene_sparsity &lt;- apply(counts(sce.x) == 0, 1, sum)/ncol(counts(sce.x)) colData(sce.x)$cell_sparsity &lt;- cell_sparsity rowData(sce.x)$gene_sparsity &lt;- gene_sparsity # write outcome to file for later use tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene.Rds&quot;, projDir, outDirBit, setName) saveRDS(list(&quot;colData&quot; = colData(sce.x), &quot;rowData&quot; = rowData(sce.x)), tmpFn) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_sparsityCellGene.Rds&quot;, projDir, outDirBit, setName) tmpList &lt;- readRDS(tmpFn) cell_sparsity &lt;- tmpList$colData$cell_sparsity gene_sparsity &lt;- tmpList$rowData$gene_sparsity # plot tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sparsity.png&quot;, projDir, outDirBit, qcPlotDirBit, setName) png(tmpFn) par(mfrow=c(1, 2)) hist(cell_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Cell sparsity&quot;, main=&quot;&quot;) hist(gene_sparsity, breaks=50, col=&quot;grey80&quot;, xlab=&quot;Gene sparsity&quot;, main=&quot;&quot;) abline(v=40, lty=2, col=&#39;purple&#39;) dev.off() ## png ## 2 tmpFn &lt;- sprintf(&quot;../%s/%s_sparsity.png&quot;, qcPlotDirBit, setName) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) # filter sparse.cells &lt;- cell_sparsity &gt; 0.99 mito.cells &lt;- sce.x$subsets_Mito_percent &gt; 20 min.cells &lt;- 1 - (20/length(cell_sparsity)) sparse.genes &lt;- gene_sparsity &gt; min.cells We write the R object to ‘hca_sce_nz_postQc.Rds’. # remove cells from the SCE object that are poor quality # remove the sparse genes, then re-set the counts and row data accordingly cols.meta &lt;- colData(sce.x) rows.meta &lt;- rowData(sce.x) counts.x &lt;- counts(sce.x)[!sparse.genes, !(sparse.cells | mito.cells)] sce.x &lt;- SingleCellExperiment(assays=list(counts=counts.x)) colData(sce.x) &lt;- cols.meta[!(sparse.cells | mito.cells),] rowData(sce.x) &lt;- rows.meta[!sparse.genes, ] sce.x ## class: SingleCellExperiment ## dim: 14994 15963 ## metadata(0): ## assays(1): counts ## rownames(14994): ENSG00000237491 ENSG00000225880 ... ENSG00000276345 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(15): Barcode Run ... outlier cell_sparsity ## reducedDimNames(0): ## altExpNames(0): # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc.Rds&quot;, projDir, outDirBit, setName) saveRDS(sce.x, tmpFn) # update sce.nz.hca sce.nz.hca &lt;- sce.x # TODO not used rm(sce.x) # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc.Rds&quot;, projDir, outDirBit, setName) sce.nz.hca &lt;- readRDS(tmpFn) # TODO not used 5.15 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 (Core) ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] robustbase_0.93-7 mixtools_1.2.0 ## [3] irlba_2.3.3 biomaRt_2.46.3 ## [5] Matrix_1.2-18 igraph_1.2.6 ## [7] DropletUtils_1.10.3 scater_1.18.6 ## [9] ggplot2_3.3.3 scran_1.18.7 ## [11] SingleCellExperiment_1.12.0 SummarizedExperiment_1.20.0 ## [13] Biobase_2.50.0 GenomicRanges_1.42.0 ## [15] GenomeInfoDb_1.26.7 IRanges_2.24.1 ## [17] S4Vectors_0.28.1 BiocGenerics_0.36.1 ## [19] MatrixGenerics_1.2.1 matrixStats_0.58.0 ## [21] dplyr_1.0.5 DT_0.18 ## [23] knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] BiocFileCache_1.14.0 splines_4.0.3 ## [3] BiocParallel_1.24.1 crosstalk_1.1.1 ## [5] digest_0.6.27 htmltools_0.5.1.1 ## [7] viridis_0.5.1 fansi_0.4.2 ## [9] magrittr_2.0.1 memoise_2.0.0 ## [11] limma_3.46.0 readr_1.4.0 ## [13] R.utils_2.10.1 askpass_1.1 ## [15] prettyunits_1.1.1 colorspace_2.0-0 ## [17] blob_1.2.1 rappdirs_0.3.1 ## [19] xfun_0.22 crayon_1.4.1 ## [21] RCurl_1.98-1.3 jsonlite_1.7.2 ## [23] survival_3.2-7 glue_1.4.2 ## [25] gtable_0.3.0 zlibbioc_1.36.0 ## [27] XVector_0.30.0 DelayedArray_0.16.3 ## [29] BiocSingular_1.6.0 kernlab_0.9-29 ## [31] Rhdf5lib_1.12.1 DEoptimR_1.0-8 ## [33] HDF5Array_1.18.1 scales_1.1.1 ## [35] DBI_1.1.1 edgeR_3.32.1 ## [37] miniUI_0.1.1.1 Rcpp_1.0.6 ## [39] isoband_0.2.4 xtable_1.8-4 ## [41] viridisLite_0.3.0 progress_1.2.2 ## [43] dqrng_0.2.1 bit_4.0.4 ## [45] rsvd_1.0.3 htmlwidgets_1.5.3 ## [47] httr_1.4.2 ellipsis_0.3.1 ## [49] pkgconfig_2.0.3 XML_3.99-0.5 ## [51] R.methodsS3_1.8.1 farver_2.1.0 ## [53] scuttle_1.0.4 sass_0.3.1 ## [55] dbplyr_2.0.0 locfit_1.5-9.4 ## [57] utf8_1.2.1 later_1.1.0.1 ## [59] tidyselect_1.1.0 labeling_0.4.2 ## [61] rlang_0.4.10 AnnotationDbi_1.52.0 ## [63] munsell_0.5.0 tools_4.0.3 ## [65] cachem_1.0.4 generics_0.1.0 ## [67] RSQLite_2.2.6 evaluate_0.14 ## [69] stringr_1.4.0 fastmap_1.1.0 ## [71] yaml_2.2.1 bit64_4.0.5 ## [73] purrr_0.3.4 nlme_3.1-149 ## [75] sparseMatrixStats_1.2.1 mime_0.10 ## [77] R.oo_1.24.0 ggExtra_0.9 ## [79] xml2_1.3.2 compiler_4.0.3 ## [81] rstudioapi_0.13 beeswarm_0.2.3 ## [83] curl_4.3 tibble_3.1.1 ## [85] statmod_1.4.35 bslib_0.2.4 ## [87] stringi_1.5.3 highr_0.8 ## [89] lattice_0.20-41 bluster_1.0.0 ## [91] vctrs_0.3.7 pillar_1.6.0 ## [93] lifecycle_1.0.0 rhdf5filters_1.2.0 ## [95] jquerylib_0.1.3 BiocNeighbors_1.8.2 ## [97] cowplot_1.1.1 bitops_1.0-6 ## [99] httpuv_1.5.5 R6_2.5.0 ## [101] promises_1.1.1 bookdown_0.21 ## [103] gridExtra_2.3 vipor_0.4.5 ## [105] codetools_0.2-16 MASS_7.3-53 ## [107] assertthat_0.2.1 rhdf5_2.34.0 ## [109] openssl_1.4.3 withr_2.4.2 ## [111] GenomeInfoDbData_1.2.4 mgcv_1.8-33 ## [113] hms_1.0.0 grid_4.0.3 ## [115] beachmat_2.6.4 rmarkdown_2.7 ## [117] DelayedMatrixStats_1.12.3 segmented_1.3-3 ## [119] shiny_1.5.0 ggbeeswarm_0.6.0 "],["NormalisationAllCells.html", "Chapter 6 Normalisation 6.1 Caron 6.2 Hca 6.3 SCTransform 6.4 Session information", " Chapter 6 Normalisation Why normalise? Systematic differences in sequencing coverage between libraries caused by low input material, differences in cDNA capture and PCR amplification. Normalisation removes such differences so that differences between cells are not technical but biological, allowing meaningful comparison of expression profiles between cells. TODO difference between normalisation and batch correction. norm: technical differences only. batch correction: technical and biological. different assumptions and methods. In scaling normalization, the “normalization factor” is an estimate of the library size relative to the other cells. steps: compute a cell-specific ‘scaling’ or ‘size’ factor that represents the relative bias in that cell and divide all counts for the cell by that factor to remove that bias. Assumption: any cell specific bias will affect genes the same way. Scaling methods typically generate normalised counts-per-million (CPM) or transcripts-per-million (TPM_ values. projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit compuBool &lt;- TRUE # whether to run computation again (dev) #qcPlotDirBit &lt;- &quot;Plots/Norm&quot; library(scuttle) library(scran) library(ggplot2) library(dplyr) 6.1 Caron Load object. setName &lt;- &quot;caron&quot; setSuf = &quot;_allCells&quot; # suffix to add to file name to say all cells are used, with no downsampling # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce &lt;- readRDS(tmpFn) 6.1.1 Library size normalization For each cell, the library size factor is proportional to the library size such that the average size factor across cell is one. Advantage: normalised counts are on the same scale as the initial counts. Compute size factors: lib.sf &lt;- librarySizeFactors(sce) summary(lib.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1205 0.4432 0.7308 1.0000 1.2859 14.4562 Size factor distribution: wide range, typical of scRNA-seq data. hist(log10(lib.sf), xlab=&quot;Log10[Size factor]&quot;, col=&#39;grey80&#39;) Assumption: absence of compositional bias; differential expression two cells is balanced: upregulation in some genes is accompanied by downregulation of other genes. Not observed. Inaccurate normalisation due to unaccounted-for composition bias affects the size of the log fold change measured between clusters, but less so the clustering itself. It is thus sufficient to identify clusters and top marker genes. 6.1.2 Deconvolution Composition bias occurs when differential expression beteween two samples or here cells is not balanced. For a fixed library size, identical in both cells, upregulation of one gene in the a cell will means fewer UMIs can be assigned to other genes, which would then appear down regulated. Even if library sizes are allowed to differ in size, with that for the cell with upregulation being higher, scaling normalisation will reduce noralised counts. Non-upregulated would therefore also appear downregulated. For bulk RNA-seq, composition bias is removed by assuming that most genes are not differentially expressed between samples, so that differences in non-DE genes would amount to the bias, and used to compute size factors. Given the sparsity of scRNA-seq data, the methods are not appropriate. The method below increases read counts by pooling cells into groups, computing size factors within each of these groups and scaling them so they are comparable across clusters. This process is repeated many times, changing pools each time to collect several size factors for each cell, frome which is derived a single value for that cell. Cluster cells, normalise : set.seed(100) # clusters with PCA from irlba with approximation clust &lt;- quickCluster(sce) # slow with all cells. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(clust, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) clust &lt;- readRDS(tmpFn) table(clust) ## clust ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 1557 5519 3149 602 2106 374 2389 1788 1378 4815 923 1846 5575 1989 108 1657 ## 17 18 19 20 21 22 23 24 25 ## 701 1882 5053 1420 278 714 802 1049 156 6.1.3 Compute size factors deconv.sf &lt;- calculateSumFactors(sce, cluster=clust) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(deconv.sf, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) deconv.sf &lt;- readRDS(tmpFn) summary(deconv.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.03169 0.41551 0.73178 1.00000 1.30221 15.27223 Plot size factors: plot(lib.sf, deconv.sf, xlab=&quot;Library size factor&quot;, ylab=&quot;Deconvolution size factor&quot;, log=&#39;xy&#39;, pch=16, col=as.integer(factor(sce$source_name))) abline(a=0, b=1, col=&quot;red&quot;) deconvDf &lt;- data.frame(lib.sf, deconv.sf, &quot;source_name&quot; = sce$source_name, &quot;sum&quot; = sce$sum, &quot;mito_content&quot; = sce$subsets_Mito_percent, &quot;cell_sparsity&quot; = sce$cell_sparsity) # colour by sample type sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=source_name)) + geom_point() sp + facet_wrap(~source_name) # colour by library size sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=sum)) + geom_point() sp # colour by mito. content sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=mito_content)) + geom_point() sp # colour by cell sparsity sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=cell_sparsity)) + geom_point() sp #ggMarginal(sp) 6.1.3.1 Apply size factors For each cell, raw counts for genes are divided by the size factor for that cell and log-transformed so downstream analyses focus on genes with strong relative differences. We use scater::logNormCounts(). sce &lt;- logNormCounts(sce) assayNames(sce) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.1.3.2 Save object sce_caron &lt;- sce # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce_caron, tmpFn) 6.2 Hca Load object. # the 5kCellPerSpl subset setName &lt;- &quot;hca&quot; setSuf &lt;- &quot;_5kCellPerSpl&quot; # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce &lt;- readRDS(tmpFn) 6.2.1 Library size normalization For each cell, the library size factor is proportioanl to the library size such that the average size factor across cell is one. Advantage: normalised counts are on the same scale as the initial counts. Compute size factors: lib.sf &lt;- librarySizeFactors(sce) summary(lib.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.3249 0.4916 0.6015 1.0000 0.8224 27.5849 Size factor distribution: wide range, typical of scRNA-seq data. hist(log10(lib.sf), xlab=&quot;Log10[Size factor]&quot;, col=&#39;grey80&#39;) Assumption: absence of compositional bias; differential expression two cells is balanced: upregulation in some genes is accompanied by downregulation of other genes. Not observed. Inaccurate normalisation due to unaccounted-for composition bias affects the size of the log fold change measured between clusters, but less so the clusterisation itself. It is thus sufficient to identify clustrs and top arker genes. 6.2.2 Deconvolution Composition bias occurs when differential expression beteween two samples or here cells is not balanced. For a fixed library size, identical in both cells, upregulation of one gene in the a cell will means fewer UMIs can be assigned to other genes, which would then appear down regulated. Even if library sizes are allowed to differ in size, with that for the cell with upregulation being higher, scaling normalisation will reduce noralised counts. Non-upregulated would therefore also appear downregulated. For bulk RNA-seq, composition bias is removed by assuming that most genes are not differentially expressed between samples, so that differences in non-DE genes would amount to the bias, and used to compute size factors. Given the sparsity of scRNA-seq data, the methods are not appropriate. The method below increases read counts by pooling cells into groups, computing size factors within each of these groups and scaling them so they are comparable across clusters. This process is repeated many times, changing pools each time to collect several size factors for each cell, frome which is derived a single value for that cell. Cluster cells then normalise : #library(scran) set.seed(100) # clusters with PCA from irlba with approximation clust &lt;- quickCluster(sce) # slow with all cells. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(clust, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) clust &lt;- readRDS(tmpFn) table(clust) ## clust ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 1444 577 807 2116 3106 497 3973 613 1693 731 3655 9970 3136 225 3221 517 ## 17 18 19 20 21 22 23 24 25 ## 486 568 868 219 252 416 315 283 312 6.2.3 Compute size factors deconv.sf &lt;- calculateSumFactors(sce, cluster=clust) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(deconv.sf, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) deconv.sf &lt;- readRDS(tmpFn) summary(deconv.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0896 0.4112 0.5071 1.0000 0.7585 38.5010 Plot size factors: plot(lib.sf, deconv.sf, xlab=&quot;Library size factor&quot;, ylab=&quot;Deconvolution size factor&quot;, log=&#39;xy&#39;, pch=16, col=as.integer(factor(sce$source_name))) abline(a=0, b=1, col=&quot;red&quot;) deconvDf &lt;- data.frame(lib.sf, deconv.sf, &quot;source_name&quot; = sce$source_name, &quot;sum&quot; = sce$sum, &quot;mito_content&quot; = sce$subsets_Mito_percent, &quot;cell_sparsity&quot; = sce$cell_sparsity) # colour by sample type sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=source_name)) + geom_point() sp + facet_wrap(~source_name) # colour by library size sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=sum)) + geom_point() sp # colour by mito. content sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=mito_content)) + geom_point() sp # colour by cell sparsity sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=cell_sparsity)) + geom_point() sp #ggMarginal(sp) 6.2.3.1 Apply size factors For each cell, raw counts for genes are divided by the size factor for that cell and log-transformed so downstream analyses focus on genes with strong relative differences. We use scater::logNormCounts(). sce &lt;- logNormCounts(sce) assayNames(sce) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.2.3.2 Save object sce_hca &lt;- sce # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce_hca, tmpFn) 6.3 SCTransform With scaling normalisation a correlation remains between the mean and variation of expression (heteroskedasticity). This affects downstream dimensionality reduction as the few main new dimensions are usually correlated with library size. SCTransform addresses the issue by regressing library size out of raw counts and providing residuals to use as normalized and variance-stabilized expression values in downstream analysis. 6.3.1 Caron setName &lt;- &quot;caron&quot; setSuf = &quot;_allCells&quot; # suffix to add to file name to say which cells are used, eg downsampling sce &lt;- sce_caron counts &lt;- counts(sce) class(counts) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; colnames(counts) &lt;- colData(sce)$Barcode Inspect data We will now calculate some properties and visually inspect the data. Our main interest is in the general trends not in individual outliers. Neither genes nor cells that stand out are important at this step, but we focus on the global trends. Derive gene and cell attributes from the UMI matrix. gene_attr &lt;- data.frame(mean = rowMeans(counts), detection_rate = rowMeans(counts &gt; 0), var = apply(counts, 1, var)) gene_attr$log_mean &lt;- log10(gene_attr$mean) gene_attr$log_var &lt;- log10(gene_attr$var) rownames(gene_attr) &lt;- rownames(counts) cell_attr &lt;- data.frame(n_umi = colSums(counts), n_gene = colSums(counts &gt; 0)) rownames(cell_attr) &lt;- colnames(counts) ggplot(gene_attr, aes(log_mean, log_var)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) + geom_abline(intercept = 0, slope = 1, color=&#39;red&#39;) Mean-variance relationship For the genes, we can see that up to a mean UMI count of ca. 0.1 the variance follows the line through the origin with slop one, i.e. variance and mean are roughly equal as expected under a Poisson model. However, genes with a higher average UMI count show overdispersion compared to Poisson. # add the expected detection rate under Poisson model x = seq(from = -3, to = 2, length.out = 1000) poisson_model &lt;- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x)) ggplot(gene_attr, aes(log_mean, detection_rate)) + geom_point(alpha=0.3, shape=16) + geom_line(data=poisson_model, color=&#39;red&#39;) + theme_gray(base_size = 8) Mean-detection-rate relationship In line with the previous plot, we see a lower than expected detection rate in the medium expression range. However, for the highly expressed genes, the rate is at or very close to 1.0 suggesting that there is no zero-inflation in the counts for those genes and that zero-inflation is a result of overdispersion, rather than an independent systematic bias. ggplot(cell_attr, aes(n_umi, n_gene)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) General idea of transformation Based on the observations above, which are not unique to this particular data set, we propose to model the expression of each gene as a negative binomial random variable with a mean that depends on other variables. Here the other variables can be used to model the differences in sequencing depth between cells and are used as independent variables in a regression model. In order to avoid overfitting, we will first fit model parameters per gene, and then use the relationship between gene mean and parameter values to fit parameters, thereby combining information across genes. Given the fitted model parameters, we transform each observed UMI count into a Pearson residual which can be interpreted as the number of standard deviations an observed count was away from the expected mean. If the model accurately describes the mean-variance relationship and the dependency of mean and latent factors, then the result should have mean zero and a stable variance across the range of expression. Estimate model parameters and transform data The vst function estimates model parameters and performs the variance stabilizing transformation. Here we use the log10 of the total UMI counts of a cell as variable for sequencing depth for each cell. After data transformation we plot the model parameters as a function of gene mean (geometric mean). # We use the Future API for parallel processing; set parameters here future::plan(strategy = &#39;multicore&#39;, workers = 4) options(future.globals.maxSize = 10 * 1024 ^ 3) set.seed(44) vst_out &lt;- sctransform::vst(counts, latent_var = c(&#39;log_umi&#39;), return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE) sctransform::plot_model_pars(vst_out) Inspect model We will look at several genes in more detail. rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;)) ## ensembl_gene_id external_gene_name chromosome_name ## ENSG00000147403 ENSG00000147403 RPL10 X ## ENSG00000251562 ENSG00000251562 MALAT1 11 ## ENSG00000087086 ENSG00000087086 FTL 19 ## start_position end_position strand Symbol Type ## ENSG00000147403 154389955 154409168 1 RPL10 Gene Expression ## ENSG00000251562 65497688 65506516 1 MALAT1 Gene Expression ## ENSG00000087086 48965309 48966879 1 FTL Gene Expression ## mean detected gene_sparsity ## ENSG00000147403 48.85548 99.28030 0.011540874 ## ENSG00000251562 193.05529 99.09786 0.005352289 ## ENSG00000087086 15.48621 96.42481 0.085532093 sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000251562&#39;, &#39;ENSG00000147403&#39;, &#39;ENSG00000087086&#39;), plot_residual = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE, arrange_vertical = FALSE) # Error in seq_len(n) : argument must be coercible to non-negative integer rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;GNLY&#39;, &#39;S100A9&#39;)) #sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000115523&#39;, &#39;ENSG00000163220&#39;), plot_residual = TRUE, show_nr = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000115523&#39;), plot_residual = TRUE, show_nr = TRUE) # ok # sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE) ggplot(vst_out$gene_attr, aes(residual_mean)) + geom_histogram(binwidth=0.01) ggplot(vst_out$gene_attr, aes(residual_variance)) + geom_histogram(binwidth=0.1) + geom_vline(xintercept=1, color=&#39;red&#39;) + xlim(0, 10) ggplot(vst_out$gene_attr, aes(x=residual_mean, y=residual_variance)) + geom_point(alpha=0.3, shape=16) + xlim(0, 2.5) + ylim(0, 10) + geom_density_2d() ggplot(vst_out$gene_attr, aes(log10(gmean), residual_variance)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) dd &lt;- vst_out$gene_attr %&gt;% arrange(-residual_variance) %&gt;% slice_head(n = 22) %&gt;% mutate(across(where(is.numeric), round, 2)) dd %&gt;% tibble::rownames_to_column(&quot;ensembl_gene_id&quot;) %&gt;% left_join(as.data.frame(rowData(sce))[,c(&quot;ensembl_gene_id&quot;, &quot;Symbol&quot;)], by = &quot;ensembl_gene_id&quot;) %&gt;% DT::datatable(rownames = FALSE) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_vst_out%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(vst_out, tmpFn) 6.3.2 Hca Load object. setName &lt;- &quot;hca&quot; setSuf &lt;- &quot;_5kCellPerSpl&quot; tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce_hca &lt;- readRDS(tmpFn) sce &lt;- sce_hca counts &lt;- counts(sce) class(counts) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; colnames(counts) &lt;- colData(sce)$Barcode Inspect data gene_attr &lt;- data.frame(mean = rowMeans(counts), detection_rate = rowMeans(counts &gt; 0), var = apply(counts, 1, var)) gene_attr$log_mean &lt;- log10(gene_attr$mean) gene_attr$log_var &lt;- log10(gene_attr$var) rownames(gene_attr) &lt;- rownames(counts) cell_attr &lt;- data.frame(n_umi = colSums(counts), n_gene = colSums(counts &gt; 0)) rownames(cell_attr) &lt;- colnames(counts) Mean-variance relationship # add the expected detection rate under Poisson model x = seq(from = -3, to = 2, length.out = 1000) poisson_model &lt;- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x)) ggplot(gene_attr, aes(log_mean, detection_rate)) + geom_point(alpha=0.3, shape=16) + geom_line(data=poisson_model, color=&#39;red&#39;) + theme_gray(base_size = 8) Mean-detection-rate relationship ggplot(cell_attr, aes(n_umi, n_gene)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) # We use the Future API for parallel processing; set parameters here future::plan(strategy = &#39;multicore&#39;, workers = 4) options(future.globals.maxSize = 10 * 1024 ^ 3) set.seed(44) vst_out &lt;- sctransform::vst(counts, latent_var = c(&#39;log_umi&#39;), return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE) sctransform::plot_model_pars(vst_out) Inspect model We will look at several genes in more detail. rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;)) ## ensembl_gene_id external_gene_name chromosome_name ## ENSG00000147403 ENSG00000147403 RPL10 X ## ENSG00000251562 ENSG00000251562 MALAT1 11 ## ENSG00000087086 ENSG00000087086 FTL 19 ## start_position end_position strand Symbol Type ## ENSG00000147403 154389955 154409168 1 RPL10 Gene Expression ## ENSG00000251562 65497688 65506516 1 MALAT1 Gene Expression ## ENSG00000087086 48965309 48966879 1 FTL Gene Expression ## mean detected gene_sparsity ## ENSG00000147403 48.85548 99.28030 0.007196991 ## ENSG00000251562 193.05529 99.09786 0.009021354 ## ENSG00000087086 15.48621 96.42481 0.035751887 sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000251562&#39;, &#39;ENSG00000147403&#39;, &#39;ENSG00000087086&#39;), plot_residual = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE, arrange_vertical = FALSE) ggplot(vst_out$gene_attr, aes(residual_mean)) + geom_histogram(binwidth=0.01) ggplot(vst_out$gene_attr, aes(residual_variance)) + geom_histogram(binwidth=0.1) + geom_vline(xintercept=1, color=&#39;red&#39;) + xlim(0, 10) ggplot(vst_out$gene_attr, aes(x=residual_mean, y=residual_variance)) + geom_point(alpha=0.3, shape=16) + xlim(0, 2.5) + ylim(0, 10) + geom_density_2d() ggplot(vst_out$gene_attr, aes(log10(gmean), residual_variance)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) #dd &lt;- head(round(vst_out$gene_attr[order(-vst_out$gene_attr$residual_variance), ], 2), 22) dd &lt;- vst_out$gene_attr %&gt;% arrange(-residual_variance) %&gt;% slice_head(n = 22) %&gt;% mutate(across(where(is.numeric), round, 2)) dd %&gt;% tibble::rownames_to_column(&quot;ensembl_gene_id&quot;) %&gt;% left_join(as.data.frame(rowData(sce))[,c(&quot;ensembl_gene_id&quot;, &quot;Symbol&quot;)], &quot;ensembl_gene_id&quot;) %&gt;% DT::datatable(rownames = FALSE) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_vst_out%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(vst_out, tmpFn) 6.4 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] scuttle_1.0.4 robustbase_0.93-7 ## [3] mixtools_1.2.0 irlba_2.3.3 ## [5] biomaRt_2.46.3 Matrix_1.2-18 ## [7] igraph_1.2.6 DropletUtils_1.10.3 ## [9] scater_1.18.6 ggplot2_3.3.3 ## [11] scran_1.18.7 SingleCellExperiment_1.12.0 ## [13] SummarizedExperiment_1.20.0 Biobase_2.50.0 ## [15] GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [17] IRanges_2.24.1 S4Vectors_0.28.1 ## [19] BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [21] matrixStats_0.58.0 dplyr_1.0.5 ## [23] DT_0.18 knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] BiocFileCache_1.14.0 plyr_1.8.6 ## [3] splines_4.0.3 listenv_0.8.0 ## [5] BiocParallel_1.24.1 crosstalk_1.1.1 ## [7] digest_0.6.27 htmltools_0.5.1.1 ## [9] viridis_0.5.1 fansi_0.4.2 ## [11] magrittr_2.0.1 memoise_2.0.0 ## [13] limma_3.46.0 globals_0.14.0 ## [15] readr_1.4.0 R.utils_2.10.1 ## [17] askpass_1.1 prettyunits_1.1.1 ## [19] colorspace_2.0-0 blob_1.2.1 ## [21] rappdirs_0.3.1 xfun_0.22 ## [23] crayon_1.4.1 RCurl_1.98-1.3 ## [25] jsonlite_1.7.2 survival_3.2-7 ## [27] glue_1.4.2 gtable_0.3.0 ## [29] zlibbioc_1.36.0 XVector_0.30.0 ## [31] DelayedArray_0.16.3 BiocSingular_1.6.0 ## [33] kernlab_0.9-29 Rhdf5lib_1.12.1 ## [35] future.apply_1.7.0 DEoptimR_1.0-8 ## [37] HDF5Array_1.18.1 scales_1.1.1 ## [39] DBI_1.1.1 edgeR_3.32.1 ## [41] miniUI_0.1.1.1 Rcpp_1.0.6 ## [43] isoband_0.2.4 xtable_1.8-4 ## [45] viridisLite_0.3.0 progress_1.2.2 ## [47] dqrng_0.2.1 bit_4.0.4 ## [49] rsvd_1.0.3 htmlwidgets_1.5.3 ## [51] httr_1.4.2 ellipsis_0.3.1 ## [53] pkgconfig_2.0.3 XML_3.99-0.5 ## [55] R.methodsS3_1.8.1 farver_2.1.0 ## [57] sass_0.3.1 dbplyr_2.0.0 ## [59] locfit_1.5-9.4 utf8_1.2.1 ## [61] reshape2_1.4.4 later_1.1.0.1 ## [63] tidyselect_1.1.0 labeling_0.4.2 ## [65] rlang_0.4.10 AnnotationDbi_1.52.0 ## [67] munsell_0.5.0 tools_4.0.3 ## [69] cachem_1.0.4 generics_0.1.0 ## [71] RSQLite_2.2.6 evaluate_0.14 ## [73] stringr_1.4.0 fastmap_1.1.0 ## [75] yaml_2.2.1 bit64_4.0.5 ## [77] purrr_0.3.4 future_1.21.0 ## [79] nlme_3.1-149 sparseMatrixStats_1.2.1 ## [81] mime_0.10 R.oo_1.24.0 ## [83] ggExtra_0.9 xml2_1.3.2 ## [85] compiler_4.0.3 rstudioapi_0.13 ## [87] beeswarm_0.2.3 curl_4.3 ## [89] tibble_3.1.1 statmod_1.4.35 ## [91] bslib_0.2.4 stringi_1.5.3 ## [93] highr_0.8 lattice_0.20-41 ## [95] bluster_1.0.0 vctrs_0.3.7 ## [97] pillar_1.6.0 lifecycle_1.0.0 ## [99] rhdf5filters_1.2.0 jquerylib_0.1.3 ## [101] BiocNeighbors_1.8.2 cowplot_1.1.1 ## [103] bitops_1.0-6 httpuv_1.5.5 ## [105] R6_2.5.0 promises_1.1.1 ## [107] bookdown_0.21 gridExtra_2.3 ## [109] parallelly_1.24.0 vipor_0.4.5 ## [111] codetools_0.2-16 MASS_7.3-53 ## [113] assertthat_0.2.1 rhdf5_2.34.0 ## [115] openssl_1.4.3 withr_2.4.2 ## [117] sctransform_0.3.2.9005 GenomeInfoDbData_1.2.4 ## [119] mgcv_1.8-33 hms_1.0.0 ## [121] grid_4.0.3 beachmat_2.6.4 ## [123] rmarkdown_2.7 DelayedMatrixStats_1.12.3 ## [125] segmented_1.3-3 shiny_1.5.0 ## [127] ggbeeswarm_0.6.0 #qcPlotDirBit &lt;- &quot;NormPlots&quot; #setNameUpp &lt;- &quot;Caron&quot; projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit cacheBool &lt;- params$cacheBool library(knitr) #src &lt;- lapply(c(&quot;Caron&quot;, &quot;Hca&quot;), function(setNameUpp) knit_expand(file = &quot;test.Rmd&quot;)) src &lt;- lapply(c(&quot;Caron&quot;), function(setNameUpp) knit_expand(file = &quot;normalisation_5hCellPerSpl.Rmd&quot;)) ## src &lt;- lapply(c(&quot;Caron&quot;), function(setNameUpp) knit_expand(file = &quot;normalisation_GSM3872434.Rmd&quot;)) "],["normalisation-caron-set.html", "Chapter 7 Normalisation - Caron set 7.1 Scaling normalization 7.2 SCTransform 7.3 Visualisation 7.4 Session information", " Chapter 7 Normalisation - Caron set Sources: chapters on Normalisation in the OSCA book and the ’Hemberg group material. Why normalise? Systematic differences in sequencing coverage between libraries occur because of low input material, differences in cDNA capture and PCR amplification. Normalisation removes such differences so that differences between cells are not technical but biological, allowing meaningful comparison of expression profiles between cells. Normalisation and batch correction have different aims. Normalisation addresses technical differences only, while batch correction considers both technical and biological differences. qcPlotDirBit &lt;- &quot;Plots/Norm&quot; setName &lt;- tolower(&quot;Caron&quot;) projDir &lt;- params$projDir dirRel &lt;- params$dirRel if(params$bookType == &quot;mk&quot;){dirRel &lt;- &quot;..&quot;} outDirBit &lt;- params$outDirBit writeRds &lt;- FALSE Load object. setSuf &lt;- &quot;&quot; if(setName == &quot;hca&quot;) {setSuf &lt;- &quot;_5kCellPerSpl&quot;} # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) print(tmpFn) ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/caron_sce_nz_postQc.Rds&quot; if(!file.exists(tmpFn)) { knitr::knit_exit() } sce &lt;- readRDS(tmpFn) sce ## class: SingleCellExperiment ## dim: 16629 20908 ## metadata(0): ## assays(1): counts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(15): Barcode Run ... outlier cell_sparsity ## reducedDimNames(0): ## altExpNames(0): Subsample cells down to 500 per sample setSuf &lt;- &quot;_5hCellPerSpl&quot; nbCells &lt;- 500 #setSuf &lt;- &quot;_1kCellPerSpl&quot; #nbCells &lt;- 1000 #setSuf &lt;- &quot;_GSM3872434&quot; ##nbCells &lt;- 500 # have new list of cell barcodes for each sample sce.nz.master &lt;- sce vec.bc &lt;- colData(sce.nz.master) %&gt;% data.frame() %&gt;% filter(!Run == &quot;SRR9264351&quot;) %&gt;% group_by(Sample.Name) %&gt;% sample_n(nbCells) %&gt;% pull(Barcode) table(colData(sce.nz.master)$Barcode %in% vec.bc) ## ## FALSE TRUE ## 15408 5500 tmpInd &lt;- which(colData(sce.nz.master)$Barcode %in% vec.bc) sce &lt;- sce.nz.master[,tmpInd] We write the R object to ‘caron_sce_nz_postQc_5hCellPerSpl.Rds’. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce, tmpFn) # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce &lt;- readRDS(tmpFn) 7.1 Scaling normalization In scaling normalization, the “normalization factor” is an estimate of the library size relative to the other cells. Steps usually include: computation of a cell-specific ‘scaling’ or ‘size’ factor that represents the relative bias in that cell and division of all counts for the cell by that factor to remove that bias. Assumption: any cell specific bias will affect genes the same way. Scaling methods typically generate normalised counts-per-million (CPM) or transcripts-per-million (TPM) values that address the effect of sequencing depth. These values however typically have a variance that increases with their mean (heteroscedasticity) while most statistical methods assume a stable variance, which does not vary with the mean (homoscedasticity). A widely used ‘variance stabilising transformation’ is the log transformation (often log2). This works fine for highly expressed genes (as in bulk RNA-seq) but less so for sparse scRNA-seq data. 7.1.1 CPM Convert raw counts to counts-per-million (CPM) for each cell by dividing counts by the library size then multiplying by 1.000.000. Mind that this does not adress compositional bias caused by highly expressed genes that are also differentially expressed betwenn cells. In scater CPMs are computed with the following code: calc_cpm &lt;- function (expr_mat, spikes = NULL) { norm_factor &lt;- colSums(expr_mat[-spikes, ]) return(t(t(expr_mat)/norm_factor)) * 10^6 } We will use scater’s calculateCPM() 7.1.2 DESeq’s size factor For each gene, compute geometric mean across cells. for each cell compute for each gene the ratio of its expression to its geometric mean, and derive the cell’s size factor as the median ratio across genes. Not suitable for sparse scRNA-seq data as the geometric is computed on non-zero values only. This method is also known as ‘Relative Log Expression’ (RLE) in edgeR and scater. Example code: calc_sf &lt;- function (expr_mat, spikes = NULL) { geomeans &lt;- exp(rowMeans(log(expr_mat[-spikes, ]))) SF &lt;- function(cnts) { median((cnts/geomeans)[(is.finite(geomeans) &amp; geomeans &gt; 0)]) } norm_factor &lt;- apply(expr_mat[-spikes, ], 2, SF) return(t(t(expr_mat)/norm_factor)) } 7.1.3 Weighted Trimmed mean of M-values To compute weighted Trimmed mean of M-values (TMM), a given cell is chosen as a reference to use in computation for other cells. The M-values are gene-wise log2-fold changes between cells. Trimming entails the removal of the top and bottom 30% of values. The size factor is computed as the average for the remaining cells with a weight according to inverse variances. This method assumes that most genes are not differentially expressed, and the 40% lof genes left after trimming may include many zero counts. sizeFactors(sce) &lt;- edgeR::calcNormFactors(counts(sce), method = &quot;TMM&quot;) 7.1.4 Library size normalization For each cell, the library size factor is proportional to the library size such that the average size factor across cell is one. Advantage: normalised counts are on the same scale as the initial counts. Compute size factors: lib.sf &lt;- librarySizeFactors(sce) summary(lib.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1233 0.4223 0.7386 1.0000 1.3334 7.9364 Size factor distribution: wide range, typical of scRNA-seq data. hist(log10(lib.sf), xlab=&quot;Log10[Size factor]&quot;, col=&#39;grey80&#39;) Assumption: absence of compositional bias; differential expression two cells is balanced: upregulation in some genes is accompanied by downregulation of other genes. Not observed. Inaccurate normalisation due to unaccounted-for composition bias affects the size of the log fold change measured between clusters, but less so the clustering itself. It is thus sufficient to identify clusters and top marker genes. 7.1.5 Deconvolution Composition bias occurs when differential expression beteween two samples or here cells is not balanced. For a fixed library size, identical in both cells, upregulation of one gene in the a cell will means fewer UMIs can be assigned to other genes, which would then appear down regulated. Even if library sizes are allowed to differ in size, with that for the cell with upregulation being higher, scaling normalisation will reduce noralised counts. Non-upregulated would therefore also appear downregulated. For bulk RNA-seq, composition bias is removed by assuming that most genes are not differentially expressed between samples, so that differences in non-DE genes would amount to the bias, and used to compute size factors. Given the sparsity of scRNA-seq data, the methods are not appropriate. The method below increases read counts by pooling cells into groups, computing size factors within each of these groups and scaling them so they are comparable across clusters. This process is repeated many times, changing pools each time to collect several size factors for each cell, frome which is derived a single value for that cell. Cluster cells then normalise. 7.1.5.1 Cluster cells set.seed(100) # clusters with PCA from irlba with approximation clust &lt;- quickCluster(sce) # slow with all cells. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(clust, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) clust &lt;- readRDS(tmpFn) table(clust) ## clust ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## 144 226 904 345 428 431 504 197 553 151 238 202 280 189 139 161 134 172 102 7.1.5.2 Compute size factors #deconv.sf &lt;- calculateSumFactors(sce, cluster=clust) sce &lt;- computeSumFactors(sce, cluster=clust, min.mean=0.1) deconv.sf &lt;- sizeFactors(sce) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(deconv.sf, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) deconv.sf &lt;- readRDS(tmpFn) summary(deconv.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.04128 0.38453 0.72555 1.00000 1.33783 7.70338 Plot size factors: plot(lib.sf, deconv.sf, xlab=&quot;Library size factor&quot;, ylab=&quot;Deconvolution size factor&quot;, log=&#39;xy&#39;, pch=16, col=as.integer(factor(sce$source_name))) abline(a=0, b=1, col=&quot;red&quot;) deconvDf &lt;- data.frame(lib.sf, deconv.sf, &quot;source_name&quot; = sce$source_name, &quot;sum&quot; = sce$sum, &quot;mito_content&quot; = sce$subsets_Mito_percent, &quot;cell_sparsity&quot; = sce$cell_sparsity) # colour by sample type sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=source_name)) + geom_point() sp + facet_wrap(~source_name) # colour by library size sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=sum)) + geom_point() sp # colour by mito. content sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=mito_content)) + geom_point() sp # colour by cell sparsity sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=cell_sparsity)) + geom_point() sp 7.1.5.3 Apply size factors For each cell, raw counts for genes are divided by the size factor for that cell and log-transformed so downstream analyses focus on genes with strong relative differences. We use scater::logNormCounts(). sce &lt;- logNormCounts(sce) # adds logcounts print(assayNames(sce)) ## [1] &quot;counts&quot; &quot;logcounts&quot; 7.1.5.4 Save object sceDeconv &lt;- sce # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sceDeconv, tmpFn) 7.2 SCTransform With scaling normalisation a correlation remains between the mean and variation of expression (heteroskedasticity). This affects downstream dimensionality reduction as the few main new dimensions are usually correlated with library size. SCTransform addresses the issue by regressing library size out of raw counts and providing residuals to use as normalized and variance-stabilized expression values in downstream analysis. counts &lt;- counts(sce) print(class(counts)) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; print(dim(counts)) ## [1] 16629 5500 colnames(counts) &lt;- colData(sce)$Barcode 7.2.1 Inspect data We will now calculate some properties and visually inspect the data. Our main interest is in the general trends not in individual outliers. Neither genes nor cells that stand out are important at this step, but we focus on the global trends. Derive gene and cell attributes from the UMI matrix. gene_attr &lt;- data.frame(mean = rowMeans(counts), detection_rate = rowMeans(counts &gt; 0), var = apply(counts, 1, var)) gene_attr$log_mean &lt;- log10(gene_attr$mean) gene_attr$log_var &lt;- log10(gene_attr$var) rownames(gene_attr) &lt;- rownames(counts) cell_attr &lt;- data.frame(n_umi = colSums(counts), n_gene = colSums(counts &gt; 0)) rownames(cell_attr) &lt;- colnames(counts) dim(gene_attr) ## [1] 16629 5 head(gene_attr) ## mean detection_rate var log_mean log_var ## ENSG00000237491 0.018181818 0.018181818 0.017854486 -1.7403627 -1.7482526 ## ENSG00000225880 0.013818182 0.013636364 0.013993420 -1.8595491 -1.8540761 ## ENSG00000230368 0.018909091 0.018727273 0.018918613 -1.7233294 -1.7231107 ## ENSG00000230699 0.002363636 0.002363636 0.002358478 -2.6264193 -2.6273681 ## ENSG00000188976 0.188363636 0.164000000 0.208920762 -0.7250029 -0.6800184 ## ENSG00000187961 0.004909091 0.004545455 0.005613285 -2.3089989 -2.2507829 dim(cell_attr) ## [1] 5500 2 head(cell_attr) ## n_umi n_gene ## GTCCTCAGTCCAAGTT-1 573 331 ## ACACCCTAGCTCCCAG-1 4370 1513 ## ACTTTCACACCACCAG-1 3110 1107 ## ACGCCAGAGGCCCTCA-1 5094 1815 ## ATCCACCTCATCGATG-1 8990 2732 ## CCTATTACAAGCGATG-1 6614 2313 Mean-variance relationship For the genes, we can see that up to a mean UMI count of ca. 0.1 the variance follows the line through the origin with slop one, i.e. variance and mean are roughly equal as expected under a Poisson model. However, genes with a higher average UMI count show overdispersion compared to Poisson. ggplot(gene_attr, aes(log_mean, log_var)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) + geom_abline(intercept = 0, slope = 1, color=&#39;red&#39;) Mean-detection-rate relationship In line with the previous plot, we see a lower than expected detection rate in the medium expression range. However, for the highly expressed genes, the rate is at or very close to 1.0 suggesting that there is no zero-inflation in the counts for those genes and that zero-inflation is a result of overdispersion, rather than an independent systematic bias. # add the expected detection rate under Poisson model x = seq(from = -3, to = 2, length.out = 1000) poisson_model &lt;- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x)) ggplot(gene_attr, aes(log_mean, detection_rate)) + geom_point(alpha=0.3, shape=16) + geom_line(data=poisson_model, color=&#39;red&#39;) + theme_gray(base_size = 8) ggplot(cell_attr, aes(n_umi, n_gene)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) 7.2.2 Transformation Based on the observations above, which are not unique to this particular data set, we propose to model the expression of each gene as a negative binomial random variable with a mean that depends on other variables. Here the other variables can be used to model the differences in sequencing depth between cells and are used as independent variables in a regression model. In order to avoid overfitting, we will first fit model parameters per gene, and then use the relationship between gene mean and parameter values to fit parameters, thereby combining information across genes. Given the fitted model parameters, we transform each observed UMI count into a Pearson residual which can be interpreted as the number of standard deviations an observed count was away from the expected mean. If the model accurately describes the mean-variance relationship and the dependency of mean and latent factors, then the result should have mean zero and a stable variance across the range of expression. Estimate model parameters and transform data The vst function estimates model parameters and performs the variance stabilizing transformation. Here we use the log10 of the total UMI counts of a cell as variable for sequencing depth for each cell. After data transformation we plot the model parameters as a function of gene mean (geometric mean). print(dim(counts)) ## [1] 16629 5500 # We use the Future API for parallel processing; set parameters here future::plan(strategy = &#39;multicore&#39;, workers = 4) options(future.globals.maxSize = 10 * 1024 ^ 3) set.seed(44) vst_out &lt;- sctransform::vst(counts, latent_var = c(&#39;log_umi&#39;), return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE) sctransform::plot_model_pars(vst_out) Inspect model print(vst_out$model_str) ## [1] &quot;y ~ log_umi&quot; We will look at several genes in more detail. rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;)) ## ensembl_gene_id external_gene_name chromosome_name ## ENSG00000147403 ENSG00000147403 RPL10 X ## ENSG00000251562 ENSG00000251562 MALAT1 11 ## ENSG00000087086 ENSG00000087086 FTL 19 ## start_position end_position strand Symbol Type ## ENSG00000147403 154389955 154409168 1 RPL10 Gene Expression ## ENSG00000251562 65497688 65506516 1 MALAT1 Gene Expression ## ENSG00000087086 48965309 48966879 1 FTL Gene Expression ## mean detected gene_sparsity ## ENSG00000147403 44.29776 98.41586 0.01085709 ## ENSG00000251562 168.70211 98.86173 0.00607423 ## ENSG00000087086 11.38505 92.88974 0.09063516 sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000251562&#39;, &#39;ENSG00000147403&#39;, &#39;ENSG00000087086&#39;), plot_residual = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE, arrange_vertical = FALSE) Distribution of residual mean: ggplot(vst_out$gene_attr, aes(residual_mean)) + geom_histogram(binwidth=0.01) Distribution of residual variance: ggplot(vst_out$gene_attr, aes(residual_variance)) + geom_histogram(binwidth=0.1) + geom_vline(xintercept=1, color=&#39;red&#39;) + xlim(0, 10) Variance against mean (residuals): ggplot(vst_out$gene_attr, aes(x=residual_mean, y=residual_variance)) + geom_point(alpha=0.3, shape=16) + xlim(0, 2.5) + ylim(0, 10) + geom_density_2d() Variance against mean (genes): ggplot(vst_out$gene_attr, aes(log10(gmean), residual_variance)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) Variance against mean (residuals): dd &lt;- vst_out$gene_attr %&gt;% arrange(-residual_variance) %&gt;% slice_head(n = 22) %&gt;% mutate(across(where(is.numeric), round, 2)) dd %&gt;% tibble::rownames_to_column(&quot;ensembl_gene_id&quot;) %&gt;% left_join(as.data.frame(rowData(sce))[,c(&quot;ensembl_gene_id&quot;, &quot;Symbol&quot;)], &quot;ensembl_gene_id&quot;) %&gt;% DT::datatable(rownames = FALSE) Write outcome to file. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_vst_out%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(vst_out, tmpFn) Check transformed values: print(dim(vst_out$y)) ## [1] 16353 5500 vst_out$y[1:10,1:5] ## GTCCTCAGTCCAAGTT-1 ACACCCTAGCTCCCAG-1 ACTTTCACACCACCAG-1 ## ENSG00000237491 -0.05609117 6.74247881 -0.11724281 ## ENSG00000225880 -0.05010427 -0.11721874 -0.10206077 ## ENSG00000230368 -0.05696297 -0.13783109 -0.11937957 ## ENSG00000230699 -0.02265068 -0.04848545 -0.04274449 ## ENSG00000188976 -0.17050940 -0.42416056 -0.36719193 ## ENSG00000187961 -0.03121753 -0.06988428 -0.06123475 ## ENSG00000272512 -0.02108042 -0.04455552 -0.03935650 ## ENSG00000188290 -0.14604143 -0.36522703 -0.31538220 ## ENSG00000187608 -0.27407056 -0.64324432 -0.56711490 ## ENSG00000188157 -0.03246537 -0.07295948 -0.06389654 ## ACGCCAGAGGCCCTCA-1 ATCCACCTCATCGATG-1 ## ENSG00000237491 -0.14418312 -0.18129692 ## ENSG00000225880 -0.12466224 -0.15567896 ## ENSG00000230368 6.12170744 -0.18486895 ## ENSG00000230699 -0.05130377 -0.06312019 ## ENSG00000188976 -0.45181507 -0.56374272 ## ENSG00000187961 -0.07412736 -0.09183209 ## ENSG00000272512 -0.04710584 -0.05779140 ## ENSG00000188290 -0.38960850 -0.48980229 ## ENSG00000187608 -0.67855403 -0.81010185 ## ENSG00000188157 -0.07740485 -0.09594379 sce ## class: SingleCellExperiment ## dim: 16629 5500 ## metadata(0): ## assays(2): counts logcounts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): print(assayNames(sce)) ## [1] &quot;counts&quot; &quot;logcounts&quot; # assay(sce, &quot;sctrans_norm&quot;) &lt;- vst_out$y Genes that are expressed in fewer than 5 cells are not used and not returned, so to add vst_out$y as an assay we need to remove the missing genes. # genes that are expressed in fewer than 5 cells are not used and not returned # so to add vst_out$y as an assay we need to ditch the missing genes completely. # https://github.com/ChristophH/sctransform/issues/27 #rownames(vst_out$y) sceOrig &lt;- sce sceOrig ## class: SingleCellExperiment ## dim: 16629 5500 ## metadata(0): ## assays(2): counts logcounts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): tmpInd &lt;- which(rownames(sce) %in% rownames(vst_out$y)) cols.meta &lt;- colData(sceOrig) rows.meta &lt;- rowData(sceOrig) new.counts &lt;- counts(sceOrig)[tmpInd, ] sce &lt;- SingleCellExperiment(list(counts=new.counts)) # reset the column data on the new object colData(sce) &lt;- cols.meta rowData(sce) &lt;- rows.meta[tmpInd, ] if(FALSE) # dev { # logcounts_raw assayX &lt;- &quot;logcounts_raw&quot; tmpAssay &lt;- assay(sceOrig, assayX) assay(sce, assayX) &lt;- tmpAssay[tmpInd, ] # logCpm # logcounts for (assayX in c(&quot;logCpm&quot;, &quot;logcounts&quot;)) { tmpAssay &lt;- assay(sceOrig, assayX) assay(sce, assayX) &lt;- tmpAssay[tmpInd, ] } rm(assayX, tmpAssay) } assayNames(sce) ## [1] &quot;counts&quot; sce ## class: SingleCellExperiment ## dim: 16353 5500 ## metadata(0): ## assays(1): counts ## rownames(16353): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): vstMat &lt;- as(vst_out$y[rownames(sce),], &quot;dgCMatrix&quot;) all(colnames(vstMat) == sce$Barcode) ## [1] TRUE colnames(vstMat) &lt;- NULL assay(sce, &quot;sctrans_norm&quot;) &lt;- vstMat # as(vst_out$y[rownames(sce),], &quot;dgCMatrix&quot;) assayNames(sce) ## [1] &quot;counts&quot; &quot;sctrans_norm&quot; 7.2.3 Save SCE object # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postSct%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce, tmpFn) 7.3 Visualisation 7.3.1 log raw counts typeNorm &lt;- &quot;logRaw&quot; #setSuf &lt;- &quot;_5kCellPerSpl&quot; options(BiocSingularParam.default=IrlbaParam()) assay(sce, &quot;logcounts_raw&quot;) &lt;- log2(counts(sce) + 1) tmp &lt;- runPCA( sce[,], exprs_values = &quot;logcounts_raw&quot; ) PCA plot for the ‘logRaw’ counts in the caron set. p &lt;- plotPCA( tmp, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Cell-wise RLE for the ‘logRaw’ counts in the caron set. Each cell is represented by a box plot showing the inter-quartile range in grey, wiskers colour-coded by Sample.Name and the median as a black circle. p &lt;- plotRLE( #tmp[,1:10], tmp, exprs_values = &quot;logcounts_raw&quot;, colour_by = &quot;Sample.Name&quot; ) + ggtitle(sprintf(&quot;RLE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 7.3.2 log CPM typeNorm &lt;- &quot;logCpm&quot; assay(sce, &quot;logCpm&quot;) &lt;- log2(calculateCPM(sce, size_factors = NULL) + 1) logCpmPca &lt;- runPCA( sce[,], exprs_values = &quot;logCpm&quot; ) PCA plot for the ‘logCpm’ counts in the caron set. p &lt;- plotPCA( logCpmPca, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Cell-wise RLE for the ‘logCpm’ counts in the caron set. p &lt;- plotRLE( sce, exprs_values = &quot;logCpm&quot;, colour_by = &quot;Sample.Name&quot; ) + ggtitle(sprintf(&quot;RLE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 7.3.3 scran Normalised counts are stored in ‘logcounts’ assay typeNorm &lt;- &quot;scran&quot; # assay(sce, &quot;logcounts&quot;) scranPca &lt;- runPCA( sceDeconv[,], exprs_values = &quot;logcounts&quot; ) PCA plot for the ‘scran’ counts in the caron set. p &lt;- plotPCA( scranPca, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) TSNE plot for the ‘scran’ counts in the caron set. typeNorm &lt;- &quot;scran&quot; reducedDim(sceDeconv, &quot;TSNE_scran&quot;) &lt;- reducedDim( runTSNE(sceDeconv, exprs_values = &quot;logcounts&quot;), &quot;TSNE&quot; ) p &lt;- plotReducedDim( sceDeconv, dimred = &quot;TSNE_scran&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;TSNE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) UMAP plot for the ‘scran’ counts in the caron set. typeNorm &lt;- &quot;scran&quot; reducedDim(sceDeconv, &quot;UMAP_scran&quot;) &lt;- reducedDim( runUMAP(sceDeconv, exprs_values = &quot;logcounts&quot;), &quot;UMAP&quot; ) p &lt;- plotReducedDim( sceDeconv, dimred = &quot;UMAP_scran&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;UMAP plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sUmap.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sUmap.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Cell-wise RLE for the ‘scran’ counts in the caron set. p &lt;- plotRLE( scranPca, exprs_values = &quot;logcounts&quot;, colour_by = &quot;Sample.Name&quot; ) + ggtitle(sprintf(&quot;RLE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 7.3.4 SCTransform typeNorm &lt;- &quot;sctrans&quot; reducedDim(sce, &quot;PCA_sctrans_norm&quot;) &lt;- reducedDim( runPCA(sce, exprs_values = &quot;sctrans_norm&quot;), &quot;PCA&quot; ) PCA plot for the ‘sctrans’ counts in the caron set. p &lt;- plotReducedDim( sce, dimred = &quot;PCA_sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) TSNE plot for the ‘sctrans’ counts in the caron set. typeNorm &lt;- &quot;sctrans&quot; reducedDim(sce, &quot;TSNE_sctrans_norm&quot;) &lt;- reducedDim( runTSNE(sce, exprs_values = &quot;sctrans_norm&quot;), &quot;TSNE&quot; ) p &lt;- plotReducedDim( sce, dimred = &quot;TSNE_sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;TSNE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) UMAP plot for the ‘sctrans’ counts in the caron set. typeNorm &lt;- &quot;sctrans&quot; reducedDim(sce, &quot;UMAP_sctrans_norm&quot;) &lt;- reducedDim( runUMAP(sce, exprs_values = &quot;sctrans_norm&quot;), &quot;UMAP&quot; ) p &lt;- plotReducedDim( sce, dimred = &quot;UMAP_sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;UMAP plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sUmap.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sUmap.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Cell-wise RLE for the ‘sctrans’ counts in the caron set. p &lt;- plotRLE( sce, exprs_values = &quot;sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot; ) + ggtitle(sprintf(&quot;RLE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, projDir, outDirBit, qcPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, dirRel, qcPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 7.4 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] ggfortify_0.4.11 BiocSingular_1.6.0 ## [3] scuttle_1.0.4 robustbase_0.93-7 ## [5] mixtools_1.2.0 dplyr_1.0.5 ## [7] DT_0.18 irlba_2.3.3 ## [9] biomaRt_2.46.3 Matrix_1.2-18 ## [11] igraph_1.2.6 DropletUtils_1.10.3 ## [13] scater_1.18.6 ggplot2_3.3.3 ## [15] scran_1.18.7 SingleCellExperiment_1.12.0 ## [17] SummarizedExperiment_1.20.0 Biobase_2.50.0 ## [19] GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [21] IRanges_2.24.1 S4Vectors_0.28.1 ## [23] BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [25] matrixStats_0.58.0 knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] ggbeeswarm_0.6.0 colorspace_2.0-0 ## [3] ellipsis_0.3.1 bluster_1.0.0 ## [5] XVector_0.30.0 BiocNeighbors_1.8.2 ## [7] rstudioapi_0.13 bit64_4.0.5 ## [9] AnnotationDbi_1.52.0 fansi_0.4.2 ## [11] xml2_1.3.2 splines_4.0.3 ## [13] R.methodsS3_1.8.1 sparseMatrixStats_1.2.1 ## [15] cachem_1.0.4 jsonlite_1.7.2 ## [17] kernlab_0.9-29 dbplyr_2.0.0 ## [19] R.oo_1.24.0 HDF5Array_1.18.1 ## [21] readr_1.4.0 compiler_4.0.3 ## [23] httr_1.4.2 dqrng_0.2.1 ## [25] assertthat_0.2.1 fastmap_1.1.0 ## [27] limma_3.46.0 htmltools_0.5.1.1 ## [29] prettyunits_1.1.1 tools_4.0.3 ## [31] rsvd_1.0.3 gtable_0.3.0 ## [33] glue_1.4.2 GenomeInfoDbData_1.2.4 ## [35] rappdirs_0.3.1 Rcpp_1.0.6 ## [37] jquerylib_0.1.3 vctrs_0.3.7 ## [39] rhdf5filters_1.2.0 DelayedMatrixStats_1.12.3 ## [41] xfun_0.22 stringr_1.4.0 ## [43] beachmat_2.6.4 lifecycle_1.0.0 ## [45] statmod_1.4.35 XML_3.99-0.5 ## [47] DEoptimR_1.0-8 edgeR_3.32.1 ## [49] MASS_7.3-53 zlibbioc_1.36.0 ## [51] scales_1.1.1 hms_1.0.0 ## [53] rhdf5_2.34.0 curl_4.3 ## [55] yaml_2.2.1 memoise_2.0.0 ## [57] gridExtra_2.3 sass_0.3.1 ## [59] segmented_1.3-3 stringi_1.5.3 ## [61] RSQLite_2.2.6 BiocParallel_1.24.1 ## [63] rlang_0.4.10 pkgconfig_2.0.3 ## [65] bitops_1.0-6 evaluate_0.14 ## [67] lattice_0.20-41 purrr_0.3.4 ## [69] Rhdf5lib_1.12.1 htmlwidgets_1.5.3 ## [71] bit_4.0.4 tidyselect_1.1.0 ## [73] magrittr_2.0.1 bookdown_0.21 ## [75] R6_2.5.0 generics_0.1.0 ## [77] DelayedArray_0.16.3 DBI_1.1.1 ## [79] pillar_1.6.0 withr_2.4.2 ## [81] survival_3.2-7 RCurl_1.98-1.3 ## [83] tibble_3.1.1 crayon_1.4.1 ## [85] utf8_1.2.1 BiocFileCache_1.14.0 ## [87] rmarkdown_2.7 viridis_0.5.1 ## [89] progress_1.2.2 locfit_1.5-9.4 ## [91] grid_4.0.3 blob_1.2.1 ## [93] digest_0.6.27 tidyr_1.1.3 ## [95] R.utils_2.10.1 openssl_1.4.3 ## [97] munsell_0.5.0 beeswarm_0.2.3 ## [99] viridisLite_0.3.0 vipor_0.4.5 ## [101] bslib_0.2.4 askpass_1.1 "],["normalisation-gsm3872434-set.html", "Chapter 8 Normalisation - GSM3872434 set 8.1 Scaling normalization 8.2 SCTransform 8.3 Visualisation 8.4 Session information", " Chapter 8 Normalisation - GSM3872434 set Sources: chapters on normalisation in the OSCA book and the ‘Hemberg group material’. Why normalise? Systematic differences in sequencing coverage between libraries occur because of low input material, differences in cDNA capture and PCR amplification. Normalisation removes such differences so that differences between cells are not technical but biological, allowing meaningful comparison of expression profiles between cells. Normalisation and batch correction have different aims. Normalisation addresses technical differences only, while batch correction considers both technical and biological differences. normPlotDirBit &lt;- &quot;Plots/Norm&quot; projDir &lt;- params$projDir dirRel &lt;- params$dirRel if(params$bookType == &quot;mk&quot;) { setName &lt;- &quot;GSM3872434&quot; setSuf &lt;- &quot;_allCells&quot; dirRel &lt;- &quot;..&quot; } outDirBit &lt;- params$outDirBit dir.create(sprintf(&quot;%s/%s/%s&quot;, projDir, outDirBit, normPlotDirBit), showWarnings = FALSE) Load object # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, &quot;caron&quot;, setSuf) if(!file.exists(tmpFn)) { knitr::knit_exit() } sce &lt;- readRDS(tmpFn) sce ## class: SingleCellExperiment ## dim: 18431 47830 ## metadata(0): ## assays(1): counts ## rownames(18431): ENSG00000238009 ENSG00000237491 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Sample Barcode ... outlier cell_sparsity ## reducedDimNames(0): ## altExpNames(0): Select cells for GSM3872434: ##setSuf &lt;- &quot;_5hCellPerSpl&quot; ##nbCells &lt;- 500 #setSuf &lt;- &quot;_1kCellPerSpl&quot; #nbCells &lt;- 1000 setSuf &lt;- &quot;_GSM3872434&quot; ##nbCells &lt;- 500 # have new list of cell barcodes for each sample sce.nz.master &lt;- sce vec.bc &lt;- colData(sce.nz.master) %&gt;% data.frame() %&gt;% filter(Sample.Name == &quot;GSM3872434&quot;) %&gt;% group_by(Sample.Name) %&gt;% ##sample_n(nbCells) %&gt;% pull(Barcode) Number of cells in the sample: table(colData(sce.nz.master)$Barcode %in% vec.bc) ## ## FALSE TRUE ## 44977 2853 Subset cells from the SCE object: tmpInd &lt;- which(colData(sce.nz.master)$Barcode %in% vec.bc) sce &lt;- sce.nz.master[,tmpInd] sce ## class: SingleCellExperiment ## dim: 18431 2853 ## metadata(0): ## assays(1): counts ## rownames(18431): ENSG00000238009 ENSG00000237491 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Sample Barcode ... outlier cell_sparsity ## reducedDimNames(0): ## altExpNames(0): Check columns data: head(colData(sce)) ## DataFrame with 6 rows and 16 columns ## Sample Barcode Run Sample.Name source_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;factor&gt; ## 1 /ssd/personal/baller.. AAACCTGAGACTTTCG-1 SRR9264343 GSM3872434 ETV6-RUNX1 ## 2 /ssd/personal/baller.. AAACCTGGTCTTCAAG-1 SRR9264343 GSM3872434 ETV6-RUNX1 ## 3 /ssd/personal/baller.. AAACCTGGTGTTGAGG-1 SRR9264343 GSM3872434 ETV6-RUNX1 ## 4 /ssd/personal/baller.. AAACCTGTCCCAAGTA-1 SRR9264343 GSM3872434 ETV6-RUNX1 ## 5 /ssd/personal/baller.. AAACCTGTCGAATGCT-1 SRR9264343 GSM3872434 ETV6-RUNX1 ## 6 /ssd/personal/baller.. AAACGGGCACCATCCT-1 SRR9264343 GSM3872434 ETV6-RUNX1 ## sum detected subsets_Mito_sum subsets_Mito_detected ## &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt; ## 1 6462 1996 290 12 ## 2 11706 3079 567 12 ## 3 7981 2511 423 12 ## 4 8354 2307 519 13 ## 5 1373 701 91 11 ## 6 2142 985 102 10 ## subsets_Mito_percent total block setName discard outlier ## &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; &lt;character&gt; &lt;logical&gt; &lt;logical&gt; ## 1 4.48777 6462 ETV6-RUNX1 Caron FALSE FALSE ## 2 4.84367 11706 ETV6-RUNX1 Caron FALSE FALSE ## 3 5.30009 7981 ETV6-RUNX1 Caron FALSE FALSE ## 4 6.21259 8354 ETV6-RUNX1 Caron FALSE FALSE ## 5 6.62782 1373 ETV6-RUNX1 Caron FALSE FALSE ## 6 4.76190 2142 ETV6-RUNX1 Caron FALSE FALSE ## cell_sparsity ## &lt;numeric&gt; ## 1 0.907503 ## 2 0.857361 ## 3 0.883637 ## 4 0.893091 ## 5 0.967515 ## 6 0.954400 table(colData(sce)$Sample.Name) ## ## GSM3872434 ## 2853 We write the R object to GSM3872434_sce_nz_postQc_GSM3872434.Rds. # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce, tmpFn) # Write object to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce &lt;- readRDS(tmpFn) 8.1 Scaling normalization In scaling normalization, the “normalization factor” is an estimate of the library size relative to the other cells. Steps usually include: computation of a cell-specific ‘scaling’ or ‘size’ factor that represents the relative bias in that cell and division of all counts for the cell by that factor to remove that bias. Assumption: any cell specific bias will affect genes the same way. Scaling methods typically generate normalised counts-per-million (CPM) or transcripts-per-million (TPM) values that address the effect of sequencing depth. These values however typically have a variance that changes with their mean (heteroscedasticity) while most statistical methods assume a stable variance, which does not vary with the mean (homoscedasticity). A widely used ‘variance stabilising transformation’ is the log transformation (often log2). This works fine for highly expressed genes (as in bulk RNA-seq) but less so for sparse scRNA-seq data. 8.1.1 CPM Convert raw counts to counts-per-million (CPM) for each cell by dividing counts by the library size then multiplying by 1.000.000. Mind that this does not adress compositional bias caused by highly expressed genes that are also differentially expressed between cells. In scater CPMs are computed with the following code: calc_cpm &lt;- function (expr_mat, spikes = NULL) { norm_factor &lt;- colSums(expr_mat[-spikes, ]) return(t(t(expr_mat)/norm_factor)) * 10^6 } We will use scater’s calculateCPM(). 8.1.2 DESeq’s size factor For each gene, compute geometric mean across cells. For each cell compute for each gene the ratio of its expression to its geometric mean, and derive the cell’s size factor as the median ratio across genes. Not suitable for sparse scRNA-seq data as the geometric is computed on non-zero values only. This method is also known as ‘Relative Log Expression’ (RLE) in edgeR and scater. Example code: calc_sf &lt;- function (expr_mat, spikes = NULL) { geomeans &lt;- exp(rowMeans(log(expr_mat[-spikes, ]))) SF &lt;- function(cnts) { median((cnts/geomeans)[(is.finite(geomeans) &amp; geomeans &gt; 0)]) } norm_factor &lt;- apply(expr_mat[-spikes, ], 2, SF) return(t(t(expr_mat)/norm_factor)) } 8.1.3 Weighted Trimmed mean of M-values To compute weighted Trimmed mean of M-values (TMM), a given cell is chosen as a reference to use in computation for other cells. The M-values are gene-wise log2-fold changes between cells. Trimming entails the removal of the top and bottom 30% of values. The size factor is computed as the average for the remaining cells with a weight according to inverse variances. This method assumes that most genes are not differentially expressed, and the 40% of genes left after trimming may include many zero counts. sizeFactors(sce) &lt;- edgeR::calcNormFactors(counts(sce), method = &quot;TMM&quot;) 8.1.4 Library size factor distribution For each cell, the library size factor is proportional to the library size such that the average size factor across cells is one. Advantage: normalised counts are on the same scale as the initial counts. Compute size factors: lib.sf &lt;- librarySizeFactors(sce) summary(lib.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.09666 0.66197 0.92591 1.00000 1.23957 5.49973 Size factor distribution: wide range, typical of scRNA-seq data. hist(log10(lib.sf), xlab=&quot;Log10[Size factor]&quot;, col=&#39;grey80&#39;) Assumption: absence of compositional bias; differential expression between two cells is balanced: upregulation in some genes is accompanied by downregulation of other genes. Not observed. Inaccurate normalisation due to unaccounted-for composition bias affects the size of the log fold change measured between clusters, but less so the clustering itself. It is thus sufficient to identify clusters and top marker genes. 8.1.5 Deconvolution Composition bias occurs when differential expression beteween two samples or here cells is not balanced. For a fixed library size, identical in both cells, upregulation of one gene in a cell will means fewer UMIs can be assigned to other genes, which would then appear down regulated. Even if library sizes are allowed to differ, with that for the cell with upregulation being higher, scaling normalisation will reduce normalised counts. Non-upregulated would therefore also appear downregulated. For bulk RNA-seq, composition bias is removed by assuming that most genes are not differentially expressed between samples, so that differences in non-DE genes would amount to the bias, and used to compute size factors. Given the sparsity of scRNA-seq data, the methods are not appropriate. The method below increases read counts by pooling cells into groups, computing size factors within each of these groups and scaling them so they are comparable across clusters. This process is repeated many times, changing pools each time to collect several size factors for each cell, from which is derived a single value for that cell. tmpFn &lt;- sprintf(&quot;%s/Images/scran_Fig3.png&quot;, &quot;..&quot;) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Cluster cells then normalise. 8.1.5.1 Cluster cells set.seed(100) # clusters with PCA from irlba with approximation clust &lt;- quickCluster(sce) # slow with all cells. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(clust, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) clust &lt;- readRDS(tmpFn) table(clust) ## clust ## 1 2 3 4 5 6 7 8 9 ## 232 193 617 315 407 380 398 189 122 8.1.5.2 Compute size factors #deconv.sf &lt;- calculateSumFactors(sce, cluster=clust) sce &lt;- computeSumFactors(sce, cluster=clust, min.mean=0.1) deconv.sf &lt;- sizeFactors(sce) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(deconv.sf, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) deconv.sf &lt;- readRDS(tmpFn) summary(deconv.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.08207 0.67672 0.91982 1.00000 1.22628 4.06014 Plot deconvolution size factors against library size factors: deconvDf &lt;- data.frame(lib.sf, deconv.sf, &quot;source_name&quot; = sce$source_name, &quot;sum&quot; = sce$sum, &quot;mito_content&quot; = sce$subsets_Mito_percent, &quot;cell_sparsity&quot; = sce$cell_sparsity) sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=source_name)) + geom_point() # Split by sample type: #sp + facet_wrap(~source_name) sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=cell_sparsity)) + geom_point() sp 8.1.5.3 Apply size factors For each cell, raw counts for genes are divided by the size factor for that cell and log-transformed so downstream analyses focus on genes with strong relative differences. We use scater::logNormCounts(). sce &lt;- logNormCounts(sce) # adds logcounts print(assayNames(sce)) ## [1] &quot;counts&quot; &quot;logcounts&quot; 8.1.5.4 Save object # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce, tmpFn) sceDeconv &lt;- sce 8.2 SCTransform With scaling normalisation a correlation remains between the mean and variation of expression (heteroskedasticity). This affects downstream dimensionality reduction as the few main new dimensions are usually correlated with library size. SCTransform addresses the issue by regressing library size out of raw counts and providing residuals to use as normalized and variance-stabilized expression values in downstream analysis. We will use the sctransform vignette. counts &lt;- counts(sce) print(class(counts)) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; print(dim(counts)) ## [1] 18431 2853 colnames(counts) &lt;- colData(sce)$Barcode 8.2.1 Inspect data We will now calculate some properties and visually inspect the data. Our main interest is in the general trends not in individual outliers. Neither genes nor cells that stand out are important at this step, but we focus on the global trends. Derive gene and cell attributes from the UMI matrix. gene_attr &lt;- data.frame(mean = rowMeans(counts), detection_rate = rowMeans(counts &gt; 0), var = apply(counts, 1, var)) gene_attr$log_mean &lt;- log10(gene_attr$mean) gene_attr$log_var &lt;- log10(gene_attr$var) rownames(gene_attr) &lt;- rownames(counts) cell_attr &lt;- data.frame(n_umi = colSums(counts), n_gene = colSums(counts &gt; 0)) rownames(cell_attr) &lt;- colnames(counts) dim(gene_attr) ## [1] 18431 5 head(gene_attr) ## mean detection_rate var log_mean log_var ## ENSG00000238009 0.0007010165 0.0007010165 0.0007007707 -3.1542718 -3.1544241 ## ENSG00000237491 0.0364528566 0.0357518402 0.0365388860 -1.4382684 -1.4372447 ## ENSG00000225880 0.0318962496 0.0304942166 0.0336947550 -1.4962604 -1.4724377 ## ENSG00000230368 0.0140203295 0.0136698212 0.0145298692 -1.8532418 -1.8377383 ## ENSG00000230699 0.0021030494 0.0021030494 0.0020993624 -2.6771505 -2.6779126 ## ENSG00000188976 0.2958289520 0.2509638977 0.3065639427 -0.5289593 -0.5134789 dim(cell_attr) ## [1] 2853 2 head(cell_attr) ## n_umi n_gene ## AAACCTGAGACTTTCG-1 6462 1996 ## AAACCTGGTCTTCAAG-1 11705 3078 ## AAACCTGGTGTTGAGG-1 7981 2511 ## AAACCTGTCCCAAGTA-1 8354 2307 ## AAACCTGTCGAATGCT-1 1373 701 ## AAACGGGCACCATCCT-1 2141 984 Mean-variance relationship For the genes, we can see that up to a mean UMI count of 0 the variance follows the line through the origin with slop one, i.e. variance and mean are roughly equal as expected under a Poisson model. However, genes with a higher average UMI count show overdispersion compared to Poisson. ggplot(gene_attr, aes(log_mean, log_var)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) + geom_abline(intercept = 0, slope = 1, color=&#39;red&#39;) Mean-detection-rate relationship In line with the previous plot, we see a lower than expected detection rate in the medium expression range. However, for the highly expressed genes, the rate is at or very close to 1.0 suggesting that there is no zero-inflation in the counts for those genes and that zero-inflation is a result of overdispersion, rather than an independent systematic bias. # add the expected detection rate under Poisson model x = seq(from = -3, to = 2, length.out = 1000) poisson_model &lt;- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x)) ggplot(gene_attr, aes(log_mean, detection_rate)) + geom_point(alpha=0.3, shape=16) + geom_line(data=poisson_model, color=&#39;red&#39;) + theme_gray(base_size = 8) 8.2.2 Transformation “Based on the observations above, which are not unique to this particular data set, we propose to model the expression of each gene as a negative binomial random variable with a mean that depends on other variables. Here the other variables can be used to model the differences in sequencing depth between cells and are used as independent variables in a regression model. In order to avoid overfitting, we will first fit model parameters per gene, and then use the relationship between gene mean and parameter values to fit parameters, thereby combining information across genes. Given the fitted model parameters, we transform each observed UMI count into a Pearson residual which can be interpreted as the number of standard deviations an observed count was away from the expected mean. If the model accurately describes the mean-variance relationship and the dependency of mean and latent factors, then the result should have mean zero and a stable variance across the range of expression.” sctransform vignette. Estimate model parameters and transform data The vst function estimates model parameters and performs the variance stabilizing transformation. Here we use the log10 of the total UMI counts of a cell as variable for sequencing depth for each cell. After data transformation we plot the model parameters as a function of gene mean (geometric mean). print(dim(counts)) ## [1] 18431 2853 # We use the Future API for parallel processing; set parameters here future::plan(strategy = &#39;multicore&#39;, workers = 4) options(future.globals.maxSize = 10 * 1024 ^ 3) set.seed(44) vst_out &lt;- sctransform::vst(counts, latent_var = c(&#39;log_umi&#39;), return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE) sctransform::plot_model_pars(vst_out) Inspect model: print(vst_out$model_str) ## [1] &quot;y ~ log_umi&quot; We will look at several genes in more detail. #sctransform::plot_model(vst_out, counts, c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;), plot_residual = TRUE) rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;)) ## ensembl_gene_id external_gene_name chromosome_name ## ENSG00000147403 ENSG00000147403 RPL10 X ## ENSG00000251562 ENSG00000251562 MALAT1 11 ## ENSG00000087086 ENSG00000087086 FTL 19 ## start_position end_position strand Symbol Type ## ENSG00000147403 154389955 154409168 1 RPL10 Gene Expression ## ENSG00000251562 65497688 65506516 1 MALAT1 Gene Expression ## ENSG00000087086 48965309 48966879 1 FTL Gene Expression ## mean detected gene_sparsity ## ENSG00000147403 48.85548 99.28030 0.011540874 ## ENSG00000251562 193.05529 99.09786 0.005352289 ## ENSG00000087086 15.48621 96.42481 0.085532093 sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000251562&#39;, &#39;ENSG00000147403&#39;, &#39;ENSG00000087086&#39;), plot_residual = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE, arrange_vertical = FALSE) Distribution of residual mean: ggplot(vst_out$gene_attr, aes(residual_mean)) + geom_histogram(binwidth=0.01) Distribution of residual variance: ggplot(vst_out$gene_attr, aes(residual_variance)) + geom_histogram(binwidth=0.1) + geom_vline(xintercept=1, color=&#39;red&#39;) + xlim(0, 10) Variance against mean (residuals): ggplot(vst_out$gene_attr, aes(x=residual_mean, y=residual_variance)) + geom_point(alpha=0.3, shape=16) + xlim(0, 2.5) + ylim(0, 10) + geom_density_2d() Variance against mean (genes): ggplot(vst_out$gene_attr, aes(log10(gmean), residual_variance)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) Check genes with large residual variance: dd &lt;- vst_out$gene_attr %&gt;% arrange(-residual_variance) %&gt;% slice_head(n = 22) %&gt;% mutate(across(where(is.numeric), round, 2)) dd %&gt;% tibble::rownames_to_column(&quot;ensembl_gene_id&quot;) %&gt;% left_join(as.data.frame(rowData(sce))[,c(&quot;ensembl_gene_id&quot;, &quot;Symbol&quot;)], &quot;ensembl_gene_id&quot;) ## ensembl_gene_id detection_rate gmean variance residual_mean ## 1 ENSG00000197061 0.72 2.04 534.32 1.90 ## 2 ENSG00000175063 0.21 0.36 26.18 0.68 ## 3 ENSG00000164104 0.66 1.74 120.31 1.06 ## 4 ENSG00000100097 0.06 0.07 3.85 0.31 ## 5 ENSG00000008517 0.01 0.02 0.87 0.20 ## 6 ENSG00000123416 0.91 5.22 447.36 1.07 ## 7 ENSG00000211679 0.08 0.09 1.46 0.30 ## 8 ENSG00000102970 0.03 0.03 2.22 0.15 ## 9 ENSG00000170540 0.54 0.86 38.67 0.47 ## 10 ENSG00000164611 0.21 0.31 12.05 0.41 ## 11 ENSG00000128322 0.33 0.61 11.86 0.69 ## 12 ENSG00000244734 0.45 0.49 85356.97 0.15 ## 13 ENSG00000188536 0.16 0.15 8088.98 0.11 ## 14 ENSG00000206172 0.12 0.11 4995.50 0.09 ## 15 ENSG00000271503 0.02 0.02 0.41 0.12 ## 16 ENSG00000131747 0.16 0.27 7.92 0.34 ## 17 ENSG00000187837 0.67 1.53 21.13 0.78 ## 18 ENSG00000026025 0.69 1.92 58.23 0.73 ## 19 ENSG00000115523 0.00 0.01 0.24 0.06 ## 20 ENSG00000145649 0.00 0.01 0.06 0.08 ## 21 ENSG00000158578 0.01 0.01 1.67 0.06 ## 22 ENSG00000117399 0.11 0.16 4.07 0.25 ## residual_variance Symbol ## 1 65.39 HIST1H4C ## 2 20.67 UBE2C ## 3 16.78 HMGB2 ## 4 16.15 LGALS1 ## 5 15.36 IL32 ## 6 13.55 TUBA1B ## 7 12.64 IGLC3 ## 8 10.97 CCL17 ## 9 10.80 ARL6IP1 ## 10 10.77 PTTG1 ## 11 10.17 IGLL1 ## 12 9.95 HBB ## 13 9.83 HBA2 ## 14 9.75 HBA1 ## 15 9.02 CCL5 ## 16 8.63 TOP2A ## 17 8.44 HIST1H1C ## 18 8.42 VIM ## 19 7.85 GNLY ## 20 7.79 GZMA ## 21 7.78 ALAS2 ## 22 7.53 CDC20 Write outcome to file: # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_vst_out%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(vst_out, tmpFn) Check transformed values. print(dim(vst_out$y)) ## [1] 14214 2853 vst_out$y[1:10,1:5] ## AAACCTGAGACTTTCG-1 AAACCTGGTCTTCAAG-1 AAACCTGGTGTTGAGG-1 ## ENSG00000237491 -0.20121617 -0.25944999 -0.22046915 ## ENSG00000225880 -0.18668543 -0.24052717 -0.20448848 ## ENSG00000230368 -0.12439501 -0.16164785 -0.13667117 ## ENSG00000230699 -0.04842402 -0.06042004 -0.05240396 ## ENSG00000188976 1.03374030 1.56177764 0.80159808 ## ENSG00000187961 -0.05363629 -0.06698983 -0.05806420 ## ENSG00000188290 -0.09174430 -0.12027862 -0.10110587 ## ENSG00000187608 2.45936165 -0.77304781 -0.65435652 ## ENSG00000188157 -0.07078407 -0.09039073 -0.07724886 ## ENSG00000131591 -0.16874897 -0.21715523 -0.18475767 ## AAACCTGTCCCAAGTA-1 AAACCTGTCGAATGCT-1 ## ENSG00000237491 -0.22484005 -0.10084504 ## ENSG00000225880 -0.20852982 -0.09378858 ## ENSG00000230368 -0.13946384 -0.06115474 ## ENSG00000230699 -0.05330481 -0.02694137 ## ENSG00000188976 0.75303608 -0.27198451 ## ENSG00000187961 -0.05906678 -0.02977692 ## ENSG00000188290 -0.10324123 -0.04420393 ## ENSG00000187608 -0.66778017 -0.28420778 ## ENSG00000188157 -0.07871818 -0.03690960 ## ENSG00000131591 -0.18839118 -0.08509713 Genes that are expressed in fewer than 5 cells are not used and not returned, so to add vst_out$y as an assay we need to remove the missing genes. # https://github.com/ChristophH/sctransform/issues/27 sceOrig &lt;- sce sceOrig ## class: SingleCellExperiment ## dim: 18431 2853 ## metadata(0): ## assays(2): counts logcounts ## rownames(18431): ENSG00000238009 ENSG00000237491 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(17): Sample Barcode ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): tmpInd &lt;- which(rownames(sce) %in% rownames(vst_out$y)) cols.meta &lt;- colData(sceOrig) rows.meta &lt;- rowData(sceOrig) new.counts &lt;- counts(sceOrig)[tmpInd, ] sce &lt;- SingleCellExperiment(list(counts=new.counts)) # reset the column data on the new object colData(sce) &lt;- cols.meta rowData(sce) &lt;- rows.meta[tmpInd, ] assayNames(sce) ## [1] &quot;counts&quot; sce ## class: SingleCellExperiment ## dim: 14214 2853 ## metadata(0): ## assays(1): counts ## rownames(14214): ENSG00000237491 ENSG00000225880 ... ENSG00000278817 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(17): Sample Barcode ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): vstMat &lt;- as(vst_out$y[rownames(sce),], &quot;dgCMatrix&quot;) all(colnames(vstMat) == sce$Barcode) ## [1] TRUE colnames(vstMat) &lt;- NULL assay(sce, &quot;sctrans_norm&quot;) &lt;- vstMat # as(vst_out$y[rownames(sce),], &quot;dgCMatrix&quot;) #assayNames(sce) 8.2.3 Save SCE object # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postSct%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce, tmpFn) 8.3 Visualisation 8.3.1 log raw counts typeNorm &lt;- &quot;logRaw&quot; #setSuf &lt;- &quot;_5kCellPerSpl&quot; options(BiocSingularParam.default=IrlbaParam()) assay(sce, &quot;logcounts_raw&quot;) &lt;- log2(counts(sce) + 1) tmp &lt;- runPCA( sce[,], exprs_values = &quot;logcounts_raw&quot; ) PCA plot for the logRaw counts in the GSM3872434 set. p &lt;- plotPCA( tmp, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 8.3.2 log CPM typeNorm &lt;- &quot;logCpm&quot; assay(sce, &quot;logCpm&quot;) &lt;- log2(calculateCPM(sce, size_factors = NULL) + 1) logCpmPca &lt;- runPCA( sce[,], exprs_values = &quot;logCpm&quot; ) PCA plot for the logCpm counts in the GSM3872434 set. p &lt;- plotPCA( logCpmPca, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 8.3.3 scran Normalised counts are stored in the ‘logcounts’ assay typeNorm &lt;- &quot;scran&quot; # assay(sce, &quot;logcounts&quot;) scranPca &lt;- runPCA( sceDeconv[,], exprs_values = &quot;logcounts&quot; ) PCA plot for the ‘scran’ counts in the GSM3872434 set. p &lt;- plotPCA( scranPca, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) TSNE plot for the ‘scran’ counts in the GSM3872434 set. typeNorm &lt;- &quot;scran&quot; reducedDim(sceDeconv, &quot;TSNE_scran&quot;) &lt;- reducedDim( runTSNE(sceDeconv, exprs_values = &quot;logcounts&quot;), &quot;TSNE&quot; ) p &lt;- plotReducedDim( sceDeconv, dimred = &quot;TSNE_scran&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;TSNE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 8.3.4 SCTransform typeNorm &lt;- &quot;sctrans&quot; reducedDim(sce, &quot;PCA_sctrans_norm&quot;) &lt;- reducedDim( runPCA(sce, exprs_values = &quot;sctrans_norm&quot;), &quot;PCA&quot; ) PCA plot for the ‘sctrans’ counts in the GSM3872434 set. p &lt;- plotReducedDim( sce, dimred = &quot;PCA_sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;PCA plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) TSNE plot for the sctrans counts in the GSM3872434 set. typeNorm &lt;- &quot;sctrans&quot; reducedDim(sce, &quot;TSNE_sctrans_norm&quot;) &lt;- reducedDim( runTSNE(sce, exprs_values = &quot;sctrans_norm&quot;), &quot;TSNE&quot; ) p &lt;- plotReducedDim( sce, dimred = &quot;TSNE_sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) + ggtitle(sprintf(&quot;TSNE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sTsne.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) Cell-wise RLE for the sctrans counts in the GSM3872434 set. p &lt;- plotRLE( sce, exprs_values = &quot;sctrans_norm&quot;, colour_by = &quot;Sample.Name&quot; ) + ggtitle(sprintf(&quot;RLE plot: %s&quot;, typeNorm)) # write plot to file: tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) print(&quot;DEV&quot;); print(getwd()); print(tmpFn) ## [1] &quot;DEV&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/ScriptsMkWiC&quot; ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Plots/Norm/GSM3872434_sce_nz_postQc_GSM3872434_sctransRle.png&quot; ##ggsave(filename=tmpFn, plot=p) tmpFn &lt;- sprintf(&quot;%s/%s/%s_sce_nz_postQc%s_%sRle.png&quot;, dirRel, normPlotDirBit, setName, setSuf, typeNorm) knitr::include_graphics(tmpFn, auto_pdf = TRUE) rm(tmpFn) 8.4 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] BiocSingular_1.6.0 scuttle_1.0.4 ## [3] robustbase_0.93-7 mixtools_1.2.0 ## [5] dplyr_1.0.5 DT_0.18 ## [7] irlba_2.3.3 biomaRt_2.46.3 ## [9] Matrix_1.2-18 igraph_1.2.6 ## [11] DropletUtils_1.10.3 scater_1.18.6 ## [13] ggplot2_3.3.3 scran_1.18.7 ## [15] SingleCellExperiment_1.12.0 SummarizedExperiment_1.20.0 ## [17] Biobase_2.50.0 GenomicRanges_1.42.0 ## [19] GenomeInfoDb_1.26.7 IRanges_2.24.1 ## [21] S4Vectors_0.28.1 BiocGenerics_0.36.1 ## [23] MatrixGenerics_1.2.1 matrixStats_0.58.0 ## [25] knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] ggbeeswarm_0.6.0 colorspace_2.0-0 ## [3] ellipsis_0.3.1 bluster_1.0.0 ## [5] XVector_0.30.0 BiocNeighbors_1.8.2 ## [7] rstudioapi_0.13 bit64_4.0.5 ## [9] AnnotationDbi_1.52.0 fansi_0.4.2 ## [11] xml2_1.3.2 codetools_0.2-16 ## [13] splines_4.0.3 R.methodsS3_1.8.1 ## [15] sparseMatrixStats_1.2.1 cachem_1.0.4 ## [17] jsonlite_1.7.2 kernlab_0.9-29 ## [19] dbplyr_2.0.0 png_0.1-7 ## [21] R.oo_1.24.0 HDF5Array_1.18.1 ## [23] readr_1.4.0 compiler_4.0.3 ## [25] httr_1.4.2 dqrng_0.2.1 ## [27] assertthat_0.2.1 fastmap_1.1.0 ## [29] limma_3.46.0 htmltools_0.5.1.1 ## [31] prettyunits_1.1.1 tools_4.0.3 ## [33] rsvd_1.0.3 gtable_0.3.0 ## [35] glue_1.4.2 GenomeInfoDbData_1.2.4 ## [37] rappdirs_0.3.1 Rcpp_1.0.6 ## [39] jquerylib_0.1.3 vctrs_0.3.7 ## [41] rhdf5filters_1.2.0 DelayedMatrixStats_1.12.3 ## [43] xfun_0.22 stringr_1.4.0 ## [45] beachmat_2.6.4 lifecycle_1.0.0 ## [47] statmod_1.4.35 XML_3.99-0.5 ## [49] DEoptimR_1.0-8 edgeR_3.32.1 ## [51] MASS_7.3-53 zlibbioc_1.36.0 ## [53] scales_1.1.1 hms_1.0.0 ## [55] rhdf5_2.34.0 curl_4.3 ## [57] yaml_2.2.1 memoise_2.0.0 ## [59] gridExtra_2.3 sass_0.3.1 ## [61] segmented_1.3-3 stringi_1.5.3 ## [63] RSQLite_2.2.6 highr_0.8 ## [65] BiocParallel_1.24.1 rlang_0.4.10 ## [67] pkgconfig_2.0.3 bitops_1.0-6 ## [69] evaluate_0.14 lattice_0.20-41 ## [71] purrr_0.3.4 Rhdf5lib_1.12.1 ## [73] htmlwidgets_1.5.3 bit_4.0.4 ## [75] tidyselect_1.1.0 magrittr_2.0.1 ## [77] bookdown_0.21 R6_2.5.0 ## [79] generics_0.1.0 DelayedArray_0.16.3 ## [81] DBI_1.1.1 pillar_1.6.0 ## [83] withr_2.4.2 survival_3.2-7 ## [85] RCurl_1.98-1.3 tibble_3.1.1 ## [87] crayon_1.4.1 utf8_1.2.1 ## [89] BiocFileCache_1.14.0 rmarkdown_2.7 ## [91] viridis_0.5.1 progress_1.2.2 ## [93] locfit_1.5-9.4 grid_4.0.3 ## [95] blob_1.2.1 digest_0.6.27 ## [97] R.utils_2.10.1 openssl_1.4.3 ## [99] munsell_0.5.0 beeswarm_0.2.3 ## [101] viridisLite_0.3.0 vipor_0.4.5 ## [103] bslib_0.2.4 askpass_1.1 "],["dimRedForVizTop.html", "Chapter 9 Dimensionality reduction for visualisation 9.1 Principal Component Analysis 9.2 Load packages 9.3 Load data 9.4 PCA 9.5 t-SNE: t-Distributed Stochastic Neighbor Embedding 9.6 UMAP 9.7 Session information", " Chapter 9 Dimensionality reduction for visualisation projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit In part 1 we gathered the data, aligned reads, checked quality, and normalised read counts. We will now identify genes to focus on, use visualisation to explore the data, collapse the data set, cluster cells by their expression profile and identify genes that best characterise these cell populations. These main steps are shown below (???). We’ll first explain dimensionality reduction for visualisation, using Principal Component Analysis, t-SNE and UMAP. 9.1 Principal Component Analysis In a single cell RNA-seq (scRNASeq) data set, each cell is described by the expression level of thoushands of genes. The total number of genes measured is referred to as dimensionality. Each gene measured is one dimension in the space characterising the data set. Many genes will little vary across cells and thus be uninformative when comparing cells. Also, because some genes will have correlated expression patterns, some information is redundant. Moreover, we can represent data in three dimensions, not more. So reducing the number of useful dimensions is necessary. 9.1.1 Description The data set: a matrix with one row per sample and one variable per column. Here samples are cells and each variable is the normalised read count for a given gene. The space: each cell is associated to a point in a multi-dimensional space where each gene is a dimension. The aim: to find a new set of variables defining a space with fewer dimensions while losing as little information as possible. Out of a set of variables (read counts), PCA defines new variables called Principal Components (PCs) that best capture the variability observed amongst samples (cells), see (???) for example. The number of variables does not change. Only the fraction of variance captured by each variable differs. The first PC explains the highest proportion of variance possible (bound by prperties of PCA). The second PC explains the highest proportion of variance not explained by the first PC. PCs each explain a decreasing amount of variance not explained by the previous ones. Each PC is a dimension in the new space. The total amount of variance explained by the first few PCs is usually such that excluding remaining PCs, ie dimensions, loses little information. The stronger the correlation between the initial variables, the stronger the reduction in dimensionality. PCs to keep can be chosen as those capturing at least as much as the average variance per initial variable or using a scree plot, see below. PCs are linear combinations of the initial variables. PCs represent the same amount of information as the initial set and enable its restoration. The data is not altered. We only look at it in a different way. About the mapping function from the old to the new space: it is linear it is inverse, to restore the original space it relies on orthogonal PCs so that the total variance remains the same. Two transformations of the data are necessary: center the data so that the sample mean for each column is 0 so the covariance matrix of the intial matrix takes a simple form scale variance to 1, ie standardize, to avoid PCA loading on variables with large variance. 9.1.2 Example Here we will make a simple data set of 100 samples and 2 variables, perform PCA and visualise on the initial plane the data set and PCs (???). library(ggplot2) fontsize &lt;- theme(axis.text=element_text(size=12), axis.title=element_text(size=16)) Let’s make and plot a data set. set.seed(123) #sets the seed for random number generation. x &lt;- 1:100 #creates a vector x with numbers from 1 to 100 ex &lt;- rnorm(100, 0, 30) #100 normally distributed rand. nos. w/ mean=0, s.d.=30 ey &lt;- rnorm(100, 0, 30) # &quot; &quot; y &lt;- 30 + 2 * x #sets y to be a vector that is a linear function of x x_obs &lt;- x + ex #adds &quot;noise&quot; to x y_obs &lt;- y + ey #adds &quot;noise&quot; to y P &lt;- cbind(x_obs,y_obs) #places points in matrix plot(P,asp=1,col=1) #plot points points(mean(x_obs),mean(y_obs),col=3, pch=19) #show center Center the data and compute covariance matrix. M &lt;- cbind(x_obs - mean(x_obs), y_obs - mean(y_obs)) #centered matrix MCov &lt;- cov(M) #creates covariance matrix Compute the principal axes, ie eigenvectors and corresponding eigenvalues. An eigenvector is a direction and an eigenvalue is a number measuring the spread of the data in that direction. The eigenvector with the highest eigenvalue is the first principal component. The eigenvectors of the covariance matrix provide the principal axes, and the eigenvalues quantify the fraction of variance explained in each component. eigenValues &lt;- eigen(MCov)$values #compute eigenvalues eigenVectors &lt;- eigen(MCov)$vectors #compute eigenvectors # or use &#39;singular value decomposition&#39; of the matrix d &lt;- svd(M)$d #the singular values v &lt;- svd(M)$v #the right singular vectors Let’s plot the principal axes. First PC: # PC 1: plot(P,asp=1,col=1) #plot points points(mean(x_obs),mean(y_obs),col=3, pch=19) #show center lines(x_obs,eigenVectors[2,1]/eigenVectors[1,1]*M[x]+mean(y_obs),col=8) Second PC: plot(P,asp=1,col=1) #plot points points(mean(x_obs),mean(y_obs),col=3, pch=19) #show center # PC 1: lines(x_obs,eigenVectors[2,1]/eigenVectors[1,1]*M[x]+mean(y_obs),col=8) # PC 2: lines(x_obs,eigenVectors[2,2]/eigenVectors[1,2]*M[x]+mean(y_obs),col=8) Add the projections of the points onto the first PC: plot(P,asp=1,col=1) #plot points points(mean(x_obs),mean(y_obs),col=3, pch=19) #show center # PC 1: lines(x_obs,eigenVectors[2,1]/eigenVectors[1,1]*M[x]+mean(y_obs),col=8) # PC 2: lines(x_obs,eigenVectors[2,2]/eigenVectors[1,2]*M[x]+mean(y_obs),col=8) # add projecions: trans &lt;- (M%*%v[,1])%*%v[,1] #compute projections of points P_proj &lt;- scale(trans, center=-cbind(mean(x_obs),mean(y_obs)), scale=FALSE) points(P_proj, col=4,pch=19,cex=0.5) #plot projections segments(x_obs,y_obs,P_proj[,1],P_proj[,2],col=4,lty=2) #connect to points Compute PCs with prcomp(). pca_res &lt;- prcomp(M) summary(pca_res) ## Importance of components: ## PC1 PC2 ## Standard deviation 73.827 28.279 ## Proportion of Variance 0.872 0.128 ## Cumulative Proportion 0.872 1.000 var_explained &lt;- pca_res$sdev^2/sum(pca_res$sdev^2) var_explained ## [1] 0.8720537 0.1279463 Check amount of variance captured by PCs on a scree plot. # Show scree plot: plot(pca_res) Plot with ggplot. df_pc &lt;- data.frame(pca_res$x) g &lt;- ggplot(df_pc, aes(PC1, PC2)) + geom_point(size=2) + # draw points labs(title=&quot;PCA&quot;, subtitle=&quot;With principal components PC1 and PC2 as X and Y axis&quot;) + coord_cartesian(xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)), ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))) g &lt;- g + geom_hline(yintercept=0) g &lt;- g + geom_vline(xintercept=0) g Or use ggfortify autoplot(). # ggfortify library(ggfortify) g &lt;- autoplot(pca_res) g &lt;- g + geom_hline(yintercept=0) g &lt;- g + geom_vline(xintercept=0) g Going from 2D to 3D (figure from (???)): 9.2 Load packages library(scater) # for QC and plots 9.3 Load data We will load the R file keeping the SCE object with the normalised counts for 500 cells per sample. setName &lt;- &quot;caron&quot; setSuf &lt;- &quot;_5hCellPerSpl&quot; # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) print(tmpFn) ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/caron_sce_nz_postDeconv_5hCellPerSpl.Rds&quot; if(!file.exists(tmpFn)) { knitr::knit_exit() } sce &lt;- readRDS(tmpFn) sce ## class: SingleCellExperiment ## dim: 16629 5500 ## metadata(0): ## assays(2): counts logcounts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): head(rowData(sce)) ## DataFrame with 6 rows and 11 columns ## ensembl_gene_id external_gene_name chromosome_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000237491 ENSG00000237491 LINC01409 1 ## ENSG00000225880 ENSG00000225880 LINC00115 1 ## ENSG00000230368 ENSG00000230368 FAM41C 1 ## ENSG00000230699 ENSG00000230699 AL645608.2 1 ## ENSG00000188976 ENSG00000188976 NOC2L 1 ## ENSG00000187961 ENSG00000187961 KLHL17 1 ## start_position end_position strand Symbol ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## ENSG00000237491 778747 810065 1 AL669831.5 ## ENSG00000225880 826206 827522 -1 LINC00115 ## ENSG00000230368 868071 876903 -1 FAM41C ## ENSG00000230699 911435 914948 1 AL645608.3 ## ENSG00000188976 944203 959309 -1 NOC2L ## ENSG00000187961 960584 965719 1 KLHL17 ## Type mean detected gene_sparsity ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000237491 Gene Expression 0.02785355 2.706672 0.977951 ## ENSG00000225880 Gene Expression 0.01376941 1.340222 0.985699 ## ENSG00000230368 Gene Expression 0.02027381 1.946076 0.980821 ## ENSG00000230699 Gene Expression 0.00144251 0.144251 0.997704 ## ENSG00000188976 Gene Expression 0.17711393 14.511645 0.835565 ## ENSG00000187961 Gene Expression 0.00354070 0.348825 0.995935 #any(duplicated(rowData(nz.sce)$ensembl_gene_id)) # some function(s) used below complain about &#39;strand&#39; already being used in row data, # so rename that column now: colnames(rowData(sce))[colnames(rowData(sce)) == &quot;strand&quot;] &lt;- &quot;strandNum&quot; 9.4 PCA Perform PCA, keep outcome in same object. nbPcToComp &lt;- 50 # compute PCA: #sce &lt;- runPCA(sce, ncomponents = nbPcToComp, method = &quot;irlba&quot;) sce &lt;- runPCA(sce, ncomponents = nbPcToComp) Display scree plot. # with reducedDim sce.pca &lt;- reducedDim(sce, &quot;PCA&quot;) attributes(sce.pca)$percentVar ## [1] 16.1072558 9.6482486 4.4673293 3.7808853 1.9639696 1.8008626 ## [7] 1.6739293 1.2887282 1.0690783 0.8596321 0.8018422 0.6846937 ## [13] 0.6139309 0.5946088 0.5411263 0.4377304 0.3900507 0.3815624 ## [19] 0.3636303 0.3514861 0.3408887 0.2973306 0.2843550 0.2754252 ## [25] 0.2666001 0.2609457 0.2555751 0.2496498 0.2481626 0.2371280 ## [31] 0.2320116 0.2304992 0.2270922 0.2257485 0.2242832 0.2198916 ## [37] 0.2189744 0.2173953 0.2151230 0.2140901 0.2129180 0.2120306 ## [43] 0.2094498 0.2083422 0.2063008 0.2059701 0.2047050 0.2033185 ## [49] 0.2025080 0.2017399 barplot(attributes(sce.pca)$percentVar, main=sprintf(&quot;Scree plot for the %s first PCs&quot;, nbPcToComp), names.arg=1:nbPcToComp, cex.names = 0.8) Display cells on a plot for the first 2 PCs, colouring by ‘Sample’ and setting size to match ‘total_features’. The proximity of cells reflects the similarity of their expression profiles. g &lt;- plotPCA(sce, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot; ) g One can also split the plot by sample. g &lt;- g + facet_wrap(sce$source_name ~ .) g Or plot several PCs at once, using plotReducedDim(): plotReducedDim(sce, dimred=&quot;PCA&quot;, ncomponents=3, colour_by = &quot;Sample.Name&quot;) + fontsize 9.4.1 Correlation between PCs and the total number of features detected The PCA plot above shows cells as symbols whose size depends on the total number of features or library size. It suggests there may be a correlation between PCs and these variables. Let’s check: colData(sce)$source_name &lt;- factor(colData(sce)$source_name) colData(sce)$block &lt;- factor(colData(sce)$block) r2mat &lt;- getExplanatoryPCs(sce) #r2mat &lt;- getExplanatoryPCs(sce, # variables = c(&quot;Run&quot;, &quot;source_name&quot;)) # #variables = c(&quot;Run&quot;, &quot;Sample.Name&quot;)) # #variables = c(&quot;Run&quot;, &quot;Sample.Name&quot;, &quot;source_name&quot;)) r2mat ## Barcode Run Sample.Name source_name sum detected ## PC1 NaN 30.85659 30.85659 6.487377 0.43493165 7.08894442 ## PC2 NaN 39.71165 39.71165 25.878094 4.25167387 0.58954116 ## PC3 NaN 30.70223 30.70223 18.018721 38.24631708 43.80921901 ## PC4 NaN 59.99750 59.99750 46.026981 6.29085450 7.52064941 ## PC5 NaN 28.72873 28.72873 11.700557 4.57160974 6.47357417 ## PC6 NaN 43.68081 43.68081 15.832822 0.39643282 0.04005349 ## PC7 NaN 39.80806 39.80806 25.736034 0.34776526 1.87429989 ## PC8 NaN 61.48502 61.48502 53.382059 1.26696650 0.69851353 ## PC9 NaN 20.48116 20.48116 7.806216 2.68842935 2.55756540 ## PC10 NaN 41.24854 41.24854 5.412729 0.01273348 0.43130416 ## subsets_Mito_sum subsets_Mito_detected subsets_Mito_percent total ## PC1 6.51661947 18.1351642 4.1926231 0.43493165 ## PC2 0.10383151 1.9809524 15.5359489 4.25167387 ## PC3 25.12527402 10.3594392 2.3470910 38.24631708 ## PC4 1.55024880 1.7264436 0.2189570 6.29085450 ## PC5 8.47830110 15.8647633 7.0504884 4.57160974 ## PC6 11.71821736 14.7324487 40.4069838 0.39643282 ## PC7 0.05713278 2.0491925 0.8726234 0.34776526 ## PC8 0.05725464 1.8114625 5.5016017 1.26696650 ## PC9 4.79687302 4.6900075 3.4547445 2.68842935 ## PC10 0.06794968 0.2728095 1.0255645 0.01273348 ## block setName discard outlier cell_sparsity sizeFactor ## PC1 6.487377 NA 0.1175128 0.34195161 7.08948526 6.03083849 ## PC2 25.878094 NA 7.2209671 7.03388703 0.59077199 0.21122381 ## PC3 18.018721 NA 6.4199167 9.61961429 43.83600840 35.30043641 ## PC4 46.026981 NA 2.7802380 4.06365034 7.50975544 8.72178733 ## PC5 11.700557 NA 0.6676141 0.25601414 6.47138586 4.57011170 ## PC6 15.832822 NA 18.9268506 15.79017131 0.03990797 0.02550611 ## PC7 25.736034 NA 1.2853430 1.97448881 1.87469906 0.71227698 ## PC8 53.382059 NA 0.8302930 0.69206768 0.69721085 0.76186993 ## PC9 7.806216 NA 0.9206323 0.70318630 2.55906696 3.06770581 ## PC10 5.412729 NA 0.2997168 0.08553385 0.43088612 0.30545007 dat &lt;- cbind(colData(sce)[,c(&quot;Sample.Name&quot;, &quot;source_name&quot;, &quot;sum&quot;, &quot;detected&quot;, #&quot;percent_top_200&quot;, &quot;subsets_Mito_percent&quot;)], reducedDim(sce,&quot;PCA&quot;)) dat &lt;- data.frame(dat) dat$sum &lt;- log2(dat$sum) ggplot(dat, aes(x=sum, y=PC1, shape=source_name, col=Sample.Name)) + geom_point() + geom_smooth(method=lm, inherit.aes = FALSE, aes(x=sum, y=PC1)) #ggplot(dat, aes(x=percent_top_200, y=PC2, shape=source_name, col=Sample.Name)) + # geom_point() + # geom_smooth(method=lm, inherit.aes = FALSE, aes(x=percent_top_200, y=PC2)) ggplot(dat, aes(x=detected, y=PC3, shape=source_name, col=Sample.Name)) + geom_point() + geom_smooth(method=lm, inherit.aes = FALSE, aes(x=detected, y=PC3)) ggplot(dat, aes(x=subsets_Mito_percent, y=PC2, shape=source_name, col=Sample.Name)) + geom_point() + geom_smooth(method=lm, inherit.aes = FALSE, aes(x=subsets_Mito_percent, y=PC2)) ggplot(dat, aes(x=source_name, y=PC7, shape=source_name, col=Sample.Name)) + geom_boxplot() 9.5 t-SNE: t-Distributed Stochastic Neighbor Embedding The Stochastic Neighbor Embedding (SNE) approach address two shortcomings of PCA that captures the global covariance structure with a linear combination of initial variables: by preserving the local structure allowing for non-linear projections. It uses two distributions of the pairwise similarities between data points: in the input data set and in the low-dimensional space. SNE aims at preserving neighbourhoods. For each points, it computes probabilities of chosing each other point as its neighbour based on a Normal distribution depending on 1) the distance matrix and 2) the size of the neighbourhood (perplexity). SNE aims at finding a low-dimension space (eg 2D-plane) such that the similarity matrix deriving from it is as similar as possible as that from the high-dimension space. To address the fact that in low dimension, points are brought together, the similarity matrix in the low-dimension is allowed to follow a t-distribution. Two characteristics matter: perplexity, to indicate the relative importance of the local and global patterns in structure of the data set, usually use a value of 50, stochasticity; running the analysis will produce a different map every time, unless the seed is set. See misread-tsne. 9.5.1 Perplexity Compute t-SNE with default perplexity, ie 50. # runTSNE default perpexity if min(50, floor(ncol(object)/5)) sce &lt;- runTSNE(sce, dimred=&quot;PCA&quot;, perplexity=50, rand_seed=123) Plot t-SNE: tsne50 &lt;- plotTSNE(sce, colour_by=&quot;Sample.Name&quot;, size_by=&quot;sum&quot;) + fontsize + ggtitle(&quot;Perplexity = 50&quot;) tsne50 Compute t-SNE for several perplexity values: tsne5.run &lt;- runTSNE(sce, use_dimred=&quot;PCA&quot;, perplexity=5, rand_seed=123) tsne5 &lt;- plotTSNE(tsne5.run, colour_by=&quot;Sample.Name&quot;) + fontsize + ggtitle(&quot;Perplexity = 5&quot;) #tsne200.run &lt;- runTSNE(sce, use_dimred=&quot;PCA&quot;, perplexity=200, rand_seed=123) #tsne200 &lt;- plotTSNE(tsne200.run, colour_by=&quot;Sample.Name&quot;) + fontsize + ggtitle(&quot;Perplexity = 200&quot;) tsne500.run &lt;- runTSNE(sce, use_dimred=&quot;PCA&quot;, perplexity=500, rand_seed=123) tsne500 &lt;- plotTSNE(tsne500.run, colour_by=&quot;Sample.Name&quot;) + fontsize + ggtitle(&quot;Perplexity = 500&quot;) #tsne1000.run &lt;- runTSNE(sce, use_dimred=&quot;PCA&quot;, perplexity=1000, rand_seed=123) #tsne1000 &lt;- plotTSNE(tsne1000.run, colour_by=&quot;Sample.Name&quot;) + fontsize + ggtitle(&quot;Perplexity = 1000&quot;) tsne5 #tsne50 #tsne200 tsne500 9.5.2 Stochasticity Use a different seed with the same perplexity 50. tsne50.b &lt;- runTSNE(sce, use_dimred=&quot;PCA&quot;, perplexity=50, rand_seed=456) tsne50.b &lt;- plotTSNE(tsne50.b, colour_by=&quot;Sample.Name&quot;, size_by=&quot;sum&quot;) + fontsize + ggtitle(&quot;Perplexity = 50, seed 456&quot;) tsne50.b 9.6 UMAP Another neighbour graph method. Similar to t-SNE, but that is determistic, faster and claims to preserve both local and global structures. Compute UMAP. set.seed(123) sce &lt;- runUMAP(sce, dimred=&quot;PCA&quot;) Plot UMAP: sce.umap &lt;- plotUMAP(sce, colour_by=&quot;Sample.Name&quot;, size_by=&quot;sum&quot;) + fontsize + ggtitle(&quot;UMAP&quot;) sce.umap Save SCE object: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s_dimRed.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce, tmpFn) 9.7 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] ggfortify_0.4.11 BiocSingular_1.6.0 ## [3] scuttle_1.0.4 robustbase_0.93-7 ## [5] mixtools_1.2.0 dplyr_1.0.5 ## [7] DT_0.18 irlba_2.3.3 ## [9] biomaRt_2.46.3 Matrix_1.2-18 ## [11] igraph_1.2.6 DropletUtils_1.10.3 ## [13] scater_1.18.6 ggplot2_3.3.3 ## [15] scran_1.18.7 SingleCellExperiment_1.12.0 ## [17] SummarizedExperiment_1.20.0 Biobase_2.50.0 ## [19] GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [21] IRanges_2.24.1 S4Vectors_0.28.1 ## [23] BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [25] matrixStats_0.58.0 knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] BiocFileCache_1.14.0 splines_4.0.3 ## [3] BiocParallel_1.24.1 digest_0.6.27 ## [5] htmltools_0.5.1.1 viridis_0.5.1 ## [7] fansi_0.4.2 magrittr_2.0.1 ## [9] memoise_2.0.0 limma_3.46.0 ## [11] readr_1.4.0 R.utils_2.10.1 ## [13] askpass_1.1 prettyunits_1.1.1 ## [15] colorspace_2.0-0 blob_1.2.1 ## [17] rappdirs_0.3.1 xfun_0.22 ## [19] crayon_1.4.1 RCurl_1.98-1.3 ## [21] jsonlite_1.7.2 survival_3.2-7 ## [23] glue_1.4.2 gtable_0.3.0 ## [25] zlibbioc_1.36.0 XVector_0.30.0 ## [27] DelayedArray_0.16.3 kernlab_0.9-29 ## [29] Rhdf5lib_1.12.1 DEoptimR_1.0-8 ## [31] HDF5Array_1.18.1 scales_1.1.1 ## [33] DBI_1.1.1 edgeR_3.32.1 ## [35] Rcpp_1.0.6 viridisLite_0.3.0 ## [37] progress_1.2.2 dqrng_0.2.1 ## [39] bit_4.0.4 rsvd_1.0.3 ## [41] htmlwidgets_1.5.3 httr_1.4.2 ## [43] ellipsis_0.3.1 pkgconfig_2.0.3 ## [45] XML_3.99-0.5 R.methodsS3_1.8.1 ## [47] farver_2.1.0 uwot_0.1.10 ## [49] sass_0.3.1 dbplyr_2.0.0 ## [51] locfit_1.5-9.4 utf8_1.2.1 ## [53] tidyselect_1.1.0 labeling_0.4.2 ## [55] rlang_0.4.10 AnnotationDbi_1.52.0 ## [57] munsell_0.5.0 tools_4.0.3 ## [59] cachem_1.0.4 generics_0.1.0 ## [61] RSQLite_2.2.6 evaluate_0.14 ## [63] stringr_1.4.0 fastmap_1.1.0 ## [65] yaml_2.2.1 bit64_4.0.5 ## [67] purrr_0.3.4 nlme_3.1-149 ## [69] sparseMatrixStats_1.2.1 R.oo_1.24.0 ## [71] xml2_1.3.2 compiler_4.0.3 ## [73] rstudioapi_0.13 beeswarm_0.2.3 ## [75] curl_4.3 tibble_3.1.1 ## [77] statmod_1.4.35 bslib_0.2.4 ## [79] stringi_1.5.3 highr_0.8 ## [81] RSpectra_0.16-0 lattice_0.20-41 ## [83] bluster_1.0.0 vctrs_0.3.7 ## [85] pillar_1.6.0 lifecycle_1.0.0 ## [87] rhdf5filters_1.2.0 jquerylib_0.1.3 ## [89] RcppAnnoy_0.0.18 BiocNeighbors_1.8.2 ## [91] cowplot_1.1.1 bitops_1.0-6 ## [93] R6_2.5.0 bookdown_0.21 ## [95] gridExtra_2.3 vipor_0.4.5 ## [97] codetools_0.2-16 MASS_7.3-53 ## [99] assertthat_0.2.1 rhdf5_2.34.0 ## [101] openssl_1.4.3 withr_2.4.2 ## [103] GenomeInfoDbData_1.2.4 mgcv_1.8-33 ## [105] hms_1.0.0 grid_4.0.3 ## [107] beachmat_2.6.4 tidyr_1.1.3 ## [109] rmarkdown_2.7 DelayedMatrixStats_1.12.3 ## [111] segmented_1.3-3 Rtsne_0.15 ## [113] ggbeeswarm_0.6.0 projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit cacheBool &lt;- params$cacheBool library(knitr) "],["identifying-confounding-factors-caron-set.html", "Chapter 10 Identifying confounding factors - Caron set 10.1 Session information", " Chapter 10 Identifying confounding factors - Caron set normPlotDirBit &lt;- &quot;Plots/Norm&quot; # &quot;ConfoundPlots&quot; #setNameUpp &lt;- &quot;Caron&quot; #setNameLow &lt;- &quot;caron&quot; setName &lt;- tolower(&quot;Caron&quot;) setSuf &lt;- &quot;_5hCellPerSpl&quot; typeNorm &lt;- &quot;scran&quot; projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit caron Load object # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) tmpFn ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/caron_sce_nz_postDeconv_5hCellPerSpl.Rds&quot; #getwd() #file.exists(tmpFn) sce &lt;- readRDS(tmpFn) sce ## class: SingleCellExperiment ## dim: 16629 5500 ## metadata(0): ## assays(2): counts logcounts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(0): ## altExpNames(0): Remember scran PCA: Normalised counts are stored in ‘logcounts’ assay # scranPca &lt;- runPCA( sce, exprs_values = &quot;logcounts&quot; ) PCA plot for the ‘scran’ counts in the caron set. tmpFn &lt;- sprintf(&quot;%s/%s/%s/%s_sce_nz_postQc%s_%sPca.png&quot;, #projDir, outDirBit, normPlotDirBit, setName, setSuf, typeNorm) dirRel, normPlotDirBit, setName, setSuf, typeNorm) tmpFn knitr::include_graphics(tmpFn, auto_pdf = TRUE) #options(BiocSingularParam.default=IrlbaParam()) options(BiocSingularParam.default=ExactParam()) qclust &lt;- quickCluster(sce, min.size = 30, use.ranks = FALSE) sce &lt;- computeSumFactors(sce, sizes = 15, clusters = qclust) sce &lt;- logNormCounts(sce) Perform PCA: reducedDim(sce, &quot;PCA&quot;) &lt;- reducedDim( runPCA(sce, exprs_values = &quot;logcounts&quot;, ncomponents = 10), &quot;PCA&quot;) plotPCA( sce, colour_by = &quot;Sample.Name&quot;, size_by = &quot;sum&quot;, shape_by = &quot;source_name&quot; ) assay(sce, &quot;logcounts_raw&quot;) &lt;- log2(counts(sce)+1) # on norm count https://biocellgen-public.svi.edu.au/mig_2019_scrnaseq-workshop/public/normalization-confounders-and-batch-correction.html#identifying-confounding-factors # on logcounts_raw https://scrnaseq-course.cog.sanger.ac.uk/website/cleaning-the-expression-matrix.html#correlations-with-pcs # a bit long # issue with scale, trying with explanPc/100 # see next chunk too explanPc &lt;- getExplanatoryPCs( sce, exprs_values = &quot;logcounts_raw&quot;, variables = c( &quot;sum&quot;, &quot;detected&quot;, &quot;source_name&quot;, &quot;Sample.Name&quot;, &quot;subsets_Mito_percent&quot; ) ) plotExplanatoryPCs(explanPc/100) # on logcounts_raw # https://biocellgen-public.svi.edu.au/mig_2019_scrnaseq-workshop/public/normalization-confounders-and-batch-correction.html#identifying-confounding-factors plotExplanatoryVariables( sce, exprs_values = &quot;logcounts_raw&quot;, #exprs_values = &quot;counts&quot;, #exprs_values = &quot;logcounts&quot;, variables = c( &quot;sum&quot;, &quot;detected&quot;, &quot;source_name&quot;, &quot;Sample.Name&quot;, &quot;subsets_Mito_percent&quot; ) ) Correlation with PCs: logcounts (normalised): # on norm count https://biocellgen-public.svi.edu.au/mig_2019_scrnaseq-workshop/public/normalization-confounders-and-batch-correction.html#identifying-confounding-factors # on logcounts_raw https://scrnaseq-course.cog.sanger.ac.uk/website/cleaning-the-expression-matrix.html#correlations-with-pcs # a bit long colData(sce)$source_name &lt;- factor(colData(sce)$source_name) explanPc &lt;- getExplanatoryPCs(sce, #exprs_values = &quot;logcounts&quot;, # default variables = c( &quot;sum&quot;, &quot;detected&quot;, &quot;source_name&quot;, &quot;Sample.Name&quot;, &quot;subsets_Mito_percent&quot; ) ) plotExplanatoryPCs(explanPc/100) Explanatory variables: logcounts (normalised): # on logcounts_raw # https://biocellgen-public.svi.edu.au/mig_2019_scrnaseq-workshop/public/normalization-confounders-and-batch-correction.html#identifying-confounding-factors plotExplanatoryVariables( sce, # exprs_values = &quot;logcounts&quot;, # default variables = c( &quot;sum&quot;, &quot;detected&quot;, &quot;source_name&quot;, &quot;Sample.Name&quot;, &quot;subsets_Mito_percent&quot; ) ) rm(sce) 10.1 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] BiocSingular_1.6.0 scuttle_1.0.4 ## [3] robustbase_0.93-7 mixtools_1.2.0 ## [5] dplyr_1.0.5 DT_0.18 ## [7] irlba_2.3.3 biomaRt_2.46.3 ## [9] Matrix_1.2-18 igraph_1.2.6 ## [11] DropletUtils_1.10.3 scater_1.18.6 ## [13] ggplot2_3.3.3 scran_1.18.7 ## [15] SingleCellExperiment_1.12.0 SummarizedExperiment_1.20.0 ## [17] Biobase_2.50.0 GenomicRanges_1.42.0 ## [19] GenomeInfoDb_1.26.7 IRanges_2.24.1 ## [21] S4Vectors_0.28.1 BiocGenerics_0.36.1 ## [23] MatrixGenerics_1.2.1 matrixStats_0.58.0 ## [25] knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] ggbeeswarm_0.6.0 colorspace_2.0-0 ## [3] ellipsis_0.3.1 bluster_1.0.0 ## [5] XVector_0.30.0 BiocNeighbors_1.8.2 ## [7] rstudioapi_0.13 bit64_4.0.5 ## [9] AnnotationDbi_1.52.0 fansi_0.4.2 ## [11] xml2_1.3.2 splines_4.0.3 ## [13] R.methodsS3_1.8.1 sparseMatrixStats_1.2.1 ## [15] cachem_1.0.4 jsonlite_1.7.2 ## [17] kernlab_0.9-29 dbplyr_2.0.0 ## [19] R.oo_1.24.0 HDF5Array_1.18.1 ## [21] readr_1.4.0 compiler_4.0.3 ## [23] httr_1.4.2 dqrng_0.2.1 ## [25] assertthat_0.2.1 fastmap_1.1.0 ## [27] limma_3.46.0 htmltools_0.5.1.1 ## [29] prettyunits_1.1.1 tools_4.0.3 ## [31] rsvd_1.0.3 gtable_0.3.0 ## [33] glue_1.4.2 GenomeInfoDbData_1.2.4 ## [35] rappdirs_0.3.1 Rcpp_1.0.6 ## [37] jquerylib_0.1.3 vctrs_0.3.7 ## [39] rhdf5filters_1.2.0 DelayedMatrixStats_1.12.3 ## [41] xfun_0.22 stringr_1.4.0 ## [43] beachmat_2.6.4 lifecycle_1.0.0 ## [45] statmod_1.4.35 XML_3.99-0.5 ## [47] DEoptimR_1.0-8 edgeR_3.32.1 ## [49] MASS_7.3-53 zlibbioc_1.36.0 ## [51] scales_1.1.1 hms_1.0.0 ## [53] rhdf5_2.34.0 curl_4.3 ## [55] yaml_2.2.1 memoise_2.0.0 ## [57] gridExtra_2.3 sass_0.3.1 ## [59] segmented_1.3-3 stringi_1.5.3 ## [61] RSQLite_2.2.6 BiocParallel_1.24.1 ## [63] rlang_0.4.10 pkgconfig_2.0.3 ## [65] bitops_1.0-6 evaluate_0.14 ## [67] lattice_0.20-41 purrr_0.3.4 ## [69] Rhdf5lib_1.12.1 htmlwidgets_1.5.3 ## [71] bit_4.0.4 tidyselect_1.1.0 ## [73] magrittr_2.0.1 bookdown_0.21 ## [75] R6_2.5.0 generics_0.1.0 ## [77] DelayedArray_0.16.3 DBI_1.1.1 ## [79] pillar_1.6.0 withr_2.4.2 ## [81] survival_3.2-7 RCurl_1.98-1.3 ## [83] tibble_3.1.1 crayon_1.4.1 ## [85] utf8_1.2.1 BiocFileCache_1.14.0 ## [87] rmarkdown_2.7 viridis_0.5.1 ## [89] progress_1.2.2 locfit_1.5-9.4 ## [91] grid_4.0.3 blob_1.2.1 ## [93] digest_0.6.27 R.utils_2.10.1 ## [95] openssl_1.4.3 munsell_0.5.0 ## [97] beeswarm_0.2.3 viridisLite_0.3.0 ## [99] vipor_0.4.5 bslib_0.2.4 ## [101] askpass_1.1 "],["feature-selection.html", "Chapter 11 Feature selection 11.1 Load data 11.2 Feature selection with scran 11.3 Session information", " Chapter 11 Feature selection library(ggplot2) library(scater) library(scran) projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit cacheBool &lt;- params$cacheBool setName &lt;- params$setName setSuf &lt;- params$setSuf if(params$bookType == &quot;mk&quot;){ dirRel &lt;- &quot;..&quot; setName &lt;- &quot;caron&quot; setSuf &lt;- &quot;_5hCellPerSpl&quot; } fontsize &lt;- theme(axis.text=element_text(size=12), axis.title=element_text(size=16)) 11.1 Load data We will load the R file keeping the SCE object with the normalised counts for 500 cells per sample. # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s_dimRed.Rds&quot;, projDir, outDirBit, setName, setSuf) print(tmpFn) ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/caron_sce_nz_postDeconv_5hCellPerSpl_dimRed.Rds&quot; if(!file.exists(tmpFn)) { knitr::knit_exit() } sce &lt;- readRDS(tmpFn) sce ## class: SingleCellExperiment ## dim: 16629 5500 ## metadata(0): ## assays(2): counts logcounts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(3): PCA TSNE UMAP ## altExpNames(0): head(rowData(sce)) ## DataFrame with 6 rows and 11 columns ## ensembl_gene_id external_gene_name chromosome_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000237491 ENSG00000237491 LINC01409 1 ## ENSG00000225880 ENSG00000225880 LINC00115 1 ## ENSG00000230368 ENSG00000230368 FAM41C 1 ## ENSG00000230699 ENSG00000230699 AL645608.2 1 ## ENSG00000188976 ENSG00000188976 NOC2L 1 ## ENSG00000187961 ENSG00000187961 KLHL17 1 ## start_position end_position strandNum Symbol ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## ENSG00000237491 778747 810065 1 AL669831.5 ## ENSG00000225880 826206 827522 -1 LINC00115 ## ENSG00000230368 868071 876903 -1 FAM41C ## ENSG00000230699 911435 914948 1 AL645608.3 ## ENSG00000188976 944203 959309 -1 NOC2L ## ENSG00000187961 960584 965719 1 KLHL17 ## Type mean detected gene_sparsity ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000237491 Gene Expression 0.02785355 2.706672 0.977951 ## ENSG00000225880 Gene Expression 0.01376941 1.340222 0.985699 ## ENSG00000230368 Gene Expression 0.02027381 1.946076 0.980821 ## ENSG00000230699 Gene Expression 0.00144251 0.144251 0.997704 ## ENSG00000188976 Gene Expression 0.17711393 14.511645 0.835565 ## ENSG00000187961 Gene Expression 0.00354070 0.348825 0.995935 #any(duplicated(rowData(sce)$ensembl_gene_id)) # some function(s) used below complain about &#39;strand&#39; already being used in row data, # so rename that column now: colnames(rowData(sce))[colnames(rowData(sce)) == &quot;strand&quot;] &lt;- &quot;strandNum&quot; assayNames(sce) ## [1] &quot;counts&quot; &quot;logcounts&quot; 11.2 Feature selection with scran scRNASeq measures the expression of thousands of genes in each cell. The biological question asked in a study will most often relate to a fraction of these genes only, linked for example to differences between cell types, drivers of differentiation, or response to perturbation. Most high-throughput molecular data include variation created by the assay itself, not biology, i.e. technical noise, for example caused by sampling during RNA capture and library preparation. In scRNASeq, this technical noise will result in most genes being detected at different levels. This noise may hinder the detection of the biological signal. Let’s identify Highly Variables Genes (HVGs) with the aim to find those underlying the heterogeneity observed across cells. 11.2.1 Modelling and removing technical noise Some assays allow the inclusion of known molecules in a known amount covering a wide range, from low to high abundance: spike-ins. The technical noise is assessed based on the amount of spike-ins used, the corresponding read counts obtained and their variation across cells. The variance in expression can then be decomposed into the biolgical and technical components. UMI-based assays do not (yet?) allow spike-ins. But one can still identify HVGs, that is genes with the highest biological component. Assuming that expression does not vary across cells for most genes, the total variance for these genes mainly reflects technical noise. The latter can thus be assessed by fitting a trend to the variance in expression. The fitted value will be the estimate of the technical component. Let’s fit a trend to the variance, using modelGeneVar(). dec.sce &lt;- modelGeneVar(sce) Let’s plot variance against mean of expression (log scale) and the mean-dependent trend fitted to the variance: # Visualizing the fit: var.fit &lt;- metadata(dec.sce) plot(var.fit$mean, var.fit$var, xlab=&quot;Mean of log-expression&quot;, ylab=&quot;Variance of log-expression&quot;) curve(var.fit$trend(x), col=&quot;dodgerblue&quot;, add=TRUE, lwd=2) In the absence of spike-in data, one can attempt to create a trend by making some distributional assumptions about the noise. For example, UMI counts typically exhibit near-Poisson variation if we only consider technical noise from library preparation and sequencing. This can be used to construct a mean-variance trend in the log-counts with the modelGeneVarByPoisson() function. Note the increased residuals of the high-abundance genes, which can be interpreted as the amount of biological variation that was assumed to be “uninteresting” when fitting the gene-based trend above. set.seed(0010101) dec.pois.sce &lt;- modelGeneVarByPoisson(sce) dec.pois.sce &lt;- dec.pois.sce[order(dec.pois.sce$bio, decreasing=TRUE),] head(dec.pois.sce) ## DataFrame with 6 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000244734 2.509485 12.14273 0.944558 11.19817 0 0 ## ENSG00000188536 1.869015 9.81279 1.046947 8.76585 0 0 ## ENSG00000206172 1.624877 8.95495 1.031745 7.92321 0 0 ## ENSG00000223609 0.785968 4.36010 0.707898 3.65221 0 0 ## ENSG00000019582 2.842386 4.37079 0.848232 3.52256 0 0 ## ENSG00000204287 2.329591 3.66889 0.987724 2.68117 0 0 Plot: plot(dec.pois.sce$mean, dec.pois.sce$total, pch=16, xlab=&quot;Mean of log-expression&quot;, ylab=&quot;Variance of log-expression&quot;) curve(metadata(dec.pois.sce)$trend(x), col=&quot;dodgerblue&quot;, add=TRUE) Interestingly, trends based purely on technical noise tend to yield large biological components for highly-expressed genes. This often includes so-called “house-keeping” genes coding for essential cellular components such as ribosomal proteins, which are considered uninteresting for characterizing cellular heterogeneity. These observations suggest that a more accurate noise model does not necessarily yield a better ranking of HVGs, though one should keep an open mind - house-keeping genes are regularly DE in a variety of conditions (Glare et al. 2002; Nazari, Parham, and Maleki 2015; Guimaraes and Zavolan 2016), and the fact that they have large biological components indicates that there is strong variation across cells that may not be completely irrelevant. 11.2.2 Choosing some HVGs: Identify the top 20 HVGs by sorting genes in decreasing order of biological component. # order genes by decreasing order of biological component o &lt;- order(dec.sce$bio, decreasing=TRUE) # check top and bottom of sorted table head(dec.sce[o,]) ## DataFrame with 6 rows and 6 columns ## mean total tech bio p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000244734 2.509485 12.14273 1.501176 10.64155 0.00000e+00 ## ENSG00000188536 1.869015 9.81279 1.407077 8.40572 0.00000e+00 ## ENSG00000206172 1.624877 8.95495 1.328093 7.62686 0.00000e+00 ## ENSG00000223609 0.785968 4.36010 0.814664 3.54544 1.76443e-226 ## ENSG00000019582 2.842386 4.37079 1.491606 2.87918 2.57120e-46 ## ENSG00000206177 0.580477 3.24218 0.632917 2.60926 1.77838e-203 ## FDR ## &lt;numeric&gt; ## ENSG00000244734 0.00000e+00 ## ENSG00000188536 0.00000e+00 ## ENSG00000206172 0.00000e+00 ## ENSG00000223609 5.86744e-223 ## ENSG00000019582 1.01789e-43 ## ENSG00000206177 4.92819e-200 tail(dec.sce[o,]) ## DataFrame with 6 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000108654 2.35282 1.23874 1.50084 -0.262102 0.901192 0.963563 ## ENSG00000063177 3.03164 1.20580 1.48289 -0.277097 0.915987 0.972156 ## ENSG00000174748 3.76111 1.14211 1.43802 -0.295910 0.935507 0.983329 ## ENSG00000115268 3.81719 1.11875 1.42987 -0.311116 0.945777 0.988399 ## ENSG00000149806 2.86380 1.14650 1.49128 -0.344780 0.955963 0.994046 ## ENSG00000173812 3.05559 1.13496 1.48016 -0.345203 0.957336 0.994976 # choose the top 20 genes with the highest biological component chosen.genes.index &lt;- o[1:20] Show the top 20 HVGs on the plot displaying the variance against the mean expression: plot(var.fit$mean, var.fit$var) curve(var.fit$trend(x), col=&quot;red&quot;, lwd=2, add=TRUE) points(var.fit$mean[chosen.genes.index], var.fit$var[chosen.genes.index], col=&quot;orange&quot;) Rather than choosing a fixed number of top genes, one may define ‘HVGs’ as genes with a positive biological component, ie whose variance is higher than the fitted value for the corresponding mean expression. Select and show these ‘HVGs’ on the plot displaying the variance against the mean expression: hvgBool &lt;- dec.sce$bio &gt; 0 table(hvgBool) ## hvgBool ## FALSE TRUE ## 7301 9328 hvg.index &lt;- which(hvgBool) plot(var.fit$mean, var.fit$var) curve(var.fit$trend(x), col=&quot;red&quot;, lwd=2, add=TRUE) points(var.fit$mean[hvg.index], var.fit$var[hvg.index], col=&quot;orange&quot;) Save objects to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s_featSel.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(list(&quot;dec.sce&quot;=dec.sce,&quot;hvg.index&quot;=hvg.index), tmpFn) rm(var.fit, hvgBool, hvg.index) HVGs may be driven by outlier cells. So let’s plot the distribution of expression values for the genes with the largest biological components. First, get gene names to replace ensembl IDs on plot. # the count matrix rows are named with ensembl gene IDs. Let&#39;s label gene with their name instead: # row indices of genes in rowData(sce) tmpInd &lt;- which(rowData(sce)$ensembl_gene_id %in% rownames(dec.sce)[chosen.genes.index]) # check: rowData(sce)[tmpInd,c(&quot;ensembl_gene_id&quot;,&quot;external_gene_name&quot;)] ## DataFrame with 20 rows and 2 columns ## ensembl_gene_id external_gene_name ## &lt;character&gt; &lt;character&gt; ## ENSG00000143546 ENSG00000143546 S100A8 ## ENSG00000211592 ENSG00000211592 IGKC ## ENSG00000145335 ENSG00000145335 SNCA ## ENSG00000170180 ENSG00000170180 GYPA ## ENSG00000019582 ENSG00000019582 CD74 ## ... ... ... ## ENSG00000206177 ENSG00000206177 HBM ## ENSG00000188536 ENSG00000188536 HBA2 ## ENSG00000206172 ENSG00000206172 HBA1 ## ENSG00000169877 ENSG00000169877 AHSP ## ENSG00000090013 ENSG00000090013 BLVRB # store names: tmpName &lt;- rowData(sce)[tmpInd,&quot;external_gene_name&quot;] # the gene name may not be known, so keep the ensembl gene ID in that case: tmpName[tmpName==&quot;&quot;] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][tmpName==&quot;&quot;] tmpName[is.na(tmpName)] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][is.na(tmpName)] rm(tmpInd) Now show a violin plot for each gene, using plotExpression() and label genes with their name: g &lt;- plotExpression(sce, rownames(dec.sce)[chosen.genes.index], point_alpha=0.05, jitter=&quot;jitter&quot;) + fontsize g &lt;- g + scale_x_discrete(breaks=rownames(dec.sce)[chosen.genes.index], labels=tmpName) g rm(tmpName) Another few genes: chosen.genes.index &lt;- o[21:40] tmpInd &lt;- which(rowData(sce)$ensembl_gene_id %in% rownames(dec.sce)[chosen.genes.index]) # check: rowData(sce)[tmpInd,c(&quot;ensembl_gene_id&quot;,&quot;external_gene_name&quot;)] ## DataFrame with 20 rows and 2 columns ## ensembl_gene_id external_gene_name ## &lt;character&gt; &lt;character&gt; ## ENSG00000117632 ENSG00000117632 STMN1 ## ENSG00000163220 ENSG00000163220 S100A9 ## ENSG00000196154 ENSG00000196154 S100A4 ## ENSG00000136732 ENSG00000136732 GYPC ## ENSG00000250361 ENSG00000250361 GYPB ## ... ... ... ## ENSG00000013306 ENSG00000013306 SLC25A39 ## ENSG00000171223 ENSG00000171223 JUNB ## ENSG00000167815 ENSG00000167815 PRDX2 ## ENSG00000198692 ENSG00000198692 EIF1AY ## ENSG00000169575 ENSG00000169575 VPREB1 # store names: tmpName &lt;- rowData(sce)[tmpInd,&quot;external_gene_name&quot;] # the gene name may not be known, so keep the ensembl gene ID in that case: tmpName[tmpName==&quot;&quot;] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][tmpName==&quot;&quot;] tmpName[is.na(tmpName)] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][is.na(tmpName)] rm(tmpInd) g &lt;- plotExpression(sce, rownames(dec.sce)[chosen.genes.index], point_alpha=0.05, jitter=&quot;jitter&quot;) + fontsize g &lt;- g + scale_x_discrete(breaks=rownames(dec.sce)[chosen.genes.index], labels=tmpName) g rm(tmpName) Challenge: Show violin plots for the 20 genes with the lowest biological component. How do they compare to the those for HVGs chosen above? chosen.genes.index.tmp &lt;- order(dec.sce$bio, decreasing=FALSE)[1:20] tmpInd &lt;- (which(rowData(sce)$ensembl_gene_id %in% rownames(dec.sce)[chosen.genes.index.tmp])) # check: rowData(sce)[tmpInd,c(&quot;ensembl_gene_id&quot;,&quot;external_gene_name&quot;)] ## DataFrame with 20 rows and 2 columns ## ensembl_gene_id external_gene_name ## &lt;character&gt; &lt;character&gt; ## ENSG00000142676 ENSG00000142676 RPL11 ## ENSG00000187514 ENSG00000187514 PTMA ## ENSG00000174748 ENSG00000174748 RPL15 ## ENSG00000232112 ENSG00000232112 TMA7 ## ENSG00000104529 ENSG00000104529 EEF1D ## ... ... ... ## ENSG00000105640 ENSG00000105640 RPL18A ## ENSG00000105372 ENSG00000105372 RPS19 ## ENSG00000063177 ENSG00000063177 RPL18 ## ENSG00000142534 ENSG00000142534 RPS11 ## ENSG00000170889 ENSG00000170889 RPS9 # store names: tmpName &lt;- rowData(sce)[tmpInd,&quot;external_gene_name&quot;] # the gene name may not be known, so keep the ensembl gene ID in that case: tmpName[tmpName==&quot;&quot;] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][tmpName==&quot;&quot;] tmpName[is.na(tmpName)] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][is.na(tmpName)] rm(tmpInd) g &lt;- plotExpression(sce, rownames(dec.sce)[chosen.genes.index.tmp], point_alpha=0.05, jitter=&quot;jitter&quot;) + fontsize g &lt;- g + scale_x_discrete(breaks=rownames(dec.sce)[chosen.genes.index.tmp], labels=tmpName) g rm(chosen.genes.index.tmp, tmpName) rm(dec.sce) rm(dec.pois.sce) rm(sce) 11.3 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] ggfortify_0.4.11 BiocSingular_1.6.0 ## [3] scuttle_1.0.4 robustbase_0.93-7 ## [5] mixtools_1.2.0 dplyr_1.0.5 ## [7] DT_0.18 irlba_2.3.3 ## [9] biomaRt_2.46.3 Matrix_1.2-18 ## [11] igraph_1.2.6 DropletUtils_1.10.3 ## [13] scater_1.18.6 ggplot2_3.3.3 ## [15] scran_1.18.7 SingleCellExperiment_1.12.0 ## [17] SummarizedExperiment_1.20.0 Biobase_2.50.0 ## [19] GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [21] IRanges_2.24.1 S4Vectors_0.28.1 ## [23] BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [25] matrixStats_0.58.0 knitr_1.32 ## ## loaded via a namespace (and not attached): ## [1] ggbeeswarm_0.6.0 colorspace_2.0-0 ## [3] ellipsis_0.3.1 bluster_1.0.0 ## [5] XVector_0.30.0 BiocNeighbors_1.8.2 ## [7] rstudioapi_0.13 bit64_4.0.5 ## [9] AnnotationDbi_1.52.0 fansi_0.4.2 ## [11] xml2_1.3.2 splines_4.0.3 ## [13] R.methodsS3_1.8.1 sparseMatrixStats_1.2.1 ## [15] cachem_1.0.4 jsonlite_1.7.2 ## [17] kernlab_0.9-29 dbplyr_2.0.0 ## [19] R.oo_1.24.0 HDF5Array_1.18.1 ## [21] readr_1.4.0 compiler_4.0.3 ## [23] httr_1.4.2 dqrng_0.2.1 ## [25] assertthat_0.2.1 fastmap_1.1.0 ## [27] limma_3.46.0 htmltools_0.5.1.1 ## [29] prettyunits_1.1.1 tools_4.0.3 ## [31] rsvd_1.0.3 gtable_0.3.0 ## [33] glue_1.4.2 GenomeInfoDbData_1.2.4 ## [35] rappdirs_0.3.1 Rcpp_1.0.6 ## [37] jquerylib_0.1.3 vctrs_0.3.7 ## [39] rhdf5filters_1.2.0 DelayedMatrixStats_1.12.3 ## [41] xfun_0.22 stringr_1.4.0 ## [43] beachmat_2.6.4 lifecycle_1.0.0 ## [45] statmod_1.4.35 XML_3.99-0.5 ## [47] DEoptimR_1.0-8 edgeR_3.32.1 ## [49] MASS_7.3-53 zlibbioc_1.36.0 ## [51] scales_1.1.1 hms_1.0.0 ## [53] rhdf5_2.34.0 curl_4.3 ## [55] yaml_2.2.1 memoise_2.0.0 ## [57] gridExtra_2.3 sass_0.3.1 ## [59] segmented_1.3-3 stringi_1.5.3 ## [61] RSQLite_2.2.6 BiocParallel_1.24.1 ## [63] rlang_0.4.10 pkgconfig_2.0.3 ## [65] bitops_1.0-6 evaluate_0.14 ## [67] lattice_0.20-41 purrr_0.3.4 ## [69] Rhdf5lib_1.12.1 htmlwidgets_1.5.3 ## [71] bit_4.0.4 tidyselect_1.1.0 ## [73] magrittr_2.0.1 bookdown_0.21 ## [75] R6_2.5.0 generics_0.1.0 ## [77] DelayedArray_0.16.3 DBI_1.1.1 ## [79] pillar_1.6.0 withr_2.4.2 ## [81] survival_3.2-7 RCurl_1.98-1.3 ## [83] tibble_3.1.1 crayon_1.4.1 ## [85] utf8_1.2.1 BiocFileCache_1.14.0 ## [87] rmarkdown_2.7 viridis_0.5.1 ## [89] progress_1.2.2 locfit_1.5-9.4 ## [91] grid_4.0.3 blob_1.2.1 ## [93] digest_0.6.27 tidyr_1.1.3 ## [95] R.utils_2.10.1 openssl_1.4.3 ## [97] munsell_0.5.0 beeswarm_0.2.3 ## [99] viridisLite_0.3.0 vipor_0.4.5 ## [101] bslib_0.2.4 askpass_1.1 "]]
