[["NormalisationAllCells.html", "Chapter 6 Normalisation 6.1 Caron 6.2 Hca 6.3 SCTransform", " Chapter 6 Normalisation Why normalise? Systematic differences in sequencing coverage between libraries caused by low input material, differences in cDNA capture and PCR amplification. Normalisation removes such differences so that differences between cells are not technical but biological, allowing meaningful comparison of expression profiles between cells. TODO difference between normalisation and batch correction. norm: technical differences only. batch correction: technical and biological. different assumptions and methods. In scaling normalization, the “normalization factor” is an estimate of the library size relative to the other cells. steps: compute a cell-specific ‘scaling’ or ‘size’ factor that represents the relative bias in that cell and divide all counts for the cell by that factor to remove that bias. Assumption: any cell specific bias will affect genes the same way. Scaling methods typically generate normalised counts-per-million (CPM) or transcripts-per-million (TPM_ values. projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit compuBool &lt;- TRUE # whether to run computation again (dev) #qcPlotDirBit &lt;- &quot;Plots/Norm&quot; library(scuttle) library(scran) library(ggplot2) library(dplyr) 6.1 Caron Load object setName &lt;- &quot;caron&quot; setSuf = &quot;_allCells&quot; # suffix to add to file name to say all cells are used, with no downsampling # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce &lt;- readRDS(tmpFn) 6.1.1 Library size normalization For each cell, the library size factor is proportional to the library size such that the average size factor across cell is one. Advantage: normalised counts are on the same scale as the initial counts. Compute size factors: lib.sf &lt;- librarySizeFactors(sce) summary(lib.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1205 0.4432 0.7308 1.0000 1.2859 14.4562 Size factor distribution: wide range, typical of scRNA-seq data. hist(log10(lib.sf), xlab=&quot;Log10[Size factor]&quot;, col=&#39;grey80&#39;) Assumption: absence of compositional bias; differential expression two cells is balanced: upregulation in some genes is accompanied by downregulation of other genes. Not observed. Inaccurate normalisation due to unaccounted-for composition bias affects the size of the log fold change measured between clusters, but less so the clustering itself. It is thus sufficient to identify clusters and top marker genes. 6.1.2 Deconvolution Composition bias occurs when differential expression beteween two samples or here cells is not balanced. For a fixed library size, identical in both cells, upregulation of one gene in the a cell will means fewer UMIs can be assigned to other genes, which would then appear down regulated. Even if library sizes are allowed to differ in size, with that for the cell with upregulation being higher, scaling normalisation will reduce noralised counts. Non-upregulated would therefore also appear downregulated. For bulk RNA-seq, composition bias is removed by assuming that most genes are not differentially expressed between samples, so that differences in non-DE genes would amount to the bias, and used to compute size factors. Given the sparsity of scRNA-seq data, the methods are not appropriate. The method below increases read counts by pooling cells into groups, computing size factors within each of these groups and scaling them so they are comparable across clusters. This process is repeated many times, changing pools each time to collect several size factors for each cell, frome which is derived a single value for that cell. Cluster cells, normalise : set.seed(100) # clusters with PCA from irlba with approximation clust &lt;- quickCluster(sce) # slow with all cells. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(clust, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) clust &lt;- readRDS(tmpFn) table(clust) ## clust ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 1557 5519 3149 602 2106 374 2389 1788 1378 4815 923 1846 5575 1989 108 1657 ## 17 18 19 20 21 22 23 24 25 ## 701 1882 5053 1420 278 714 802 1049 156 6.1.3 Compute size factors deconv.sf &lt;- calculateSumFactors(sce, cluster=clust) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(deconv.sf, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) deconv.sf &lt;- readRDS(tmpFn) summary(deconv.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.03169 0.41551 0.73178 1.00000 1.30221 15.27223 Plot plot(lib.sf, deconv.sf, xlab=&quot;Library size factor&quot;, ylab=&quot;Deconvolution size factor&quot;, log=&#39;xy&#39;, pch=16, col=as.integer(factor(sce$source_name))) abline(a=0, b=1, col=&quot;red&quot;) deconvDf &lt;- data.frame(lib.sf, deconv.sf, &quot;source_name&quot; = sce$source_name, &quot;sum&quot; = sce$sum, &quot;mito_content&quot; = sce$subsets_Mito_percent, &quot;cell_sparsity&quot; = sce$cell_sparsity) sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=source_name)) + geom_point() sp + facet_wrap(~source_name) sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=sum)) + geom_point() sp sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=mito_content)) + geom_point() sp sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=cell_sparsity)) + geom_point() sp #ggMarginal(sp) 6.1.3.1 Apply size factors For each cell, raw counts for genes are divided by the size factor for that cell and log-transformed so downstream analyses focus on genes with strong relative differences. We use scater::logNormCounts(). sce &lt;- logNormCounts(sce) assayNames(sce) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.1.3.2 Save object sce_caron &lt;- sce # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce_caron, tmpFn) 6.2 Hca Load object # the 5kCellPerSpl subset setName &lt;- &quot;hca&quot; setSuf &lt;- &quot;_5kCellPerSpl&quot; # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postQc%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce &lt;- readRDS(tmpFn) 6.2.1 Library size normalization For each cell, the library size factor is proportioanl to the library size such that the average size factor across cell is one. Advantage: normalised counts are on the same scale as the initial counts. Compute size factors: lib.sf &lt;- librarySizeFactors(sce) summary(lib.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.3249 0.4916 0.6015 1.0000 0.8224 27.5849 Size factor distribution: wide range, typical of scRNA-seq data. hist(log10(lib.sf), xlab=&quot;Log10[Size factor]&quot;, col=&#39;grey80&#39;) Assumption: absence of compositional bias; differential expression two cells is balanced: upregulation in some genes is accompanied by downregulation of other genes. Not observed. Inaccurate normalisation due to unaccounted-for composition bias affects the size of the log fold change measured between clusters, but less so the clusterisation itself. It is thus sufficient to identify clustrs and top arker genes. 6.2.2 Deconvolution Composition bias occurs when differential expression beteween two samples or here cells is not balanced. For a fixed library size, identical in both cells, upregulation of one gene in the a cell will means fewer UMIs can be assigned to other genes, which would then appear down regulated. Even if library sizes are allowed to differ in size, with that for the cell with upregulation being higher, scaling normalisation will reduce noralised counts. Non-upregulated would therefore also appear downregulated. For bulk RNA-seq, composition bias is removed by assuming that most genes are not differentially expressed between samples, so that differences in non-DE genes would amount to the bias, and used to compute size factors. Given the sparsity of scRNA-seq data, the methods are not appropriate. The method below increases read counts by pooling cells into groups, computing size factors within each of these groups and scaling them so they are comparable across clusters. This process is repeated many times, changing pools each time to collect several size factors for each cell, frome which is derived a single value for that cell. Cluster cells, normalise : #library(scran) set.seed(100) # clusters with PCA from irlba with approximation clust &lt;- quickCluster(sce) # slow with all cells. # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(clust, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_quickClus%s.Rds&quot;, projDir, outDirBit, setName, setSuf) clust &lt;- readRDS(tmpFn) table(clust) ## clust ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 1444 577 807 2116 3106 497 3973 613 1693 731 3655 9970 3136 225 3221 517 ## 17 18 19 20 21 22 23 24 25 ## 486 568 868 219 252 416 315 283 312 6.2.3 Compute size factors deconv.sf &lt;- calculateSumFactors(sce, cluster=clust) # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(deconv.sf, tmpFn) # read from file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_deconvSf%s.Rds&quot;, projDir, outDirBit, setName, setSuf) deconv.sf &lt;- readRDS(tmpFn) summary(deconv.sf) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0896 0.4112 0.5071 1.0000 0.7585 38.5010 Plot plot(lib.sf, deconv.sf, xlab=&quot;Library size factor&quot;, ylab=&quot;Deconvolution size factor&quot;, log=&#39;xy&#39;, pch=16, col=as.integer(factor(sce$source_name))) abline(a=0, b=1, col=&quot;red&quot;) deconvDf &lt;- data.frame(lib.sf, deconv.sf, &quot;source_name&quot; = sce$source_name, &quot;sum&quot; = sce$sum, &quot;mito_content&quot; = sce$subsets_Mito_percent, &quot;cell_sparsity&quot; = sce$cell_sparsity) sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=source_name)) + geom_point() sp + facet_wrap(~source_name) sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=sum)) + geom_point() sp sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=mito_content)) + geom_point() sp sp &lt;- ggplot(deconvDf, aes(x=lib.sf, y=deconv.sf, col=cell_sparsity)) + geom_point() sp #ggMarginal(sp) 6.2.3.1 Apply size factors For each cell, raw counts for genes are divided by the size factor for that cell and log-transformed so downstream analyses focus on genes with strong relative differences. We use scater::logNormCounts(). sce &lt;- logNormCounts(sce) assayNames(sce) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.2.3.2 Save object sce_hca &lt;- sce # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(sce_hca, tmpFn) 6.3 SCTransform With scaling normalisation a correlation remains between the mean and variation of expression (heteroskedasticity). This affects downstream dimensionality reduction as the few main new dimensions are usually correlated with library size. SCTransform addresses the issue by regressing library size out of raw counts and providing residuals to use as normalized and variance-stabilized expression values in downstream analysis. 6.3.1 Caron setName &lt;- &quot;caron&quot; setSuf = &quot;_allCells&quot; # suffix to add to file name to say which cells are used, eg downsampling sce &lt;- sce_caron counts &lt;- counts(sce) class(counts) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; colnames(counts) &lt;- colData(sce)$Barcode Inspect data We will now calculate some properties and visually inspect the data. Our main interest is in the general trends not in individual outliers. Neither genes nor cells that stand out are important at this step, but we focus on the global trends. Derive gene and cell attributes from the UMI matrix. gene_attr &lt;- data.frame(mean = rowMeans(counts), detection_rate = rowMeans(counts &gt; 0), var = apply(counts, 1, var)) gene_attr$log_mean &lt;- log10(gene_attr$mean) gene_attr$log_var &lt;- log10(gene_attr$var) rownames(gene_attr) &lt;- rownames(counts) cell_attr &lt;- data.frame(n_umi = colSums(counts), n_gene = colSums(counts &gt; 0)) rownames(cell_attr) &lt;- colnames(counts) ggplot(gene_attr, aes(log_mean, log_var)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) + geom_abline(intercept = 0, slope = 1, color=&#39;red&#39;) Mean-variance relationship For the genes, we can see that up to a mean UMI count of ca. 0.1 the variance follows the line through the origin with slop one, i.e. variance and mean are roughly equal as expected under a Poisson model. However, genes with a higher average UMI count show overdispersion compared to Poisson. # add the expected detection rate under Poisson model x = seq(from = -3, to = 2, length.out = 1000) poisson_model &lt;- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x)) ggplot(gene_attr, aes(log_mean, detection_rate)) + geom_point(alpha=0.3, shape=16) + geom_line(data=poisson_model, color=&#39;red&#39;) + theme_gray(base_size = 8) Mean-detection-rate relationship In line with the previous plot, we see a lower than expected detection rate in the medium expression range. However, for the highly expressed genes, the rate is at or very close to 1.0 suggesting that there is no zero-inflation in the counts for those genes and that zero-inflation is a result of overdispersion, rather than an independent systematic bias. ggplot(cell_attr, aes(n_umi, n_gene)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) General idea of transformation Based on the observations above, which are not unique to this particular data set, we propose to model the expression of each gene as a negative binomial random variable with a mean that depends on other variables. Here the other variables can be used to model the differences in sequencing depth between cells and are used as independent variables in a regression model. In order to avoid overfitting, we will first fit model parameters per gene, and then use the relationship between gene mean and parameter values to fit parameters, thereby combining information across genes. Given the fitted model parameters, we transform each observed UMI count into a Pearson residual which can be interpreted as the number of standard deviations an observed count was away from the expected mean. If the model accurately describes the mean-variance relationship and the dependency of mean and latent factors, then the result should have mean zero and a stable variance across the range of expression. Estimate model parameters and transform data The vst function estimates model parameters and performs the variance stabilizing transformation. Here we use the log10 of the total UMI counts of a cell as variable for sequencing depth for each cell. After data transformation we plot the model parameters as a function of gene mean (geometric mean). # We use the Future API for parallel processing; set parameters here future::plan(strategy = &#39;multicore&#39;, workers = 4) options(future.globals.maxSize = 10 * 1024 ^ 3) set.seed(44) vst_out &lt;- sctransform::vst(counts, latent_var = c(&#39;log_umi&#39;), return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE) sctransform::plot_model_pars(vst_out) Inspect model We will look at several genes in more detail. #sctransform::plot_model(vst_out, counts, c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;), plot_residual = TRUE) rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;)) ## ensembl_gene_id external_gene_name chromosome_name ## ENSG00000147403 ENSG00000147403 RPL10 X ## ENSG00000251562 ENSG00000251562 MALAT1 11 ## ENSG00000087086 ENSG00000087086 FTL 19 ## start_position end_position strand Symbol Type ## ENSG00000147403 154389955 154409168 1 RPL10 Gene Expression ## ENSG00000251562 65497688 65506516 1 MALAT1 Gene Expression ## ENSG00000087086 48965309 48966879 1 FTL Gene Expression ## mean detected gene_sparsity ## ENSG00000147403 48.85548 99.28030 0.011540874 ## ENSG00000251562 193.05529 99.09786 0.005352289 ## ENSG00000087086 15.48621 96.42481 0.085532093 sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000251562&#39;, &#39;ENSG00000147403&#39;, &#39;ENSG00000087086&#39;), plot_residual = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE, arrange_vertical = FALSE) # Error in seq_len(n) : argument must be coercible to non-negative integer rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;GNLY&#39;, &#39;S100A9&#39;)) #sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000115523&#39;, &#39;ENSG00000163220&#39;), plot_residual = TRUE, show_nr = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000115523&#39;), plot_residual = TRUE, show_nr = TRUE) # ok # sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE) ggplot(vst_out$gene_attr, aes(residual_mean)) + geom_histogram(binwidth=0.01) ggplot(vst_out$gene_attr, aes(residual_variance)) + geom_histogram(binwidth=0.1) + geom_vline(xintercept=1, color=&#39;red&#39;) + xlim(0, 10) ggplot(vst_out$gene_attr, aes(x=residual_mean, y=residual_variance)) + geom_point(alpha=0.3, shape=16) + xlim(0, 2.5) + ylim(0, 10) + geom_density_2d() ggplot(vst_out$gene_attr, aes(log10(gmean), residual_variance)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) dd &lt;- head(round(vst_out$gene_attr[order(-vst_out$gene_attr$residual_variance), ], 2), 22) dd %&gt;% tibble::rownames_to_column(&quot;ensembl_gene_id&quot;) %&gt;% left_join(as.data.frame(rowData(sce))[,c(&quot;ensembl_gene_id&quot;, &quot;Symbol&quot;)], &quot;ensembl_gene_id&quot;) ## ensembl_gene_id detection_rate gmean variance residual_mean ## 1 ENSG00000244734 0.68 4.10 649629.63 14.75 ## 2 ENSG00000188536 0.52 2.19 85659.15 12.77 ## 3 ENSG00000206172 0.47 1.69 44114.20 11.90 ## 4 ENSG00000143546 0.11 0.19 249.14 3.10 ## 5 ENSG00000090382 0.09 0.19 212.73 3.06 ## 6 ENSG00000163220 0.12 0.20 203.90 2.71 ## 7 ENSG00000223609 0.24 0.57 1329.34 3.95 ## 8 ENSG00000196565 0.09 0.11 3174.14 1.17 ## 9 ENSG00000257764 0.06 0.09 59.35 1.44 ## 10 ENSG00000206177 0.17 0.38 364.29 2.35 ## 11 ENSG00000133742 0.15 0.31 412.45 1.79 ## 12 ENSG00000115523 0.03 0.05 5.59 0.88 ## 13 ENSG00000211592 0.29 0.43 19480.27 1.30 ## 14 ENSG00000213934 0.02 0.03 485.05 0.49 ## 15 ENSG00000169877 0.17 0.39 297.02 1.94 ## 16 ENSG00000132465 0.17 0.22 297.11 0.68 ## 17 ENSG00000211677 0.14 0.16 8450.79 0.77 ## 18 ENSG00000163221 0.03 0.05 5.80 0.66 ## 19 ENSG00000211895 0.12 0.11 3391.59 0.36 ## 20 ENSG00000211679 0.15 0.19 5093.45 0.82 ## 21 ENSG00000211896 0.04 0.04 1076.76 0.25 ## 22 ENSG00000005381 0.02 0.03 3.76 0.38 ## residual_variance Symbol ## 1 2870.41 HBB ## 2 2351.19 HBA2 ## 3 2095.02 HBA1 ## 4 536.54 S100A8 ## 5 444.50 LYZ ## 6 429.12 S100A9 ## 7 385.33 HBD ## 8 251.55 HBG2 ## 9 243.89 AC020656.1 ## 10 171.40 HBM ## 11 152.56 CA1 ## 12 124.08 GNLY ## 13 120.13 IGKC ## 14 107.86 HBG1 ## 15 105.89 AHSP ## 16 77.24 JCHAIN ## 17 76.38 IGLC2 ## 18 73.68 S100A12 ## 19 69.44 IGHA1 ## 20 66.42 IGLC3 ## 21 57.73 IGHG1 ## 22 52.10 MPO # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_vst_out%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(vst_out, tmpFn) 6.3.2 Hca Load object setName &lt;- &quot;hca&quot; setSuf &lt;- &quot;_5kCellPerSpl&quot; tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s.Rds&quot;, projDir, outDirBit, setName, setSuf) sce_hca &lt;- readRDS(tmpFn) sce &lt;- sce_hca counts &lt;- counts(sce) class(counts) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; colnames(counts) &lt;- colData(sce)$Barcode Inspect data gene_attr &lt;- data.frame(mean = rowMeans(counts), detection_rate = rowMeans(counts &gt; 0), var = apply(counts, 1, var)) gene_attr$log_mean &lt;- log10(gene_attr$mean) gene_attr$log_var &lt;- log10(gene_attr$var) rownames(gene_attr) &lt;- rownames(counts) cell_attr &lt;- data.frame(n_umi = colSums(counts), n_gene = colSums(counts &gt; 0)) rownames(cell_attr) &lt;- colnames(counts) Mean-variance relationship # add the expected detection rate under Poisson model x = seq(from = -3, to = 2, length.out = 1000) poisson_model &lt;- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x)) ggplot(gene_attr, aes(log_mean, detection_rate)) + geom_point(alpha=0.3, shape=16) + geom_line(data=poisson_model, color=&#39;red&#39;) + theme_gray(base_size = 8) Mean-detection-rate relationship ggplot(cell_attr, aes(n_umi, n_gene)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) # We use the Future API for parallel processing; set parameters here future::plan(strategy = &#39;multicore&#39;, workers = 4) options(future.globals.maxSize = 10 * 1024 ^ 3) set.seed(44) vst_out &lt;- sctransform::vst(counts, latent_var = c(&#39;log_umi&#39;), return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE) sctransform::plot_model_pars(vst_out) Inspect model We will look at several genes in more detail. #sctransform::plot_model(vst_out, counts, c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;), plot_residual = TRUE) rowData(sce) %&gt;% as.data.frame %&gt;% filter(Symbol %in% c(&#39;MALAT1&#39;, &#39;RPL10&#39;, &#39;FTL&#39;)) ## ensembl_gene_id external_gene_name chromosome_name ## ENSG00000147403 ENSG00000147403 RPL10 X ## ENSG00000251562 ENSG00000251562 MALAT1 11 ## ENSG00000087086 ENSG00000087086 FTL 19 ## start_position end_position strand Symbol Type ## ENSG00000147403 154389955 154409168 1 RPL10 Gene Expression ## ENSG00000251562 65497688 65506516 1 MALAT1 Gene Expression ## ENSG00000087086 48965309 48966879 1 FTL Gene Expression ## mean detected gene_sparsity ## ENSG00000147403 48.85548 99.28030 0.007196991 ## ENSG00000251562 193.05529 99.09786 0.009021354 ## ENSG00000087086 15.48621 96.42481 0.035751887 sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000251562&#39;, &#39;ENSG00000147403&#39;, &#39;ENSG00000087086&#39;), plot_residual = TRUE) sctransform::plot_model(vst_out, counts, c(&#39;ENSG00000087086&#39;), plot_residual = TRUE, show_nr = TRUE, arrange_vertical = FALSE) ggplot(vst_out$gene_attr, aes(residual_mean)) + geom_histogram(binwidth=0.01) ggplot(vst_out$gene_attr, aes(residual_variance)) + geom_histogram(binwidth=0.1) + geom_vline(xintercept=1, color=&#39;red&#39;) + xlim(0, 10) ggplot(vst_out$gene_attr, aes(x=residual_mean, y=residual_variance)) + geom_point(alpha=0.3, shape=16) + xlim(0, 2.5) + ylim(0, 10) + geom_density_2d() ggplot(vst_out$gene_attr, aes(log10(gmean), residual_variance)) + geom_point(alpha=0.3, shape=16) + geom_density_2d(size = 0.3) dd &lt;- head(round(vst_out$gene_attr[order(-vst_out$gene_attr$residual_variance), ], 2), 22) dd %&gt;% tibble::rownames_to_column(&quot;ensembl_gene_id&quot;) %&gt;% left_join(as.data.frame(rowData(sce))[,c(&quot;ensembl_gene_id&quot;, &quot;Symbol&quot;)], &quot;ensembl_gene_id&quot;) ## ensembl_gene_id detection_rate gmean variance residual_mean ## 1 ENSG00000244734 0.42 1.08 238622.12 9.19 ## 2 ENSG00000206172 0.22 0.53 15107.92 4.68 ## 3 ENSG00000188536 0.20 0.43 15462.24 4.13 ## 4 ENSG00000143546 0.23 0.85 831.45 6.72 ## 5 ENSG00000163220 0.25 0.97 971.98 6.91 ## 6 ENSG00000211592 0.38 0.76 410578.57 3.29 ## 7 ENSG00000211896 0.07 0.10 12130.59 1.31 ## 8 ENSG00000090382 0.26 1.17 1000.53 5.56 ## 9 ENSG00000211895 0.17 0.20 41519.43 1.36 ## 10 ENSG00000132465 0.10 0.18 2376.73 1.71 ## 11 ENSG00000211677 0.17 0.27 154546.35 1.81 ## 12 ENSG00000115523 0.12 0.31 56.22 2.97 ## 13 ENSG00000211897 0.05 0.07 4513.13 0.94 ## 14 ENSG00000223609 0.09 0.26 876.42 1.58 ## 15 ENSG00000211679 0.09 0.13 52521.33 1.21 ## 16 ENSG00000206177 0.04 0.11 152.68 1.08 ## 17 ENSG00000257764 0.10 0.22 30.21 1.66 ## 18 ENSG00000196415 0.02 0.04 14.02 0.75 ## 19 ENSG00000169877 0.09 0.32 796.95 1.82 ## 20 ENSG00000133742 0.08 0.25 691.30 1.42 ## 21 ENSG00000197561 0.03 0.05 21.68 0.73 ## 22 ENSG00000005381 0.05 0.09 27.49 1.08 ## residual_variance Symbol ## 1 1640.51 HBB ## 2 708.02 HBA1 ## 3 672.49 HBA2 ## 4 623.27 S100A8 ## 5 577.52 S100A9 ## 6 436.55 IGKC ## 7 273.25 IGHG1 ## 8 272.65 LYZ ## 9 264.35 IGHA1 ## 10 260.18 JCHAIN ## 11 229.99 IGLC2 ## 12 204.05 GNLY ## 13 190.74 IGHG3 ## 14 183.97 HBD ## 15 161.54 IGLC3 ## 16 148.18 HBM ## 17 117.43 AC020656.1 ## 18 116.06 PRTN3 ## 19 113.25 AHSP ## 20 107.15 CA1 ## 21 104.22 ELANE ## 22 96.48 MPO # write to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_vst_out%s.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(vst_out, tmpFn) "]]
