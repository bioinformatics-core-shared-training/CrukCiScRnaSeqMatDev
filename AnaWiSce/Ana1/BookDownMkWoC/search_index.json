[["feature-selection.html", "Chapter 9 Feature selection 9.1 Load data 9.2 Feature selection with scran 9.3 Session information", " Chapter 9 Feature selection library(ggplot2) library(scater) library(scran) projDir &lt;- params$projDir dirRel &lt;- params$dirRel outDirBit &lt;- params$outDirBit cacheBool &lt;- params$cacheBool setName &lt;- params$setName setSuf &lt;- params$setSuf if(params$bookType == &quot;mk&quot;){ dirRel &lt;- &quot;..&quot; setName &lt;- &quot;caron&quot; setSuf &lt;- &quot;_5hCellPerSpl&quot; } fontsize &lt;- theme(axis.text=element_text(size=12), axis.title=element_text(size=16)) 9.1 Load data We will load the R file keeping the SCE object with the normalised counts for 500 cells per sample. # Read object in: tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s_dimRed.Rds&quot;, projDir, outDirBit, setName, setSuf) print(tmpFn) ## [1] &quot;/ssd/personal/baller01/20200511_FernandesM_ME_crukBiSs2020/AnaWiSce/Ana1/Robjects/caron_sce_nz_postDeconv_5hCellPerSpl_dimRed.Rds&quot; if(!file.exists(tmpFn)) { knitr::knit_exit() } sce &lt;- readRDS(tmpFn) sce ## class: SingleCellExperiment ## dim: 16629 5500 ## metadata(0): ## assays(2): counts logcounts ## rownames(16629): ENSG00000237491 ENSG00000225880 ... ENSG00000275063 ## ENSG00000271254 ## rowData names(11): ensembl_gene_id external_gene_name ... detected ## gene_sparsity ## colnames: NULL ## colData names(16): Barcode Run ... cell_sparsity sizeFactor ## reducedDimNames(3): PCA TSNE UMAP ## altExpNames(0): head(rowData(sce)) ## DataFrame with 6 rows and 11 columns ## ensembl_gene_id external_gene_name chromosome_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000237491 ENSG00000237491 LINC01409 1 ## ENSG00000225880 ENSG00000225880 LINC00115 1 ## ENSG00000230368 ENSG00000230368 FAM41C 1 ## ENSG00000230699 ENSG00000230699 AL645608.2 1 ## ENSG00000188976 ENSG00000188976 NOC2L 1 ## ENSG00000187961 ENSG00000187961 KLHL17 1 ## start_position end_position strandNum Symbol ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## ENSG00000237491 778747 810065 1 AL669831.5 ## ENSG00000225880 826206 827522 -1 LINC00115 ## ENSG00000230368 868071 876903 -1 FAM41C ## ENSG00000230699 911435 914948 1 AL645608.3 ## ENSG00000188976 944203 959309 -1 NOC2L ## ENSG00000187961 960584 965719 1 KLHL17 ## Type mean detected gene_sparsity ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000237491 Gene Expression 0.02785355 2.706672 0.977951 ## ENSG00000225880 Gene Expression 0.01376941 1.340222 0.985699 ## ENSG00000230368 Gene Expression 0.02027381 1.946076 0.980821 ## ENSG00000230699 Gene Expression 0.00144251 0.144251 0.997704 ## ENSG00000188976 Gene Expression 0.17711393 14.511645 0.835565 ## ENSG00000187961 Gene Expression 0.00354070 0.348825 0.995935 #any(duplicated(rowData(sce)$ensembl_gene_id)) # some function(s) used below complain about &#39;strand&#39; already being used in row data, # so rename that column now: colnames(rowData(sce))[colnames(rowData(sce)) == &quot;strand&quot;] &lt;- &quot;strandNum&quot; assayNames(sce) ## [1] &quot;counts&quot; &quot;logcounts&quot; 9.2 Feature selection with scran scRNASeq measures the expression of thousands of genes in each cell. The biological question asked in a study will most often relate to a fraction of these genes only, linked for example to differences between cell types, drivers of differentiation, or response to perturbation. Most high-throughput molecular data include variation created by the assay itself, not biology, i.e. technical noise, for example caused by sampling during RNA capture and library preparation. In scRNASeq, this technical noise will result in most genes being detected at different levels. This noise may hinder the detection of the biological signal. Let’s identify Highly Variables Genes (HVGs) with the aim to find those underlying the heterogeneity observed across cells. 9.2.1 Modelling and removing technical noise Some assays allow the inclusion of known molecules in a known amount covering a wide range, from low to high abundance: spike-ins. The technical noise is assessed based on the amount of spike-ins used, the corresponding read counts obtained and their variation across cells. The variance in expression can then be decomposed into the biolgical and technical components. UMI-based assays do not (yet?) allow spike-ins. But one can still identify HVGs, that is genes with the highest biological component. Assuming that expression does not vary across cells for most genes, the total variance for these genes mainly reflects technical noise. The latter can thus be assessed by fitting a trend to the variance in expression. The fitted value will be the estimate of the technical component. Let’s fit a trend to the variance, using modelGeneVar(). dec.sce &lt;- modelGeneVar(sce) Let’s plot variance against mean of expression (log scale) and the mean-dependent trend fitted to the variance: # Visualizing the fit: var.fit &lt;- metadata(dec.sce) plot(var.fit$mean, var.fit$var, xlab=&quot;Mean of log-expression&quot;, ylab=&quot;Variance of log-expression&quot;) curve(var.fit$trend(x), col=&quot;dodgerblue&quot;, add=TRUE, lwd=2) In the absence of spike-in data, one can attempt to create a trend by making some distributional assumptions about the noise. For example, UMI counts typically exhibit near-Poisson variation if we only consider technical noise from library preparation and sequencing. This can be used to construct a mean-variance trend in the log-counts with the modelGeneVarByPoisson() function. Note the increased residuals of the high-abundance genes, which can be interpreted as the amount of biological variation that was assumed to be “uninteresting” when fitting the gene-based trend above. set.seed(0010101) dec.pois.sce &lt;- modelGeneVarByPoisson(sce) dec.pois.sce &lt;- dec.pois.sce[order(dec.pois.sce$bio, decreasing=TRUE),] head(dec.pois.sce) ## DataFrame with 6 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000244734 2.509485 12.14273 0.944558 11.19817 0 0 ## ENSG00000188536 1.869015 9.81279 1.046947 8.76585 0 0 ## ENSG00000206172 1.624877 8.95495 1.031745 7.92321 0 0 ## ENSG00000223609 0.785968 4.36010 0.707898 3.65221 0 0 ## ENSG00000019582 2.842386 4.37079 0.848232 3.52256 0 0 ## ENSG00000204287 2.329591 3.66889 0.987724 2.68117 0 0 Plot: plot(dec.pois.sce$mean, dec.pois.sce$total, pch=16, xlab=&quot;Mean of log-expression&quot;, ylab=&quot;Variance of log-expression&quot;) curve(metadata(dec.pois.sce)$trend(x), col=&quot;dodgerblue&quot;, add=TRUE) Interestingly, trends based purely on technical noise tend to yield large biological components for highly-expressed genes. This often includes so-called “house-keeping” genes coding for essential cellular components such as ribosomal proteins, which are considered uninteresting for characterizing cellular heterogeneity. These observations suggest that a more accurate noise model does not necessarily yield a better ranking of HVGs, though one should keep an open mind - house-keeping genes are regularly DE in a variety of conditions (Glare et al. 2002; Nazari, Parham, and Maleki 2015; Guimaraes and Zavolan 2016), and the fact that they have large biological components indicates that there is strong variation across cells that may not be completely irrelevant. 9.2.2 Choosing some HVGs: Identify the top 20 HVGs by sorting genes in decreasing order of biological component. # order genes by decreasing order of biological component o &lt;- order(dec.sce$bio, decreasing=TRUE) # check top and bottom of sorted table head(dec.sce[o,]) ## DataFrame with 6 rows and 6 columns ## mean total tech bio p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000244734 2.509485 12.14273 1.501176 10.64155 0.00000e+00 ## ENSG00000188536 1.869015 9.81279 1.407077 8.40572 0.00000e+00 ## ENSG00000206172 1.624877 8.95495 1.328093 7.62686 0.00000e+00 ## ENSG00000223609 0.785968 4.36010 0.814664 3.54544 1.76443e-226 ## ENSG00000019582 2.842386 4.37079 1.491606 2.87918 2.57120e-46 ## ENSG00000206177 0.580477 3.24218 0.632917 2.60926 1.77838e-203 ## FDR ## &lt;numeric&gt; ## ENSG00000244734 0.00000e+00 ## ENSG00000188536 0.00000e+00 ## ENSG00000206172 0.00000e+00 ## ENSG00000223609 5.86744e-223 ## ENSG00000019582 1.01789e-43 ## ENSG00000206177 4.92819e-200 tail(dec.sce[o,]) ## DataFrame with 6 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000108654 2.35282 1.23874 1.50084 -0.262102 0.901192 0.963563 ## ENSG00000063177 3.03164 1.20580 1.48289 -0.277097 0.915987 0.972156 ## ENSG00000174748 3.76111 1.14211 1.43802 -0.295910 0.935507 0.983329 ## ENSG00000115268 3.81719 1.11875 1.42987 -0.311116 0.945777 0.988399 ## ENSG00000149806 2.86380 1.14650 1.49128 -0.344780 0.955963 0.994046 ## ENSG00000173812 3.05559 1.13496 1.48016 -0.345203 0.957336 0.994976 # choose the top 20 genes with the highest biological component chosen.genes.index &lt;- o[1:20] Show the top 20 HVGs on the plot displaying the variance against the mean expression: plot(var.fit$mean, var.fit$var) curve(var.fit$trend(x), col=&quot;red&quot;, lwd=2, add=TRUE) points(var.fit$mean[chosen.genes.index], var.fit$var[chosen.genes.index], col=&quot;orange&quot;) Rather than choosing a fixed number of top genes, one may define ‘HVGs’ as genes with a positive biological component, ie whose variance is higher than the fitted value for the corresponding mean expression. Select and show these ‘HVGs’ on the plot displaying the variance against the mean expression: hvgBool &lt;- dec.sce$bio &gt; 0 table(hvgBool) ## hvgBool ## FALSE TRUE ## 7301 9328 hvg.index &lt;- which(hvgBool) plot(var.fit$mean, var.fit$var) curve(var.fit$trend(x), col=&quot;red&quot;, lwd=2, add=TRUE) points(var.fit$mean[hvg.index], var.fit$var[hvg.index], col=&quot;orange&quot;) Save objects to file tmpFn &lt;- sprintf(&quot;%s/%s/Robjects/%s_sce_nz_postDeconv%s_featSel.Rds&quot;, projDir, outDirBit, setName, setSuf) saveRDS(list(&quot;dec.sce&quot;=dec.sce,&quot;hvg.index&quot;=hvg.index), tmpFn) HVGs may be driven by outlier cells. So let’s plot the distribution of expression values for the genes with the largest biological components. First, get gene names to replace ensembl IDs on plot. # the count matrix rows are named with ensembl gene IDs. Let&#39;s label gene with their name instead: # row indices of genes in rowData(sce) tmpInd &lt;- which(rowData(sce)$ensembl_gene_id %in% rownames(dec.sce)[chosen.genes.index]) # check: rowData(sce)[tmpInd,c(&quot;ensembl_gene_id&quot;,&quot;external_gene_name&quot;)] ## DataFrame with 20 rows and 2 columns ## ensembl_gene_id external_gene_name ## &lt;character&gt; &lt;character&gt; ## ENSG00000143546 ENSG00000143546 S100A8 ## ENSG00000211592 ENSG00000211592 IGKC ## ENSG00000145335 ENSG00000145335 SNCA ## ENSG00000170180 ENSG00000170180 GYPA ## ENSG00000019582 ENSG00000019582 CD74 ## ... ... ... ## ENSG00000206177 ENSG00000206177 HBM ## ENSG00000188536 ENSG00000188536 HBA2 ## ENSG00000206172 ENSG00000206172 HBA1 ## ENSG00000169877 ENSG00000169877 AHSP ## ENSG00000090013 ENSG00000090013 BLVRB # store names: tmpName &lt;- rowData(sce)[tmpInd,&quot;external_gene_name&quot;] # the gene name may not be known, so keep the ensembl gene ID in that case: tmpName[tmpName==&quot;&quot;] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][tmpName==&quot;&quot;] tmpName[is.na(tmpName)] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][is.na(tmpName)] rm(tmpInd) Now show a violin plot for each gene, using plotExpression() and label genes with their name: g &lt;- plotExpression(sce, rownames(dec.sce)[chosen.genes.index], point_alpha=0.05, jitter=&quot;jitter&quot;) + fontsize g &lt;- g + scale_x_discrete(breaks=rownames(dec.sce)[chosen.genes.index], labels=tmpName) g Another few genes: chosen.genes.index &lt;- o[21:40] tmpInd &lt;- which(rowData(sce)$ensembl_gene_id %in% rownames(dec.sce)[chosen.genes.index]) # check: rowData(sce)[tmpInd,c(&quot;ensembl_gene_id&quot;,&quot;external_gene_name&quot;)] ## DataFrame with 20 rows and 2 columns ## ensembl_gene_id external_gene_name ## &lt;character&gt; &lt;character&gt; ## ENSG00000117632 ENSG00000117632 STMN1 ## ENSG00000163220 ENSG00000163220 S100A9 ## ENSG00000196154 ENSG00000196154 S100A4 ## ENSG00000136732 ENSG00000136732 GYPC ## ENSG00000250361 ENSG00000250361 GYPB ## ... ... ... ## ENSG00000013306 ENSG00000013306 SLC25A39 ## ENSG00000171223 ENSG00000171223 JUNB ## ENSG00000167815 ENSG00000167815 PRDX2 ## ENSG00000198692 ENSG00000198692 EIF1AY ## ENSG00000169575 ENSG00000169575 VPREB1 # store names: tmpName &lt;- rowData(sce)[tmpInd,&quot;external_gene_name&quot;] # the gene name may not be known, so keep the ensembl gene ID in that case: tmpName[tmpName==&quot;&quot;] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][tmpName==&quot;&quot;] tmpName[is.na(tmpName)] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][is.na(tmpName)] rm(tmpInd) g &lt;- plotExpression(sce, rownames(dec.sce)[chosen.genes.index], point_alpha=0.05, jitter=&quot;jitter&quot;) + fontsize g &lt;- g + scale_x_discrete(breaks=rownames(dec.sce)[chosen.genes.index], labels=tmpName) g Challenge: Show violin plots for the 20 genes with the lowest biological component. How do they compare to the those for HVGs chosen above? chosen.genes.index.tmp &lt;- order(dec.sce$bio, decreasing=FALSE)[1:20] tmpInd &lt;- (which(rowData(sce)$ensembl_gene_id %in% rownames(dec.sce)[chosen.genes.index.tmp])) # check: rowData(sce)[tmpInd,c(&quot;ensembl_gene_id&quot;,&quot;external_gene_name&quot;)] ## DataFrame with 20 rows and 2 columns ## ensembl_gene_id external_gene_name ## &lt;character&gt; &lt;character&gt; ## ENSG00000142676 ENSG00000142676 RPL11 ## ENSG00000187514 ENSG00000187514 PTMA ## ENSG00000174748 ENSG00000174748 RPL15 ## ENSG00000232112 ENSG00000232112 TMA7 ## ENSG00000104529 ENSG00000104529 EEF1D ## ... ... ... ## ENSG00000105640 ENSG00000105640 RPL18A ## ENSG00000105372 ENSG00000105372 RPS19 ## ENSG00000063177 ENSG00000063177 RPL18 ## ENSG00000142534 ENSG00000142534 RPS11 ## ENSG00000170889 ENSG00000170889 RPS9 # store names: tmpName &lt;- rowData(sce)[tmpInd,&quot;external_gene_name&quot;] # the gene name may not be known, so keep the ensembl gene ID in that case: tmpName[tmpName==&quot;&quot;] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][tmpName==&quot;&quot;] tmpName[is.na(tmpName)] &lt;- rowData(sce)[tmpInd,&quot;ensembl_gene_id&quot;][is.na(tmpName)] rm(tmpInd) g &lt;- plotExpression(sce, rownames(dec.sce)[chosen.genes.index.tmp], point_alpha=0.05, jitter=&quot;jitter&quot;) + fontsize g &lt;- g + scale_x_discrete(breaks=rownames(dec.sce)[chosen.genes.index.tmp], labels=tmpName) g rm(chosen.genes.index.tmp) 9.3 Session information sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 8 (Core) ## ## Matrix products: default ## BLAS: /opt/R/R-4.0.3/lib64/R/lib/libRblas.so ## LAPACK: /opt/R/R-4.0.3/lib64/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_GB.UTF-8 LC_COLLATE=en_GB.UTF-8 ## [5] LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 ## [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] knitr_1.32 scran_1.18.7 ## [3] scater_1.18.6 SingleCellExperiment_1.12.0 ## [5] SummarizedExperiment_1.20.0 Biobase_2.50.0 ## [7] GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [9] IRanges_2.24.1 S4Vectors_0.28.1 ## [11] BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [13] matrixStats_0.58.0 ggplot2_3.3.3 ## ## loaded via a namespace (and not attached): ## [1] viridis_0.5.1 edgeR_3.32.1 ## [3] sass_0.3.1 BiocSingular_1.6.0 ## [5] jsonlite_1.7.2 viridisLite_0.3.0 ## [7] DelayedMatrixStats_1.12.3 scuttle_1.0.4 ## [9] bslib_0.2.4 assertthat_0.2.1 ## [11] statmod_1.4.35 highr_0.8 ## [13] dqrng_0.2.1 GenomeInfoDbData_1.2.4 ## [15] vipor_0.4.5 yaml_2.2.1 ## [17] pillar_1.6.0 lattice_0.20-41 ## [19] limma_3.46.0 glue_1.4.2 ## [21] beachmat_2.6.4 digest_0.6.27 ## [23] XVector_0.30.0 colorspace_2.0-0 ## [25] cowplot_1.1.1 htmltools_0.5.1.1 ## [27] Matrix_1.2-18 pkgconfig_2.0.3 ## [29] bookdown_0.21 zlibbioc_1.36.0 ## [31] purrr_0.3.4 scales_1.1.1 ## [33] BiocParallel_1.24.1 tibble_3.1.1 ## [35] farver_2.1.0 generics_0.1.0 ## [37] ellipsis_0.3.1 withr_2.4.2 ## [39] magrittr_2.0.1 crayon_1.4.1 ## [41] evaluate_0.14 fansi_0.4.2 ## [43] bluster_1.0.0 beeswarm_0.2.3 ## [45] tools_4.0.3 lifecycle_1.0.0 ## [47] stringr_1.4.0 locfit_1.5-9.4 ## [49] munsell_0.5.0 DelayedArray_0.16.3 ## [51] irlba_2.3.3 compiler_4.0.3 ## [53] jquerylib_0.1.3 rsvd_1.0.3 ## [55] rlang_0.4.10 grid_4.0.3 ## [57] RCurl_1.98-1.3 BiocNeighbors_1.8.2 ## [59] rstudioapi_0.13 igraph_1.2.6 ## [61] labeling_0.4.2 bitops_1.0-6 ## [63] rmarkdown_2.7 gtable_0.3.0 ## [65] DBI_1.1.1 R6_2.5.0 ## [67] gridExtra_2.3 dplyr_1.0.5 ## [69] utf8_1.2.1 stringi_1.5.3 ## [71] ggbeeswarm_0.6.0 Rcpp_1.0.6 ## [73] vctrs_0.3.7 tidyselect_1.1.0 ## [75] xfun_0.22 sparseMatrixStats_1.2.1 "]]
